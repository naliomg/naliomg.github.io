<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Vue简介 | Nali</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Vue简介</h1><a id="logo" href="/.">Nali</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Vue简介</h1><div class="post-meta"><a href="/2019/08/03/vue/#comments" class="comment-count"></a><p><span class="date">Aug 03, 2019</span></p></div><div class="post-content"><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="1-通过脚手架安装"><a href="#1-通过脚手架安装" class="headerlink" title="1.通过脚手架安装"></a>1.通过脚手架安装</h3><pre><code>npm install -g @vue/cli // 全局安装vue/cli脚手架
vue --version // 查看vue版本
vue create hello-world // 创建项目
vue ui // 以图形化界面管理项目
</code></pre><h3 id="2-目录结构"><a href="#2-目录结构" class="headerlink" title="2.目录结构"></a>2.目录结构</h3><p><code>/public</code>目录下存放的<code>index.html</code>为基础html，vue生成的html页面文件均是以此文件为模板基础产生的。<br><code>/src</code>目录下为项目源文件，分为<code>assets</code>资源文件夹、<code>components</code>组件文件夹、<code>views</code>页面文件夹、<code>store</code>状态管理文件夹、<code>modules</code>多入口文件夹，单入口时不需要。<br><code>/dist</code>目录为发布目录。</p>
<h3 id="3-简介"><a href="#3-简介" class="headerlink" title="3.简介"></a>3.简介</h3><p>单页面单入口时，<code>main.js</code>为入口文件，会将<code>vue</code>实例挂载到<code>#app</code>节点上。<code>.vue</code>文件包含<code>&lt;template&gt;&lt;/template&gt;</code>、<code>&lt;script&gt;&lt;/script&gt;</code>、<code>&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</code>。注意<code>style</code>样式要注明样式文件语言，<code>template</code>内首层节点为单节点。</p>
<h3 id="4-vue-config-js文件配置简介"><a href="#4-vue-config-js文件配置简介" class="headerlink" title="4.vue.config.js文件配置简介"></a>4.vue.config.js文件配置简介</h3><pre><code>module.exports = {
  publicPath: &apos;/wxapp/&apos;, // 一般为public根路径
  outputDir: &apos;dist/wxapp&apos;, // build的项目存放路径
  assetsDir： &apos;&apos;, // 放置生成的静态资源(js、css、img、fonts)的(相对于 outputDir 的)目录
  indexPath: &apos;index.html&apos;, // 指定生成的 index.html 的输出路径 (相对于 outputDir)，也可以是一个绝对路径
  pages: { // 多页面入口配置
    page1: {
      entry: &apos;src/modules/page1/page1.js&apos;, // 应用入口配置，相当于单页面应用的main.js，必需项
      template: &apos;public/index.html&apos;, // 应用的模版，相当于单页面应用的public/index.html，可选项，省略时默认与模块名一致
      filename: &apos;page1.html&apos;, // 编译后在dist目录的输出文件名，可选项，省略时默认与模块名一致
      title: &apos;page1标题&apos;, // 标题，可选项，一般情况不使用，通常是在路由切换时设置title；需要注意的是使用title属性template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
    },
    page2: {}
  },
  // 其余项目配置详见
}
</code></pre><h3 id="5-多入口页面"><a href="#5-多入口页面" class="headerlink" title="5.多入口页面"></a>5.多入口页面</h3><p>多页面入口时，不仅需要配置<code>vue.config.js</code>文件中的<code>pages</code>字段，还要将多页面文件的入口文件脚本、入口vue文件分别处理，若有router路由配置的话，还应分别配置路由router文件。入口JS文件:</p>
<pre><code>import Vue from &apos;vue&apos;
import axios from &apos;axios&apos;
import VueAxios from &apos;vue-axios&apos;
import store from &apos;@/store/store.js&apos;
import MainLoan from &apos;./MainLoan.vue&apos;
import &apos;@/assets/css/cssreset-mobile.css&apos;
import &apos;we-vue/lib/style.css&apos;
import WeVue from &apos;we-vue&apos;
import &apos;@/assets/css/main-mobile.css&apos;
import router from &apos;./router&apos;
import Fastclick from &apos;fastclick&apos;
Vue.config.productionTip = false
Vue.use(WeVue)
Vue.use(VueAxios, axios)
Fastclick.attach(document.body)
new Vue({
  router, // 挂载路由
  store, // 挂载全局状态
  render: h =&gt; h(MainLoan) // 初始模板选择
}).$mount(&apos;#app&apos;)
</code></pre><h3 id="6-vue实例"><a href="#6-vue实例" class="headerlink" title="6.vue实例"></a>6.vue实例</h3><p><code>&lt;script&gt;&lt;/script&gt;</code>脚本标签内，基本类型如下：</p>
<pre><code>import HelloWorld from &apos;./components/HelloWorld.vue&apos;
export default {
  name: &apos;app&apos;, // 页面或者组件名称
  components: { // 本组件需要使用的下级组件声明
    HelloWorld
  },
  props: {
        prop1: String/Object/Number // 上级组件传递的参数
  },
  data() { // data数据，需要使用函数返回
    return {
    index: 1,
      temp: &apos;nali&apos;,
      title: &apos;ttx&apos;,
      watchIndex: 1,
    }
  },
  computed: { // 计算属性，监听值无变化时，会有计算缓存，不会重复求值
        getIndex() {
          return this.index + 1
        }
  },
  methods: { // 内部方法定义
        test() {
          console.log(&apos;test&apos;)
        }
  }，
    watch: { // 监听实例数据变动，可用于异步或开销较大的处理，一般无返回值
        index(value) {
            this.watchIndex = this.index
        }
    },
  filters: { // 过滤器，对传入的值进行包装处理
        capitalize(value) {
            return value.toString()    
        },
    },
  // 以下为生命周期回调
  beforeCreate() {}, // 实例创建之前调用
  created() {}, // 实例创建成功，此时 data 中的数据显示出来了
  beforeMount() {}, // 数据中的 data 在模版中先占一个位置
  mounted() {}, // 模版中的 data 数据直接显示出来了
  beforeUpdate() {}, // 当 data 数据发生变化调用，发生在虚拟 DOM 重新渲染和打补丁之前
  updated() {}, // 数据更改导致的虚拟 DOM 重新渲染和打补丁
  beforeDestroy() {}, // 在 vue 实例销毁之前调用，此时实例任然可用
  destroyed() {}, // 在vue实例销毁之后调用，实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁
}
</code></pre><h3 id="7-数据展示绑定"><a href="#7-数据展示绑定" class="headerlink" title="7.数据展示绑定"></a>7.数据展示绑定</h3><p>模板展示内容内，通过<code></code>进行绑定，如<code>&lt;div&gt;&lt;/div&gt;</code>；若要进行一次性插值，节点上加入<code>v-once</code>指令即可，次节点内数据绑定一次后将不会随data数据变化而更新。这个称为 Mustache 语法。Mustache语法不能用于HTML节点上，节点上应该使用vue指令。<br>Mustache语法内可以使用JS表达式，且只能为单个表达式。</p>
<pre><code>{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
</code></pre><h3 id="8-vue指令"><a href="#8-vue指令" class="headerlink" title="8.vue指令"></a>8.vue指令</h3><p>指令是带有<code>v-</code>前缀的特殊特性。指令后数据绑定直接使用data属性即可，不用Mustache语法。</p>
<p><code>v-bind:</code>指令可以用于响应式地更新HTML特性：<code>&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</code>，<code>v-bind:</code>可简写为<code>:</code>；<br><code>v-on:</code>用于监听 DOM 事件：<code>&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</code>，<code>v-on:</code>可简写为<code>@</code>；<br><code>v-if:</code>用于条件性地渲染一块内容，<code>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no&lt;/h1&gt;</code>；<br><code>v-show:</code>用于节点的显示与隐藏；<br><code>v-for:</code>用于循环渲染；<br><code>v-model:</code>用于数据双向绑定；</p>
<h3 id="9-指令修饰符"><a href="#9-指令修饰符" class="headerlink" title="9.指令修饰符"></a>9.指令修饰符</h3><p><code>.</code>修饰符半角句号<code>.</code>指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。修饰符可以级联使用。</p>
<pre><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;
</code></pre><p>常用修饰符：<br>事件修饰：</p>
<pre><code>`.stop`: event.stopPropagation()，防止事件冒泡;
`.prevent`: event.preventDefault()，防止执行预设的行为;
`.capture`: 与事件冒泡的方向相反，事件捕获由外到内;
`.self`: 只会触发自己范围内的事件，不包含子元素;
`.once`: 只会触发一次;
`.passive`: 不会等待事件回调执行完毕才继续执行下一次事件，等于事件回调时异步的。有助于提升连续触发事件的性能。
</code></pre><p>键盘修饰符：</p>
<pre><code>`.enter`：回车键;
`.tab`：制表键;
`.delete`：含delete和backspace键;
`.esc`：返回键;
`.space`: 空格键;
`.up`：向上键;
`.down`：向下键;
`.left`：向左键;
`.right`：向右键;
类似于`@keyup.esc`。
</code></pre><p>鼠标修饰符：</p>
<pre><code>`.left`：鼠标左键;
`.middle`：鼠标中间滚轮;
`.right`：鼠标右键;
</code></pre><p>自定义按键修饰符别名：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt;
&lt;/div&gt;

Vue.config.keyCodes.f5 = 116
</code></pre><h3 id="10-class与style绑定"><a href="#10-class与style绑定" class="headerlink" title="10.class与style绑定"></a>10.class与style绑定</h3><p>通过<code>v-bind:class=</code>指令动态地切换节点class属性。这个元素上已经存在的类不会被覆盖。</p>
<p>对象语法：</p>
<pre><code>&lt;div class=&quot;static&quot; v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;&lt;/div&gt;
// vue实例中
data() {
    return {
        isActive: true,
        hasError: 1
    }
}
</code></pre><p>也可以直接使用class的对象：</p>
<pre><code>&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;

data: {
  classObject: { // 此对象放于计算属性最好，可以动态结算更新
    active: true,
    &apos;text-danger&apos;: false
  }
}
</code></pre><p>数组语法，类似于直接将class名列出给节点：</p>
<pre><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;
data: {
  activeClass: &apos;active&apos;,
  errorClass: &apos;text-danger&apos;
}
// &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;
</code></pre><p>内联样式绑定：</p>
<pre><code>&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt;
data: {
  activeColor: &apos;red&apos;,
  fontSize: 30
}
// 或者
&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;
data: { // 同样，计算属性更加灵活方便
  styleObject: {
    color: &apos;red&apos;,
    fontSize: &apos;13px&apos;
  }
}
// 数组语法可以将多个样式对象应用到同一个元素上
&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="11-条件渲染"><a href="#11-条件渲染" class="headerlink" title="11.条件渲染"></a>11.条件渲染</h3><p><code>v-if</code>预计传值得真假判断去确定是否需要渲染html结构；</p>
<pre><code>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
</code></pre><p>当需要批量显示与隐藏多节点时，可以使用<code>&lt;template&gt;</code>加<code>v-if</code>指令进行包裹，最终渲染不会包含<code>&lt;template&gt;</code>节点。</p>
<pre><code>&lt;template v-if=&quot;ok&quot;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/template&gt;
</code></pre><p><code>v-if</code>对应的<code>v-else</code>与<code>v-else-if</code>指令：</p>
<pre><code>&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;
  A
&lt;/div&gt;
&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;
  B
&lt;/div&gt;
&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;
  C
&lt;/div&gt;
&lt;div v-else&gt;
  Not A/B/C
&lt;/div&gt;
</code></pre><p>另外，vue在切换渲染时，会服用已有的元素，若要表明两元素不可服用，需要在元素节点上定义不同<code>key</code>值：</p>
<pre><code>&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;
&lt;/template&gt;
</code></pre><p><code>v-show</code>用于节点的显示与隐藏，仅仅变换了<code>display</code>值；<code>v-show</code>不支持<code>&lt;template&gt;</code>元素。</p>
<h3 id="12-循环渲染"><a href="#12-循环渲染" class="headerlink" title="12.循环渲染"></a>12.循环渲染</h3><p><code>v-for:</code>循环渲染。<code>v-for</code>节点渲染时，节点会被不断复用，当数据顺序变更或减少时，节点不会全部重新渲染，但会就近更新节点简单数据，因此只适用于不依赖子组件状态的情况。<br>当节点需要跟踪每个节点身份时，请使用<code>v-bind:key</code>为节点添加唯一标示。</p>
<pre><code>&lt;ul id=&quot;example-1&quot;&gt;
  &lt;li v-for=&quot;item in items&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
var example1 = new Vue({
  el: &apos;#example-1&apos;,
  data: {
    items: [
      { message: &apos;Foo&apos; },
      { message: &apos;Bar&apos; }
    ]
  }
})
// index为渲染索引
&lt;ul id=&quot;example-2&quot;&gt;
  &lt;li v-for=&quot;(item, index) in items&quot;&gt;
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
var example2 = new Vue({
  el: &apos;#example-2&apos;,
  data: {
    parentMessage: &apos;Parent&apos;,
    items: [
      { message: &apos;Foo&apos; },
      { message: &apos;Bar&apos; }
    ]
  }
})
</code></pre><p>也可以用<code>of</code>替代<code>in</code>作为分隔符，当使用<code>in</code>时，可以遍历对象属性。</p>
<pre><code>&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;
new Vue({
  el: &apos;#v-for-object&apos;,
  data: {
    object: {
      title: &apos;How to do lists in Vue&apos;,
      author: &apos;Jane Doe&apos;,
      publishedAt: &apos;2016-04-10&apos;
    }
  }
})
// name为属性名
&lt;div v-for=&quot;(value, name) in object&quot;&gt;
  {{ name }}: {{ value }}
&lt;/div&gt;
// index为索引
&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;
  {{ index }}. {{ name }}: {{ value }}
&lt;/div&gt;
</code></pre><p>为循环节点添加唯一标示，不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值：</p>
<pre><code>&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;&lt;!-- 内容 --&gt;&lt;/div&gt;
</code></pre><p><code>v-for</code>也可以接受整数。在这种情况下，它会把模板重复对应次数。</p>
<pre><code>&lt;div&gt;
  &lt;span v-for=&quot;n in 10&quot;&gt;{{ n }} &lt;/span&gt;
&lt;/div&gt;
</code></pre><p><code>v-for</code>指令与<code>v-if</code>指令同时使用时，<code>v-for</code>指令优先级高于<code>v-if</code>指令。</p>
<h3 id="13-数组数据的更新检测"><a href="#13-数组数据的更新检测" class="headerlink" title="13.数组数据的更新检测"></a>13.数组数据的更新检测</h3><p>vue数据长度隐式更新或数组被替换时，vue会触发数据更新与视图更新；如<code>push();pop();shift();unshift();splice();sort();reverse()</code>或数组替换方法均会触发数据更新。<br>但当用索引更新某一个数组项或者显示地定义数组长度时，数据更新不会检测到。如<code>arr[1] = 2; arr.length = 5;</code><br>当需要使用上述方式时，可以使用以下方式变更触发视图更新：</p>
<pre><code>Vue.set(vm.items, indexOfItem, newValue)
vm.items.splice(indexOfItem, 1, newValue)
vm.$set(vm.items, indexOfItem, newValue)
vm.items.splice(newLength)
</code></pre><p>同理，对象数据变更时，vue也不能检测对象属性的添加与删除。对于已经创建的实例，Vue 不允许动态添加根级别的<strong>响应式属性</strong>，但可以通过<code>Vue.set</code>向对象中添加响应属性。</p>
<pre><code>var vm = new Vue({
  data: {
    userProfile: {
      name: &apos;Anika&apos;
    }
  }
})
Vue.set(vm.userProfile, &apos;age&apos;, 27)
vm.$set(vm.userProfile, &apos;age&apos;, 27) // 或直接调用通用方法
</code></pre><p>若有多个属性要一次性添加，不应该将多个属性直接添加到原对象上，而是应该创建一个新对象去替换原对象：</p>
<pre><code>vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: &apos;Vue Green&apos;
})
</code></pre><h3 id="14-事件处理"><a href="#14-事件处理" class="headerlink" title="14.事件处理"></a>14.事件处理</h3><p><code>v-on</code>指令监听DOM事件；若需要在内联语句处理器中访问原始的DOM事件。可以用特殊变量<code>$event</code>把它传入方法；</p>
<pre><code>&lt;button @click=&quot;test($event)&quot;&gt;&lt;/button&gt;
// ...
methods: {
    test(e) {
        e.stopPropagation()
    }
}
</code></pre><h3 id="15-表单输入绑定"><a href="#15-表单输入绑定" class="headerlink" title="15.表单输入绑定"></a>15.表单输入绑定</h3><p>用<code>v-model</code>指令在表单<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>及<code>&lt;select&gt;</code>元素上创建双向数据绑定。<code>v-model</code>会忽略表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>的初始值。<code>input</code>和<code>textarea</code>输入时，中文、日文和韩文等输入法，没有输入完毕不会更新数据。</p>
<p>修饰符：<br><code>.lazy</code>：<code>v-model</code>在每次<code>input</code>事件触发后将输入框的值与数据进行同步(除了上述输入法组合文字时)。你可以添加<code>.lazy</code>修饰符，从而转变为使用<code>change</code> 事件进行同步;</p>
<pre><code>&lt;input v-model.lazy=&quot;msg&quot; &gt;
</code></pre><p><code>.trim</code>: 自动过滤用户输入的首尾空白字符;</p>
<h3 id="16-组件基础"><a href="#16-组件基础" class="headerlink" title="16.组件基础"></a>16.组件基础</h3><p>对于重复性的结构，组件的使用将大大简化节点结构的书写。组件和页面类似，均有自己独立的实例与作用域。组件使用时，需要先注册才能被使用。注册分全局注册和局部注册。组件使用时，需要使用短横线分隔命名。</p>
<pre><code>&lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; // 使用
import HelloWorld from &apos;@/components/HelloWorld.vue&apos; // 引入
export default {
  name: &apos;home&apos;,
  inheritAttrs: false, // 组件不继承使用父组件传入的prop为定义的属性
  components: { // 注册
    HelloWorld
  }
}
</code></pre><p>向子组件传递数据<code>props</code></p>
<pre><code>// HelloWorld组件中
export default {
  name: &apos;HelloWorld&apos;,
  props: {
    msg: String
  }
}
</code></pre><p>每一个组件必须只有一个根节点，多个时会报错。父组件的数据变化可以引起子组件的数据变化，但子组件内数据变化不会传递到父组件，但子组件需要通知父组件时，可以使用<code>$emit()</code>向父组件派发事件，当父组件由对该事件进行监听时，就会触发父组件事件，达到子组件通知父组件的效果。</p>
<pre><code>// 父组件
&lt;blog-post  v-on:enlarge-text=&quot;enlargeText&quot;&gt;&lt;/blog-post&gt;
data() {
    postFontSize: 16
},
methods: {
    enlargeText(addition) { // 也可以用$event进行访问
        this.postFontSize += addition
    }
}

// 子组件
&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;, 0.1)&quot;&gt;
  Enlarge text
&lt;/button&gt;
</code></pre><p>当在组件上使用<code>v-model</code>进行值绑定时，等价于：</p>
<pre><code>&lt;input v-model=&quot;searchText&quot;&gt;
&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; // value和input必须绑定才有效果

&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt;
Vue.component(&apos;custom-input&apos;, {
    props: [&apos;value&apos;], // 组件的props必须包含value
  template: &apos;&lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;&gt; // 事件需通过input传出
})
</code></pre><p>组件的<code>prop</code>可以是数组，可以是对象集。当使用对象集时，可以指定各个属性的接受值类型。任何类型的值都可以传递给<code>prop</code>。</p>
<pre><code>props: [&apos;title&apos;, &apos;likes&apos;, &apos;isPublished&apos;, &apos;commentIds&apos;, &apos;author&apos;]
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
}

Vue.component(&apos;my-component&apos;, {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number, Date, Symbol],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: &apos;hello&apos; }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1
      }
    }
  }
})
</code></pre><p>若需要向<code>prop</code>传入一个对象的所有属性，可使用不带参数的<code>v-bind</code>：</p>
<pre><code>post: { id: 1, title: &apos;My Journey with Vue&apos; }
&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;
// 等价于
&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;
</code></pre><p>注意组件的数据传递请遵守单项数据原则，由父组件去改变传递的数据值，子组件不应该改变传递的值，若有需要，请使用子组件事件派发通知父组件改变。</p>
<p>组件的<code>prop</code>接收到未定义的属性时，未定义的属性会直接添加到组件的根节点上。另外，父节点传入的属性一般会覆盖子组件的同名属性，但<code>class</code>与<code>style</code>会并存叠加。</p>
<h3 id="17-自定义事件"><a href="#17-自定义事件" class="headerlink" title="17.自定义事件"></a>17.自定义事件</h3><p>自定义事件的事件名不会用作一个JS变量名或者属性名，所有没有必要使用驼峰结构，且<code>v-on</code>事件监听时，会自动转换为小写，故推荐使用<code>-</code>分隔的命名方式。</p>
<h3 id="18-插槽"><a href="#18-插槽" class="headerlink" title="18.插槽"></a>18.插槽</h3><p>自定义的组件中，可以使用模板代码或html结构对组件进行合成，可以理解为<code>prop</code>接收的是JS数据，而插槽接收的是html结构。如果组件内没有包含<code>&lt;slot&gt;</code>元素，则组件标签内所有内容均会被舍弃。</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;Your Profile&lt;/navigation-link&gt;
// 模板
&lt;a v-bind:href=&quot;url&quot; class=&quot;nav-link&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;
// 渲染为
&lt;a v-bind:href=&quot;/profile&quot; class=&quot;nav-link&quot;&gt;Your Profile&lt;/a&gt;
</code></pre><p>卡槽的作用域与组件的作用域一致，父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
<p>预置内容：当一个组件中有<code>&lt;slot&gt;</code>结构但是父组件使用该组件时，没有传递<code>slot</code>值，则会展示出默认的预置内容。</p>
<pre><code>&lt;button type=&quot;submit&quot;&gt;&lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt;
// 使用
&lt;submit-button&gt;&lt;/submit-button&gt;
// 渲染
&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
// 使用
&lt;submit-button&gt;save&lt;/submit-button&gt;
// 渲染
&lt;button type=&quot;submit&quot;&gt;save&lt;/button&gt;
</code></pre><p>具名插槽：<code>&lt;slot&gt;</code>插槽带有<code>name</code>属性值，可以让父组件在使用时，传递特定的内容到指定的位置。<code>&lt;slot&gt;</code>属性在不设置<code>name</code>属性时，默认<code>name</code>属性值为<code>default</code>。父组件中任何没有被包裹在带有<code>v-slot</code>的<code>&lt;template&gt;</code>中的内容均会被视为默认<code>&lt;slot&gt;</code>的内容。注意<code>v-slot</code>指令只能用于<code>&lt;template&gt;</code>节点上，除非组件只有默认插槽，不过这时候有无<code>v-slot</code>已经不重要了。</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
// 使用
&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;
  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;
  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here&apos;s some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
// 渲染
&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;p&gt;Here&apos;s some contact info&lt;/p&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre><p>作用域插槽：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译；若需要向卡槽中传递数据，则可以使用插槽<code>prop</code>。在<code>&lt;slot&gt;</code>上绑定具名属性值，在父组件中给<code>v-slot</code>带一个值来定义我们提供的插槽<code>prop</code>的名字。</p>
<pre><code>&lt;span&gt;&lt;slot v-bind:user=&quot;user&quot;&gt;{{ user.lastName }}&lt;/slot&gt;&lt;/span&gt;
&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre><h3 id="19-动态组件"><a href="#19-动态组件" class="headerlink" title="19.动态组件"></a>19.动态组件</h3><p>当组件通过<code>is</code>属性进行动态切换时，不能组件之间会进行不断的销毁与创建。若需要将组件销毁前的状态保存下来，可以使用<code>&lt;keep-alive&gt;</code>元素进行包裹。当使用<code>&lt;keep-alive&gt;</code>时，内部组件必须要有唯一名字，否则无效。</p>
<pre><code>&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;keep-alive&gt;
  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre><h3 id="20-边界情况"><a href="#20-边界情况" class="headerlink" title="20.边界情况"></a>20.边界情况</h3><p><strong>访问根实例</strong>：在每个<code>new Vue</code>实例的子组件中，其根实例可以通过<code>$root</code>属性进行访问。</p>
<pre><code>new Vue({
  data: { foo: 1 },
  computed: {
    bar: function () { /* ... */ }
  },
  methods: {
    baz: function () { /* ... */ }
  }
})
// 子组件中，可以把根vue实例作为一个简单的全局store来使用：如下
this.$root.foo
this.$root.foo = 2
this.$root.bar
this.$root.baz()
</code></pre><p><strong>访问父组件实例</strong>：<code>$parent</code>属性可以用来从一个子组件访问父组件的实例。与<code>$root</code>类似，但不建议使用。</p>
<p><strong>访问子组件实例或者子元素</strong>：可以在子组件或者节点上添加<code>ref</code>属性赋予一个标记ID，然后通过<code>$refs</code>访问这个组件或者元素。注意<code>$refs</code>属性只在定义<code>ref</code>的组件实例内有效。同样地，<code>ref</code>也应尽量减少使用。</p>
<pre><code>// base-input组件
&lt;input ref=&quot;input&quot;&gt;
// 使用base-input组件
&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;
methods: {
  // 用来从父级组件聚焦输入框
  focus: function () {
    this.$refs.input.focus()
  }
}
</code></pre><h3 id="21-进入离开过渡动画"><a href="#21-进入离开过渡动画" class="headerlink" title="21.进入离开过渡动画"></a>21.进入离开过渡动画</h3><p><strong>单元素/组件的过渡</strong>:使用<code>&lt;transition name=&quot;actionName&quot;&gt;&lt;/transition&gt;</code>包裹。若过渡没有检测到CSS动画定义，也没有检测到钩子函数，则节点的显示与隐藏将会在下一帧（显示动画帧update）执行</p>
<pre><code>&lt;div id=&quot;demo&quot;&gt;
  &lt;button v-on:click=&quot;show = !show&quot;&gt;
    Toggle
  &lt;/button&gt;
  &lt;transition name=&quot;fade&quot;&gt;
    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
  &lt;/transition&gt;
&lt;/div&gt;

new Vue({
  el: &apos;#demo&apos;,
  data: {
    show: true
  }
})

.fade-enter-active, .fade-leave-active { // 动画执行时样式
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to { // 渐入状态和渐出状态
  opacity: 0;
}
</code></pre><p><strong>过渡类名</strong>:<br><code>v-enter</code>: 元素被插入之前状态，插入之后下一帧移除；<br><code>v-enter-active</code>: 元素被插入的前一帧生效，进入动画执行时间内有效，动画完成后移除；<br><code>v-enter-to</code>: 元素被插入后的下一帧生效，动画完成后移除；有点类似于<code>enter-active</code>，但生效时间晚3帧；<br><code>v-leave</code>: 元素离开动画触发那一帧生效，下一帧移除；<br><code>v-leave-active</code>: 元素离开动画触发那一帧生效，离开动画执行时间内有效，动画完成后移除；<br><code>v-leave-to</code>: 元素离开动画触发下一帧生效，离开动画执行时间内有效，动画完成后移除；</p>
<p><strong>自定义过渡类名</strong>：<br>用<code>enter-class</code>、<code>enter-active-class</code>、<code>enter-to-class</code>、<code>leave-class</code>、<code>leave-active-class</code>、<code>leave-to-class</code>自定义动画类名，他们的优先级高于普通类名。用于vue过渡动画和第三方库结合较好。</p>
<pre><code>&lt;transition
name=&quot;custom-classes-transition&quot;
enter-active-class=&quot;animated tada&quot;
leave-active-class=&quot;animated bounceOutRight&quot;
&gt;
    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
&lt;/transition&gt;
</code></pre><p><strong>多元素多节点动画</strong>：<br><code>&lt;transition-group&gt;&lt;/transition-group&gt;</code></p>
<h3 id="22-混入"><a href="#22-混入" class="headerlink" title="22.混入"></a>22.混入</h3><p>类似于对象继承的一个东西，组件在实例化之前将预先设定或者公共的属性添加到实例化对象上。当有许多组件有公共的部分的时候使用起来就比较方便。<br>data对象会如下方式合并：</p>
<pre><code>// 混入对象
var mixin = {
  data: function () {
    return {
      message: &apos;hello&apos;,
      foo: &apos;abc&apos;
    }
  }
}
// 组件使用
new Vue({
  mixins: [mixin],
  data: function () {
    return {
      message: &apos;goodbye&apos;,
      bar: &apos;def&apos;
    }
  },
  created: function () {
    console.log(this.$data)
    // =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; }
  }
})
</code></pre><p>混入对象会依次优先被复制到组件上，组件定义的内容会最后复制到组件上，产生自定义修改效果。<strong>另外</strong>：同名的钩子函数将会被合并为一个数组，同名钩子函数会依次执行。其实可以将钩子函数看做一个订阅事件，当此事件被多次订阅后，肯定也会多次执行。</p>
<pre><code>var mixin = {
  created: function () {
    console.log(&apos;混入对象的钩子被调用&apos;)
  }
}
new Vue({
  mixins: [mixin],
  created: function () {
    console.log(&apos;组件钩子被调用&apos;)
  }
})
// =&gt; &quot;混入对象的钩子被调用&quot;
// =&gt; &quot;组件钩子被调用&quot;
</code></pre><p>值为对象的选项，例如<code>methods</code>、<code>components</code>和<code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。与<code>data</code>合并方式类似。<code>Vue.extend()</code>也是如此。</p>
<pre><code>var mixin = {
  methods: {
    foo: function () {
      console.log(&apos;foo&apos;)
    },
    conflicting: function () {
      console.log(&apos;from mixin&apos;)
    }
  }
}

var vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function () {
      console.log(&apos;bar&apos;)
    },
    conflicting: function () {
      console.log(&apos;from self&apos;)
    }
  }
})

vm.foo() // =&gt; &quot;foo&quot;
vm.bar() // =&gt; &quot;bar&quot;
vm.conflicting() // =&gt; &quot;from self&quot;
</code></pre><p><strong>全局混入</strong>：我们可以使用<code>Vue.mixin({})</code>进行全局混入，当使用全局混入时，以后使用的每一个vue实例都会受到此影响(包括第三方组件)，所有不建议使用。</p>
<h3 id="23-自定义指令"><a href="#23-自定义指令" class="headerlink" title="23.自定义指令"></a>23.自定义指令</h3><p>全局定义时，可以使用<code>Vue.directive(&#39;directive-name&#39;, {})</code>进行定义；当然也可以在组件内使用局部定义<code>directives</code>属性。</p>
<pre><code>// 注册一个全局自定义指令 `v-focus`
Vue.directive(&apos;focus&apos;, {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
// 局部定义
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
</code></pre><p>定义时，需要定义指令的触发时间，也就是指令的钩子函数：<br><code>bind</code>: 只调用一次，指令第一次绑定到元素时调用。<br><code>insert</code>: 被绑定元素插入父节点时调用(仅保证父节点存在，但不一定已被插入文档中)。<br><code>update</code>: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。<br><code>componentUpdated</code>: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。<br><code>unbind</code>: 只调用一次，指令与元素解绑时调用。</p>
<p>钩子函数的参数请参考vue文档。</p>
</div><div class="tags"><a href="/tags/vue/">vue</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/08/03/vue-router/" class="pre">vue-router简介</a><a href="/2019/02/02/移动端HTML适配/" class="next">移动端HTML适配</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-通过脚手架安装"><span class="toc-text">1.通过脚手架安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-目录结构"><span class="toc-text">2.目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-简介"><span class="toc-text">3.简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-vue-config-js文件配置简介"><span class="toc-text">4.vue.config.js文件配置简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-多入口页面"><span class="toc-text">5.多入口页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-vue实例"><span class="toc-text">6.vue实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-数据展示绑定"><span class="toc-text">7.数据展示绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-vue指令"><span class="toc-text">8.vue指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-指令修饰符"><span class="toc-text">9.指令修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-class与style绑定"><span class="toc-text">10.class与style绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-条件渲染"><span class="toc-text">11.条件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-循环渲染"><span class="toc-text">12.循环渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-数组数据的更新检测"><span class="toc-text">13.数组数据的更新检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-事件处理"><span class="toc-text">14.事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-表单输入绑定"><span class="toc-text">15.表单输入绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-组件基础"><span class="toc-text">16.组件基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-自定义事件"><span class="toc-text">17.自定义事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-插槽"><span class="toc-text">18.插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-动态组件"><span class="toc-text">19.动态组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-边界情况"><span class="toc-text">20.边界情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-进入离开过渡动画"><span class="toc-text">21.进入离开过渡动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-混入"><span class="toc-text">22.混入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-自定义指令"><span class="toc-text">23.自定义指令</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/css单位/">css长度单位</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/CSS3实现3D旋转/">CSS3实现3D旋转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/03/vue-router/">vue-router简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/03/vue/">Vue简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/02/移动端HTML适配/">移动端HTML适配</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/css-reset/">css-reset</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/js工具函数/">JS常用工具函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/05/koa/">Koa2使用简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/TypeScript小计(1)/">TypeScript小记(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/22/kue任务队列使用/">kue任务队列使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具使用/">工具使用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技巧/">技巧</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/语法/">语法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言/">语言</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/ts/" style="font-size: 15px;">ts</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/md/" style="font-size: 15px;">md</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/cdn/" style="font-size: 15px;">cdn</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/其他/" style="font-size: 15px;">其他</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/笔记/" style="font-size: 15px;">笔记</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p><span> Copyright &copy;<a href="/." rel="nofollow">Nali.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b8feba972650c12d2536f2cfeb9a72bf";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>