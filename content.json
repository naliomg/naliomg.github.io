[{"title":"kue任务队列使用","date":"2018-03-22T13:58:54.000Z","path":"2018/03/22/kue任务队列使用/","text":"kue任务队列使用kue三方库用于构建node的任务队列非常方便有效。注意kue是基于redis的，kue的队列将会存储于redis中，避免了主进程中的node内存的分配与阻塞。 // 安装 npm install kue --save var kue = require(&apos;kue&apos;) var cluster = require(&apos;cluster&apos;) var config = require(&apos;../configs/configs&apos;) var queues = kue.createQueue({ prefix: &apos;q&apos;, redis: { port: config.REDIS_PORT, host: config.REDIS_HOST, auth: config.REDIS_PASSWORD, db: 15 } }) function createJob() { // 注意创建的任务名不要为&apos;test&apos;，不然任务执行会有问题，此处有坑！ let job = queues.create(&quot;jobName&quot;, { data: &apos;test&apos; }) .attempts(5) .backoff(true) .save(function(err) { if(err) { console.log(err) return } console.log(&apos;创建任务&apos; + job.id + &apos;成功!&apos;) }); setTimeout(createJob, 0); } if (cluster.isMaster) { console.log(&quot;主线程 %s 工作!创建任务！&quot;, process.pid) for (let i = 0; i &lt; 4; i++) { cluster.fork(); } createJob(); cluster.on(&apos;exit&apos;, function (worker, code) { console.log(&quot;worker线程 %s is died by %s&quot;, worker.process.pid, code); }); } else { queues.process(&apos;jobName&apos;, (job, done)=&gt; { console.log(&quot;worker线程 %s 处理 job[%d][%s]&quot;, process.pid, job.id, job.data.name); setTimeout(done, 0); }); } THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"redis-cli指令","date":"2018-03-22T13:35:43.000Z","path":"2018/03/22/redis-cli指令/","text":"redis-cli 常用指令redis cli命令 redis安装后，在src和/usr/local/bin下有几个以redis开头的可执行文件，称为redis shell，这些可执行文件可做很多事情。 可执行文件作用 redis-server 启动redis redis-cli redis命令行工具 redis-benchmark 基准测试工具 redis-check-aof AOF持久化文件检测工具和修复工具 redis-check-dump RDB持久化文件检测工具和修复工具 redis-sentinel 启动redis-sentinel 本文重点介绍的redis-cli命令。 可以使用两种方式连接redis服务器。 第一种：交互式方式 redis-cli -h {host} -p {port}方式连接，然后所有的操作都是在交互的方式实现，不需要再执行redis-cli了。 $redis-cli -h 127.0.0.1-p 6379 127.0.0.1：6379>set hello world OK 127.0.0.1：6379>get hello \"world\" 第二种方式：命令方式 redis-cli -h {host} -p {port} {command}直接得到命令的返回结果。 $redis-cli -h 127.0.0.1-p 6379 get hello \"world\" redis-cli包含很多参数，如-h，-p，要了解全部参数，可用redis-cli -help命令。 第一部分 命令方式介绍一些重要参数以及使用场景。 1、-r 代表将命令重复执行多次 $redis-cli -r 3 ping PONG PONG PONG ping 命令可用于检测redis实例是否存活，如果存活则显示PONG。 2、-i 每隔几秒(如果想用ms，如10ms则写0.01)执行一次命令，必须与-r一起使用。 $redis-cli -r 3 -i 1 ping PONG PONG PONG $redis-cli -r 10 -i 1 info|grep used_memory_human used_memory_human:2.95G ..................................... used_memory_human:2.95G 每隔1秒输出内存的使用量，一共输出10次。 $redis-cli -h ip -p port info server|grep process_id process_id:999 获取redis的进程号999 3、-x 代表从标准输入读取数据作为该命令的最后一个参数。 $echo \"world\" |redis-cli -x set hello Ok 4、-c 连接集群结点时使用，此选项可防止moved和ask异常。 5、-a 如配置了密码，可用a选项。 6、--scan 和 --pattern 用于扫描指定模式的键，相当于scan命令。 7、--slave 当当前客户端模拟成当前redis节点的从节点，可用来获取当前redis节点的更新操作。合理利用可用于记录当前连接redis节点的一些更新操作，这些更新可能是实开发业务时需要的数据。 8、--rdb 会请求redis实例生成并发送RDB持久化文件，保存在本地。可做定期备份。 9、--pipe 将命令封装成redis通信协议定义的数据格式，批量发送给redis执行。 10、--bigkeys 统计bigkey的分布，使用scan命令对redis的键进行采样，从中找到内存占用比较大的键，这些键可能是系统的瓶颈。 11、--eval 用于执行lua脚本 12、--latency 有三个选项，--latency、--latency-history、--latency-dist。它们可检测网络延迟，展现的形式不同。 13、--stat 可实时获取redis的重要统计信息。info命令虽然比较全，但这里可看到一些增加的数据，如requests（每秒请求数） 14、--raw 和 --no-raw: --no-raw 要求返回原始格式。--raw 显示格式化的效果。 第二部分redis-cli 命令有很多。比如 连接操作相关的命令 默认直接连接 远程连接-h 192.168.1.20 -p 6379 ping：测试连接是否存活如果正常会返回pong echo：打印 select：切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值 quit：关闭连接（connection） auth：简单密码认证 服务端相关命令 time：返回当前服务器时间 client list: 返回所有连接到服务器的客户端信息和统计数据 参见http://redisdoc.com/server/client_list.html client kill ip:port：关闭地址为 ip:port 的客户端 save：将数据同步保存到磁盘 bgsave：将数据异步保存到磁盘 lastsave：返回上次成功将数据保存到磁盘的Unix时戳 shundown：将数据同步保存到磁盘，然后关闭服务 info：提供服务器的信息和统计 config resetstat：重置info命令中的某些统计数据 config get：获取配置文件信息 config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出 config rewrite：Redis 服务器时所指定的 redis.conf 文件进行改写 monitor：实时转储收到的请求 slaveof：改变复制策略设置 发布订阅相关命令 psubscribe：订阅一个或多个符合给定模式的频道 例如psubscribe news.* tweet.* publish：将信息 message 发送到指定的频道 channel 例如publish msg \"good morning\" pubsub channels：列出当前的活跃频道 例如PUBSUB CHANNELS news.i* pubsub numsub：返回给定频道的订阅者数量 例如PUBSUB NUMSUB news.it news.internet news.sport news.music pubsub numpat：返回客户端订阅的所有模式的数量总和 punsubscribe：指示客户端退订所有给定模式。 subscribe：订阅给定的一个或多个频道的信息。例如 subscribe msg chat_room unsubscribe：指示客户端退订给定的频道。 对KEY操作的命令 exists(key)：确认一个key是否存在 del(key)：删除一个key type(key)：返回值的类型 keys(pattern)：返回满足给定pattern的所有key randomkey：随机返回key空间的一个 keyrename(oldname, newname)：重命名key dbsize：返回当前数据库中key的数目 expire：设定一个key的活动时间（s） ttl：获得一个key的活动时间 move(key, dbindex)：移动当前数据库中的key到dbindex数据库 flushdb：删除当前选择数据库中的所有key flushall：删除所有数据库中的所有key 对String操作的命令 set(key, value)：给数据库中名称为key的string赋予值value get(key)：返回数据库中名称为key的string的value getset(key, value)：给名称为key的string赋予上一次的value mget(key1, key2,…, key N)：返回库中多个string的value setnx(key, value)：添加string，名称为key，值为value setex(key, time, value)：向库中添加string，设定过期时间time mset(key N, value N)：批量设置多个string的值 msetnx(key N, value N)：如果所有名称为key i的string都不存在 incr(key)：名称为key的string增1操作 incrby(key, integer)：名称为key的string增加integer decr(key)：名称为key的string减1操作 decrby(key, integer)：名称为key的string减少integer append(key, value)：名称为key的string的值附加value substr(key, start, end)：返回名称为key的string的value的子串 对List操作的命令 rpush(key, value)：在名称为key的list尾添加一个值为value的元素 lpush(key, value)：在名称为key的list头添加一个值为value的 元素 llen(key)：返回名称为key的list的长度 lrange(key, start, end)：返回名称为key的list中start至end之间的元素 ltrim(key, start, end)：截取名称为key的list lindex(key, index)：返回名称为key的list中index位置的元素 lset(key, index, value)：给名称为key的list中index位置的元素赋值 lrem(key, count, value)：删除count个key的list中值为value的元素 lpop(key)：返回并删除名称为key的list中的首元素 rpop(key)：返回并删除名称为key的list中的尾元素 blpop(key1, key2,… key N, timeout)：lpop命令的block版本。 brpop(key1, key2,… key N, timeout)：rpop的block版本。 rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 对Set操作的命令 sadd(key, member)：向名称为key的set中添加元素member srem(key, member) ：删除名称为key的set中的元素member spop(key) ：随机返回并删除名称为key的set中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为key的set的基数 sismember(key, member) ：member是否是名称为key的set的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合 sdiff(key1, (keys)) ：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合 smembers(key) ：返回名称为key的set的所有元素 srandmember(key) ：随机返回名称为key的set的一个元素 对Hash操作的命令 hset(key, field, value)：向名称为key的hash中添加元素field hget(key, field)：返回名称为key的hash中field对应的value hmget(key, (fields))：返回名称为key的hash中field i对应的value hmset(key, (fields))：向名称为key的hash中添加元素field hincrby(key, field, integer)：将名称为key的hash中field的value增加integer hexists(key, field)：名称为key的hash中是否存在键为field的域 hdel(key, field)：删除名称为key的hash中键为field的域 hlen(key)：返回名称为key的hash中元素个数 hkeys(key)：返回名称为key的hash中所有键 hvals(key)：返回名称为key的hash中所有键对应的value hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value 实例 query在线分析 redis-cli MONITOR | head -n 5000 | ./redis-faina.py 监控正在请求执行的命令 在cli下执行monitor，生产环境慎用。 模拟oom redis-cli debug oom 模拟宕机 redis-cli debug segfault 模拟hang redis-cli -p 6379 DEBUG sleep 30 获取慢查询 SLOWLOG GET 10 结果为查询ID、发生时间、运行时长和原命令 默认10毫秒，默认只保留最后的128条。单线程的模型下，一个请求占掉10毫秒是件大事情，注意设置和显示的单位为微秒，注意这个时间是不包含网络延迟的。 slowlog get 获取慢查询日志 slowlog len 获取慢查询日志条数 slowlog reset 清空慢查询 配置： config set slow-log-slower-than 20000 config set slow-max-len 1000 config rewrite","tags":[{"name":"redis","slug":"redis","permalink":"https://naliomg.github.io/tags/redis/"}]},{"title":"node将json转换为excel","date":"2018-03-22T13:10:22.000Z","path":"2018/03/22/node将json转换为excel/","text":"node将json转换为excel如题，需要的材料为：ejsExcel，此三方库功能比较强大，可以将json数据根据设定的模板输出为ejs; // 安装 npm install ejsExcel --save // 主程序 var fs = require(&apos;fs&apos;) var ejsExcel = require(&quot;ejsExcel&quot;); var data = require(&apos;./ban.js&apos;) // json数据 var results = data //获得Excel模板的buffer对象 var exlBuf = fs.readFileSync(&quot;./bannedWords.xlsx&quot;); //用数据源(对象)data渲染Excel模板 ejsExcel.renderExcel(exlBuf, results).then(function(exlBuf2) { fs.writeFileSync(&quot;./test2.xlsx&quot;, exlBuf2); console.log(&quot;生成test2.xlsx&quot;); }).catch(function(err) { console.error(err); }); git链接 THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"co模块异步书写","date":"2018-02-09T14:46:43.000Z","path":"2018/02/09/co模块异步书写/","text":"ES6 co模块的异步书写es6之前，异步的回调嵌套太多，书写与阅读都非常麻烦。若用promise写法，数据从头到尾必须包含在promise内，也不是很方便。 此处介绍基于generator和yeild的co模块，阅读与书写就比较方便了。使用方法如下： npm install co // 安装 const co = require(&apos;co&apos;) function step1() { return new Promise(function(resolve, reject) { setTimeout(function() { console.log(&apos;step1&apos;) resolve(&apos;step1&apos;) }, 1000) }) } function step2() { return new Promise(function(resolve, reject) { setTimeout(function() { console.log(&apos;step2&apos;) resolve(&apos;step2&apos;) }, 1000) }) } function step3() { return new Promise(function(resolve, reject) { setTimeout(function() { console.log(&apos;step3&apos;) resolve(&apos;step3&apos;) }, 1000) }) } co(function *() { // 这样顺序书写，会在step1执行完毕后再执行step2； // 且resolve传递的值脱离了promise，被传递给了a,b var a = yield step1() var b = yield step2() }).then(function(data) { // co方法返回的也是一个promise对象，当然可以用then和catch继续书写 console.log(data) }).catch(function(err) { console.log(err) }) co(function *() { // 这样用数组书写，step1和step2并行执行； // 等到step1和step2都执行完毕之后，此个yeild才算执行完毕，才会执行step3 var res = yeild [ step1(), step2() ] // res = [&apos;step1&apos;, &apos;step2&apos;] var c = yeild step3() }) // 以下代码也是并行处理的一种书写方式 co(function *() { var res = yeild { 1: step1(), 2: step2() } var c = yeild step3() }) THE END！","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"发布订阅模式的事件BUS","date":"2017-12-09T08:36:17.000Z","path":"2017/12/09/发布订阅模式的事件BUS/","text":"发布订阅模式下的事件BUS// 事件bus，不考虑事件延迟订阅的情况，后端可以用promise替代，此脚本在于简化前端异步的情况； // 此处没有创建事件的命名空间，请使用者自行管理自定义事件名作为命名空间； // 后绑定的先执行 var Event = (function() { var clientList = {}; var listen = null; var trigger = null; var remove = null; var one = null; // 事件绑定，可以重复绑定相同的事件，触发时会全部触发 // 注意绑定的事件最好不要用匿名函数，事件移除不会移除匿名函数 listen = function(key, fn) { if (!clientList[key]) { clientList[key] = []; } clientList[key].push(fn); } // 事件触发 trigger = function() { var key = Array.prototype.shift.call(arguments); var fns = clientList[key]; if (!fns || fns.length === 0) { return false; } for (var i = fns.length - 1, fn; i &gt;= 0; i--) { fn = fns[i]; fn.apply(this, arguments); } } // 移除绑定 remove = function(key, fn) { var fns = clientList[key]; if (!fns) { // 未绑定对应事件 return false } if (!fn) { // 清除key绑定的全部事件 fns &amp;&amp; (fns.length = 0) } else { for (var l = fns.length - 1; l &gt;= 0; l--) { var _fn = fns[l]; if (_fn == fn) { fns.splice(l, 1); } } } } // 绑定一次 one = function(key, fn) { var _self = this; var once = fn; var handler = function() { once.apply(this, arguments); _self.remove(key, handler) } _self.listen(key, handler) } return { listen: listen, one: one, trigger: trigger, remove: remove } })(); module.exports = Event; THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"策略模式文本校验","date":"2017-12-03T14:19:54.000Z","path":"2017/12/03/策略模式文本校验/","text":"策略模式的文本校验策略模式由两部分组成：一部分是由可以替换的算法对象集合组成的策略类，另一部分是接受外部请求并将请求委托给策略组中某个对象的环境类。 以下为策略模式下的文本校验，以后用时可以随意添加策略类： // 策略模式表单校验 var strategies = { isNoEmpty: function(value) { if (value === &apos;&apos;) { return false } return true }, minLength: function(value, exdata) { var length = exdata[0] if (value.length &lt; length) { return false } return true }, maxLength: function(value, exdata) { var length = exdata[0] if (value.length &gt; length) { return false } return true }, isMobile: function(value) { if (!(/^1[3|4|5|8][0-9]\\d{4,8}$/.test(value))) { return false } return true } } var validataTest = function(str, arr) { if (!(arr instanceof Array) || (typeof str !== &apos;string&apos;)) { return { state: false, errmsg: &apos;参数错误！&apos; } } if (arr.length == 0) { return { state: true, errmsg: &apos;无规则，直接通过校验&apos; } } var result = { state: true, errmsg: &apos;通过校验！&apos; } for (var i = 0; i &lt; arr.length; i++) { if (!strategies[arr[i].strategy](str, arr[i].exdata)) { result.state = false result.errmsg = arr[i].errmsg break } } return result } module.exports = validataTest THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"stylus语法简介","date":"2017-10-27T12:13:30.000Z","path":"2017/10/27/stylus语法简介/","text":"stylus的安装与使用stylus介绍就不需要了，直接进入主题吧。 stylus的安装此处只介绍sublime中使用stylus编译的安装方法，因个人比较喜欢使用sublime。 node肯定是要有的； 全局安装stylus: npm install stylus -g； sublime中搜索stylus插件，下载安装，设置stylus的个人配置； 重启sublime，创建 .styl 文件保存就会自动编译了。 以上的stylus插件只提供了编译与高亮，并不会有语法补与提示，所以还要安装一个stylus-clean-completions插件就ok了！ 如果需要自动前置添加的话，最好还是工程化后结合gulp对编译后的css进行处理，此点less也是如此。 基本配置如下： { &quot;envPATH&quot;: &quot;&quot;, //环境的路径 &quot;binDir&quot;: &quot;&quot;, //项目路径 &quot;compileOnSave&quot;: true, //是否编辑保存 &quot;compileDir&quot;: true, //编译到指定目录 &quot;compress&quot;: true, //是否压缩 &quot;compilePaths&quot;: {&quot;&quot;: &quot;&quot;} //输出路径，此项不要默认在styl相同路径生成css } stylus语法简介语法的话参考 张鑫旭翻译的stylus文档 就行了，本文只挑选一些常用的语法出来，便于及时查看。感谢张大大的无私奉献！ 选择器 stylus的冒号、花括号、分号均可以省略替代； stylus通过空格，缩排来代替花括号，故缩进很重要； body color #fff Stylus就跟CSS一样，允许你使用逗号为多个选择器同时定义属性，使用新行是一样的效果： textarea input border 1px solid #eee //等同于： textarea, input border 1px solid #eee 父级引用，同less一样，用 &amp; 代表； 消除歧义，类似padding - n的表达式可能既被解释成减法运算，也可能被释义成一元负号属性。为了避免这种歧义，用括号包裹表达式： pad(n) padding (- n) body pad(5px) 然而，只有在函数中才会这样（因为函数同时用返回值扮演混合或回调）。 变量 stylus以等式的方式定义变量，变量替换时，会将变量值全部替换到使用的变量名位置，变量值中还可以包含变量；标识符（变量名，函数等），也可能包括$字符。变量冒失只能在冒号右边有效，左边属性名内会被当成属性名而无效。 font-size = 14px font = font-size &quot;Lucida Grande&quot;, Arial body font font sans-serif //会被编译为： body { font: 14px &quot;Lucida Grande&quot;, Arial sans-serif; } 属性查找，Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下： #logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2) 我们不使用这里的变量w和h, 而是简单地前置 `@` 字符在属性名前来访问该属性名对应的值： #logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 若 `@` 的属性没有被定义，则属性会“向上冒泡”查找堆栈直到被发现，或者返回null（如果属性搞不定）。下面这个例子，@color被弄成了blue。 body color: red ul li color: blue a background-color: @color 变量赋值时，若后面的值内容有空格分隔，则变量可以当做数组来看待： size = 10px 15px body font-size size[0] padding size //编译为： body { font-size:10px; padding:10px 15px } 插值 Stylus支持通过使用{}字符包围 表达式 来插入值，其会变成标识符的一部分。例如，-webkit-{‘border’ + ‘-radius’}等同于-webkit-border-radius。感觉就是变量名的字符串链接，若用变量直接放在属性中的话，会被当成属性名处理的。 vendor(prop, args) -webkit-{prop} args -moz-{prop} args {prop} args border-radius() vendor(&apos;border-radius&apos;, arguments) button border-radius 1px 2px / 3px 4px // 编译为 button { -webkit-border-radius: 1px 2px / 3px 4px; -moz-border-radius: 1px 2px / 3px 4px; border-radius: 1px 2px / 3px 4px; } table for row in 1 2 tr:nth-child({row}) height: 10px * row // 编译为 table tr:nth-child(1) { height: 10px; } table tr:nth-child(2) { height: 20px; } 运算符 这一部分比较杂乱，复杂的运用一般不多，若遇到了可以参考 此文档。 混合书写 混入和函数定义方法一致，但是应用却大相径庭。mixins作为状态调用，而非表达式调用，仅仅是一些模块化的状态封装而已；minxins使用的时候，其内部属性会被复制到对应的选择器中。 border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius n form input[type=button] border-radius(5px) form input[type=button] border-radius 5px // 编译为如下，mix调用时，甚至不需要编写括号。 form input[type=button] { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; } 更进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式。 border-radius() -webkit-border-radius arguments -moz-border-radius arguments border-radius arguments border-radius 1px 2px / 3px 4px 另外一个很赞的应用是特定的私有前缀支持——例如IE浏览器的透明度： support-for-ie ?= true opacity(n) opacity n if support-for-ie filter unquote(&apos;progid:DXImageTransform.Microsoft.Alpha(Opacity=&apos; + round(n * 100) + &apos;)&apos;) #logo &amp;:hover opacity 0.5 // 编译为 #logo:hover { opacity: 0.5; filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50); } 混合书写可以利用父级引用字符 &amp;, 继承父业而不是自己筑巢，也就是mixins最外层的 &amp; 引用引的是mixins调用的环境父级。 自然，混合书写可以利用其它混合书写，建立在它们自己的属性和选择器上。 方法 语言函数定义，其定义与混入(mixins)一致，却可以返回值。 add(a, b) a + b body padding add(10px, 5) // 渲染为： body { padding: 15px; } 注意到方法和混入的区别了吗？简介片面的来说，方法可以看做一个定义的变量，而混入是一个相较独立的属性包。 默认参数：可选参数往往有个默认的给定表达。在Stylus中，我们甚至可以超越默认参数。 add(a, b = a) a + b add(10, 5) // =&gt; 15 add(10) // =&gt; 20 返回多值：Stylus的函数可以返回多个值，就像你给变量赋多个值一样。 sizes() 15px 10px sizes()[0] // =&gt; 15px 有个小小的例外就是返回值是标识符。例如，下面看上去像一个属性赋值给Stylus（因为没有操作符）。为避免歧义，我们可以使用括号，或是return关键字。 swap(a, b) b a swap(a, b) (b a) swap(a, b) return b a 条件：简单的 if…else… 应用。 stringish(val) if val is a &apos;string&apos; or val is a &apos;ident&apos; yes else no stringish(&apos;yay&apos;) == yes // =&gt; true stringish(yay) == yes // =&gt; true stringish(0) == no // =&gt; true 注意：yes和no并不是布尔值。本例中，它们只是简单的未定义标识符。 别名：给函数起别名类似于定义变量。 add(a, b) a + b plus = add plus(1, 2) // =&gt; 3 变量函数：把函数当作变量传递到新的函数中。 invoke(a, b, fn) fn(a, b) add(a, b) a + b body padding invoke(5, 10, add) padding invoke(5, 10, sub) body { padding: 15; padding: -5; } 参数：arguments是所有函数体都有的局部变量，包含传递的所有参数。mixins中也有arguments变量，同函数一致。 sum() n = 0 for num in arguments n = n + num sum(1,2,3,4,5) // =&gt; 15 关键字参数 Stylus支持关键字参数，或”kwargs”. 允许你根据相关参数名引用参数，参数的顺序可以打乱，因为有的关键字，但这种情况一般使用的很少，个人感觉其实是加大了开发的复杂度，故此处就不再讨论。 内置方法 red(color)：返回color中的红色比重。 green(color)：返回color中的绿色比重。 blue(color)：返回color中的蓝色比重。 alpha(color)：返回color中的透明度比重。 dark(color)：检查color是否是暗色。 light(color)：检查color是否是亮色。 hue(color)：返回给定color的色调。 push(expr, args…)：后面推送给定的args给expr，别名为append()。 nums = 1 2 push(nums, 3, 4, 5) nums // =&gt; 1 2 3 4 5 unshift(expr, args…)：起始位置插入给定的args给expr，别名为prepend()，单个单个数据的操作，不是一次将所有args按给定顺序插入。 nums = 4 5 unshift(nums, 3, 2, 1) nums // =&gt; 1 2 3 4 5 keys(pairs)：返回给定pairs中的键。 pairs = (one 1) (two 2) (three 3) keys(pairs) // =&gt; one two three values(pairs)：返回给定pairs中的值。 pairs = (one 1) (two 2) (three 3) values(pairs) // =&gt; 1 2 3 typeof(node)：字符串形式返回node类型，别名有type-of和type。 type(12) // =&gt; &apos;unit&apos; typeof(12) // =&gt; &apos;unit&apos; typeof(#fff) // =&gt; &apos;rgba&apos; type-of(#fff) // =&gt; &apos;rgba&apos; unit(unit[, type])：返回unit类型的字符串或空字符串，或者赋予type值而无需单位转换。 unit(10) // =&gt; &apos;&apos; unit(15in) // =&gt; &apos;in&apos; unit(15%, &apos;px&apos;) // =&gt; 15px unit(15%, px) // =&gt; 15px match(pattern, string):检测string是否匹配给定的pattern。 abs(unit)：绝对值。 abs(-5px) // =&gt; 5px ceil(unit)：向上取整。 floor(unit)：向下取整。 round(unit)：四舍五入取整。 min(a, b)：取较小值。 max(a, b)：取较大值。 even(unit)：是否为偶数。 even(6px) // =&gt; true odd(unit)：是否为奇数。 sum(nums)：求和。 avg(nums)：求平均数。 join(delim, vals…)：给定vals使用delim连接。 join(&apos; &apos;, 1 2 3) // =&gt; &quot;1 2 3&quot; join(&apos;,&apos;, 1 2 3) // =&gt; &quot;1,2,3&quot; join(&apos;, &apos;, foo bar baz) // =&gt; &quot;foo, bar, baz&quot; join(&apos;, &apos;, foo, bar, baz) // =&gt; &quot;foo, bar, baz&quot; join(&apos;, &apos;, 1 2, 3 4, 5 6) // =&gt; &quot;1 2, 3 4, 5 6&quot; s(fmt, …)：s()方法类似于unquote()，不过后者返回的是Literal节点，而这里起接受一个格式化的字符串，非常像C语言的sprintf(). 目前，唯一标识符是%s。 s(&apos;bar()&apos;); // =&gt; bar() s(&apos;bar(%s)&apos;, &apos;baz&apos;); // =&gt; bar(&quot;baz&quot;) s(&apos;bar(%s)&apos;, baz); // =&gt; bar(baz) s(&apos;bar(%s)&apos;, 15px); // =&gt; bar(15px) s(&apos;rgba(%s, %s, %s, 0.5)&apos;, 255, 100, 50); // =&gt; rgba(255, 100, 50, 0.5) s(&apos;bar(%Z)&apos;, 15px); // =&gt; bar(%Z) s(&apos;bar(%s, %s)&apos;, 15px); // =&gt; bar(15px, null) length([expr])：括号表达式扮演元组，length()方法返回该表达式的长度。 length((1 2 3 4)) // =&gt; 4 length((1 2)) // =&gt; 2 length((1)) // =&gt; 1 length(()) // =&gt; 0 length(1 2 3) // =&gt; 3 length(1) // =&gt; 1 length() // =&gt; 0 warn(msg)：使用给定的error警告，并不退出。 error(msg)：伴随着给定的错误msg退出。 last(expr)：返回给定expr的最后一个值。 opposite-position(positions)：返回给定positions相反内容。 opposite-position(right) // =&gt; left opposite-position(top left) // =&gt; bottom right 其余参数 Stylus支持 name... 形式的其余参数。这些参数可以消化传递给混写或函数的参数们。 box-shadow(offset-x, args...) got-offset-x offset-x -webkit-box-shadow offset-x args -moz-box-shadow offset-x args box-shadow offset-x args #login box-shadow 1px 2px 5px #eee // 编译为 #login { got-offset-x: 1px; -webkit-box-shadow: 1px 2px 5px #eee; -moz-box-shadow: 1px 2px 5px #eee; box-shadow: 1px 2px 5px #eee; } offset-x设定一个专门的变量接收第一个传入的参数，剩余的参数统统传到args类数组中，不过传入的数据好像不能实现表达式的精确传递，比如逗号就有问题，故推荐直接使用 arguments 参数处理。 注释 Stylus支持三种注释，单行注释，多行注释，以及多行缓冲注释。 // 我是注释! body padding 5px // 蛋疼的padding /* * 给定数值合体 */ add(a, b) a + b /*! * 给定数值合体 */ add(a, b) a + b 单行注释跟JavaScript一样，双斜杠，CSS中不输出；多行注释看起来有点像CSS的常规注释。然而，它们只有在compress选项未启用的时候才会被输出；多行缓冲注释跟多行注释类似，不同之处在于开始的时候，这里是/*!. 这个相当于告诉Stylus压缩的时候这段无视直接输出。 条件 if / else if / else：跟一般的语言一致，if表达式满足(true)的时候执行后面语句块，否则，继续后面的else if或else。 box(x, y, margin-only = false) if margin-only margin y x else padding y x unless：除非，基本上与if相反，本质上是(!(expr))。 后缀条件：Stylus支持后缀条件，这就意味着if和unless可以当作操作符；当右边表达式为真的时候执行左边的操作对象，有点类似于三目运算； negative(n) error(&apos;无效数值&apos;) unless n is a &apos;unit&apos; return yes if n &lt; 0 no 迭代 Stylus允许你通过for/in对表达式进行迭代形式如下： for &lt;val-name&gt; [, &lt;key-name&gt;] in &lt;expression&gt; 例如： body for num in 1 2 3 foo num // 编译为： body { foo: 1; foo: 2; foo: 3; } 加上key-name的情况： body fonts = Impact Arial sans-serif for font, i in fonts foo i font // 编译为 body { foo: 0 Impact; foo: 1 Arial; foo: 2 sans-serif; } 后缀：就跟if/unless可以利用后面语句一样，for也可以。如下后缀解析的例子： sum(nums) sum = 0 sum += n for n in nums 不过为了方便理解，个人不建议使用这种方式。 导入 Stylus支持字面@import CSS, 也支持其他Stylus样式的动态导入。 @import &quot;reset.css&quot; 当使用@import没有 .css 扩展，会被认为是Stylus片段（如：@import &quot;mixins/border-radius&quot;）。 媒体 @media 工作原理和在常规CSS中一样，但是，要使用Stylus的块状符号。 @media print #header #footer display none 自定义字体 @font-face 跟其在CSS中作用表现一样，在后面简单地添加个块状属性即可，类似下面： @font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf) .ingeo font-family Geo 动画定义 Stylus支持@keyframes规则，当编译的时候转换成@-webkit-keyframes，使用@keyframes，通过vendors变量，会自动添加私有前缀(webkit moz official)，official 为标准解析。 继承 Stylus的 @extend 指令受SASS实现的启发，基本一致，除了些轻微差异。此功能大大简化了继承其他语义规则集的语义规则集的维护；把对应的选择器传给 @extend 即可继承已存在的选择器规则；此方式用 mixins 也可以实现，两种方式均比较简便，对于已有的规则集，一般使用 extend，若公共的规则比较多，建议使用 mixins 。 .message { padding: 10px; border: 1px solid #eee; } .warning { @extend .message; color: #E2E21E; } 目前Stylus与SASS不同之处在于SASS不允许@extend嵌套选择器，Stylus中，只要选择器匹配，就可以生效。 CSS字面量 不管什么原因，如果遇到Stylus搞不定的特殊需求，你可以使用@css使其作为CSS字面量解决之。 @css { body { font: 14px; } } // 编译为 body { font: 14px; } 字符转码 Stylus可以字符转码。这可以让字符变成标识符，或是渲染成字面量。注意Stylus中 / 当作为属性使用的时候需要用括号括起来： body padding 1 \\+ 2 body font 14px/1.4 font (14px/1.4) // 编译为 body { padding: 1 + 2; } body { font: 14px/1.4; font: 10px; } 慢慢回味学习吧~","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"chrome中圆角遮盖不住transform动画导致子元素溢出","date":"2017-10-24T14:17:45.000Z","path":"2017/10/24/chrome中圆角遮盖不住transform动画导致子元素溢出/","text":"chrome中圆角遮盖不住transform动画导致子元素溢出在chrome浏览器下（webkit内核），overflow:hidden;border-radus:*px;在静态的情况可以遮盖住超出圆角的子元素，但一旦子元素有transform移动时，圆角就会变为直角（子元素在圆角的地方溢出了）而出现闪烁的情况，非常糟糕！ 究其原因，是因为transform会创建新的stacking context，会压住没有此层级的父元素而出现溢出的现象。 哪些情况下会创建新的stacking context呢？1.the root element (HTML)（html层级自带）,2.positioned (absolutely or relatively) with a z-index value other than “auto”（position:absolute/relative;z-index不是auto的）,3.a flex item with a z-index value other than “auto”,4.elements with an opacity value less than 1（小于1的opacity也有）,5.elements with a transform value other than “none”（transform属性）,6.elements with a mix-blend-mode value other than “normal”,7.elements with isolation set to “isolate”, on mobile WebKit and Chrome 22+, 8.position: fixed always creates a new stacking context, even when z-index is “auto”（position:fixed;自带）,9.specifing any attribute above in will-change even you don’t write themselves directly 故常用解决办法： 1.给border-radius的父元素设置z-index即可；2.给border-radius的父元素设置transform: rotate(0)也可以;","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"vuex使用小计","date":"2017-08-28T13:12:27.000Z","path":"2017/08/28/vuex使用小计/","text":"vuex使用小计1. 安装vuexnpm install vuex --save 2. 引入vueximport Vuex from &apos;vuex&apos; 3. 文件安装Vue.use(Vuex) 4. 实例化const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment: state =&gt; state.count++ } }) 5. 挂载注入(此处为全局注入)new Vue({ el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: { App } }) 6. 组件使用状态读取:store中的状态应该从组件的计算属性中去读取，因为状态存储是响应式的。对于一个组件需要获取较多的状态的时候，可以在计算属性中引入 mapState 辅助函数去计算，作用不大…也就少写几个字。 computed: { count () { return this.$store.state.count } } 7. getters使用getters相当于计算属性computed，当依赖发生改变时才会刷新对应的缓存值。Getters 接受 state 作为其第一个参数，另一个getter作为第二个参数。也有一个 mapGetters 函数可以简化书写。 const store = new Vuex.Store({ state: { arr: [{ value: &apos;first&apos;, state: true }, { value: &apos;second&apos;, state: false }, { value: &apos;third&apos;, state: true }] }, getters: { trueArr: state =&gt; { return state.arr.filter(item =&gt; item.state) } } }) // 组件中： computed: { arr() { // [{value: &apos;first&apos;, state: true}, {value: &apos;third&apos;, state: true}] return this.$store.getters.trueArr } } 8. Mutations状态改变更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型（事件名） (type) 和 一个 回调函数（处理函数） (handler)。当然，你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）,在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment(state, params) { state.count += params.n } } }) // 组件中触发事件： methods: { addCount() { this.$store.commit(&apos;increment&apos;, { n: 2 }) } } 提交 mutation 的另一种方式是直接使用包含 type 属性的对象,当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变: store.commit({ type: &apos;increment&apos;, n: 2 }) 注意事项 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：state.obj = { …state.obj, newProp: 123 }。 mutation 必须是同步函数。 9. Actions状态改变Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象: const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment: state =&gt; state.count++ }, actions: { increment(context, paramsObj) { setTimeout(function(){ context.commit(&apos;increment&apos;, paramsObj) }, 1000) } } }) // 分发, 载荷部分同mutations methods: { delayCount() { this.$store.dispatch(&apos;increment&apos;, 2) } } 10. ModulesVuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -&gt; moduleA 的状态 store.state.b // -&gt; moduleB 的状态 THE END!","tags":[{"name":"vue","slug":"vue","permalink":"https://naliomg.github.io/tags/vue/"}]},{"title":"soket.io使用","date":"2017-08-08T13:28:26.000Z","path":"2017/08/08/soket-io使用/","text":"soket-io的常用接口webdoket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。 此文介绍一些 soket.io 的基本使用。主页：https://socket.io/ 1. node + express + soket.io系统搭建服务器端：安装：npm install --save socket.io 将soket服务绑到 server 上； // www文件 var io = require(&apos;../routes/websoket.js&apos;); io.attach(server); //独立的websoket文件 var io = require(&apos;socket.io&apos;)(); var request = require(&apos;request&apos;); io.on(&apos;connection&apos;, function(socket) { console.log(&apos;a user connected&apos;); socket.emit(&apos;msg&apos;, { msg: &apos;我是智能闲聊高手，放马过来吧!&apos; }); socket.on(&apos;msg&apos;, function(obj) { // 接入图灵机器人,此处用图灵机器人实现了一个对话功能。 request({ url: &apos;http://www.tuling123.com/openapi/api&apos;, method: &quot;POST&quot;, json: true, form: { &apos;key&apos;: &apos;1a6e7a453c1645ee8739f592ef05465e&apos;, &apos;info&apos;: obj.msg, &apos;userid&apos;: &apos;naliomg&apos; } }, function(err, resp, body) { if (err) { console.log(err); return; } if (body.code == 100000) { socket.emit(&apos;msg&apos;, {msg: body.text}); }else if(body.code == 200000) { socket.emit(&apos;msg&apos;, {msg: body.text+&apos;，&lt;a href=&quot;&apos;+body.url+&apos;&quot;&gt;点这里&lt;/a&gt;&apos;}); } }); }); }); module.exports = io; 客户端：客户端需要引入soket.io的js文件，cdn: https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=1.0&quot; /&gt; &lt;title&gt;websoket&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ margin: 0; padding: 0; } .clearfix{ zoom: 1; } .clearfix:after{ content: &apos;&apos;; display:block; width: 0; height: 0; font-size: 0; visibility: hidden; clear: both; } .pull-l{ float: left; } .pull-r{ float: right; } .container{ padding: 10px; margin: 0 auto; box-sizing: border-box; } .msg-wrap{ width: 300px; height: 400px; margin: 10px auto; border: 3px solid #ddd; overflow: auto; } .controll-btn{ width: 300px } #sendMsg{ width: 220px; height: 40px; color: #aaa; box-sizing: border-box; } #send{ height: 40px; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/utils/jquery/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;msg-wrap container&quot; id=&quot;log&quot;&gt;&lt;/div&gt; &lt;div class=&quot;controll-btn container clearfix&quot;&gt; &lt;input id=&quot;sendMsg&quot; class=&quot;pull-l&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/input&gt; &lt;input id=&quot;send&quot; class=&quot;pull-r&quot; type=&quot;button&quot; value=&quot;发送&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;script&gt; $(function(){ var socket = io(&apos;http://naliomg.site&apos;); socket.on(&apos;msg&apos;, function(resp){ $(&apos;#log&apos;).append(&apos;&lt;p class=&quot;clearfix&quot;&gt;&lt;span class=&quot;pull-l&quot;&gt;&apos;+resp.msg+&apos;&lt;/span&gt;&lt;/p&gt;&apos;); $(&apos;#log&apos;).scrollTop( $(&apos;#log&apos;)[0].scrollHeight ); }); $(&apos;#send&apos;).on(&apos;click&apos;, function(){ var msg = $(&apos;#sendMsg&apos;).val(); if (msg.trim()==&apos;&apos;) { alert(&apos;消息不能为空~&apos;); return; } socket.emit(&apos;msg&apos;, {msg: msg}); $(&apos;#log&apos;).append(&apos;&lt;p class=&quot;clearfix&quot;&gt;&lt;span class=&quot;pull-r&quot;&gt;&apos;+msg+&apos;&lt;/span&gt;&lt;/p&gt;&apos;); $(&apos;#sendMsg&apos;).val(&apos;&apos;); $(&apos;#log&apos;).scrollTop( $(&apos;#log&apos;)[0].scrollHeight ); }); $(&apos;#otherConnect&apos;).on(&apos;click&apos;, function(){ var nameSoket = io(&apos;/test&apos;); }); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2. 服务器端常用API//监听客户端连接,回调函数会传递本次连接的socket io.on(&apos;connection&apos;,function(socket){ //监听客户端发送的信息 socket.on(&apos;event&apos;,function(data){}); //给该socket的客户端发送消息 socket.emit(&apos;event&apos;, data); //给除了自己以外的客户端广播消息 socket.broadcast.emit(&quot;msg&quot;,{data:&quot;hello,everyone&quot;}); //分组 socket.on(&apos;group1&apos;, function (data) { socket.join(&apos;group1&apos;); }); socket.on(&apos;group2&apos;,function(data){ socket.join(&apos;group2&apos;); }); //一个客户端可以存在多个分组（订阅模式） socket.emit(&apos;group1&apos;); //就可以加入group1分组； socket.emit(&apos;group2&apos;); //就可以加入group2分组； socket.leave(data.room); //退出分组 //对分组中的用户发送信息，不包括自己 socket.broadcast.to(&apos;group1&apos;).emit(&apos;event_name&apos;, data); }); //给所有客户端广播消息 io.sockets.emit(&apos;event&apos;,data); //给指定的客户端发送消息 io.sockets.socket(socketid).emit(&apos;event&apos;, data); //对分组中的用户发送信息，不包括自己 io.sockets.in(&apos;group1&apos;).emit(&apos;event_name&apos;, data); //获取连接的客户端socket io.sockets.clients().forEach(function (socket) { //..... }); //获取分组信息 //获取所有房间（分组）信息 io.sockets.manager.rooms; //来获取此socketid进入的房间信息 io.sockets.manager.roomClients[socket.id]; //获取particular room中的客户端，返回所有在此房间的socket实例 io.sockets.clients(&apos;particular room&apos;); //另一种分组方式 io.of(&apos;/some&apos;).on(&apos;connection&apos;, function (socket) { socket.on(&apos;test&apos;, function (data) { socket.broadcast.emit(&apos;event_name&apos;,{}); }); }); 3. 客户端常用API//建立一个socket连接 var socket = io(&quot;ws://103.31.201.154:5555&quot;); //监听服务消息 socket.on(&apos;msg&apos;,function(data){ socket.emit(&apos;msg&apos;, {rp:&quot;fine,thank you&quot;}); //向服务器发送消息 console.log(data); }); //监听socket断开与重连。 socket.on(&apos;disconnect&apos;, function() { console.log(&quot;与服务其断开&quot;); }); socket.on(&apos;reconnect&apos;, function() { console.log(&quot;重新连接到服务器&quot;); }); 客户端socket.on()监听的事件：connect：连接成功connecting：正在连接disconnect：断开连接connect_failed：连接失败error：错误发生，并且无法被其他事件类型所处理message：同服务器端message事件anything：同服务器端anything事件reconnect_failed：重连失败reconnect：成功重连reconnecting：正在重连 当第一次连接时，事件触发顺序为：connecting-&gt;connect；当失去连接时，事件触发顺序 为：disconnect-&gt;reconnecting（可能进行多 次）-&gt;connecting-&gt;reconnect-&gt;connect。 THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"ngrok搭建外网可以访问的本地服务器","date":"2017-08-01T12:18:15.000Z","path":"2017/08/01/ngrok搭建外网可以访问的本地服务器/","text":"利用ngrok搭建外网可以访问的本地服务器微信公众号开发的时候，由于在自己电脑上开发，而微信接入需要一个外网的域名地址，用ngrok搭建一个反向代理就非常方便了。 使用方法： 注册 -&gt; 开通一个隧道 -&gt; 利用隧道的id -&gt; 启动‘Sunny-Ngrok启动工具.bat’ -&gt; 输入隧道id -&gt; ok; 前提要打开本地服务器； 免费的隧道有时候慢得很…","tags":[{"name":"工具","slug":"工具","permalink":"https://naliomg.github.io/tags/工具/"}]},{"title":"node+ueditor+qn+atjs编辑器搭建","date":"2017-08-01T12:17:53.000Z","path":"2017/08/01/node-ueditor-qn-atjs编辑器搭建/","text":"nodejs + ueditor + qn + at.js 构建富文本编辑器图片文件上传及@功能1. ueditorueditor为百度前端团队开发的一款功能强大的富文本编辑器，使用也比较方便。 其主页为：http://ueditor.baidu.com/website/ 使用时必须引入的文件有：ueditor.cssueditor.config.jsueditor.all.js后端需要使用ueditor.config.json;ueditor.config.js的具体配置请查看官网api；后台为node或者php的话，下载php版本即可 基本使用： // html，可以为script标签，也可以为textarea标签 &lt;script id=&quot;container&quot; name=&quot;content&quot; type=&quot;text/plain&quot;&gt;需要初始化的数据&lt;/script&gt; &lt;!-- &lt;textarea id=&quot;container&quot;&gt;需要初始化的数据&lt;/textarea&gt; --&gt; // js实例化即可，可以传一个json参数作为初始化的使用定制 var ue = UE.getEditor(&apos;container&apos;); 2. 七牛文件上传搭配nodejs使用七牛，此处并没有使用七牛官方提供 js sdk ，而是使用的 node-ueditor 的一款针对ueditor的插件。实现图片文件的上传与管理。 安装: npm install ueditor --save 使用: // 此为没有使用7牛存储，将上传的图片存储到自己服务器的情况 var bodyParser = require(&apos;body-parser&apos;) var ueditor = require(&quot;ueditor&quot;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), function(req, res, next) { // ueditor 客户发起上传图片请求 if(req.query.action === &apos;uploadimage&apos;){ var foo = req.ueditor; var date = new Date(); var imgname = req.ueditor.filename; var img_url = &apos;/images/ueditor/&apos;; res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 } // 客户端发起图片列表请求 else if (req.query.action === &apos;listimage&apos;){ var dir_url = &apos;/images/ueditor/&apos;; res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/ueditor/ueditor.config.json&apos;) // ueditor初始化时会向设置的/ueditor/ue路由发起请求，需要返回ueditor.config.json }})); // qn存储 var bodyParser = require(&apos;body-parser&apos;) var ueditor = require(&quot;ueditor&quot;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); // 支持七牛上传，如有需要请配置好qn参数，如果没有qn参数则存储在本地 app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), { qn: { accessKey: &apos;your access key&apos;, // qn accessKey secretKey: &apos;your secret key&apos;, // qn secretKey bucket: &apos;your bucket name&apos;, // qn bucket origin: &apos;http://{bucket}.u.qiniudn.com&apos;, // 这个地址是qn返回的图片地址域，使用融合cdn或者qn提供的测试域 uploadURL: &apos;http://up-z2.qiniu.com&apos; // qn上传接口地址，这个为华南 } }, function(req, res, next) { // ueditor 客户发起上传图片请求，如果没有配置qn参数，则会上传到本地服务器；就会走下面的存储。 var imgDir = &apos;/img/ueditor/&apos; if(req.query.action === &apos;uploadimage&apos;){ var foo = req.ueditor; var imgname = req.ueditor.filename; res.ue_up(imgDir); //你只要输入要保存的地址 。保存操作交给ueditor来做 } // 客户端发起图片列表请求 else if (req.query.action === &apos;listimage&apos;){ res.ue_list(imgDir); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/ueditor/ueditor.config.json&apos;) }})); // 多文件类型存储 var bodyParser = require(&apos;body-parser&apos;) var ueditor = require(&quot;ueditor&quot;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), function(req, res, next) { var imgDir = &apos;/img/ueditor/&apos; //默认上传地址为图片 var ActionType = req.query.action; if (ActionType === &apos;uploadimage&apos; || ActionType === &apos;uploadfile&apos; || ActionType === &apos;uploadvideo&apos;) { var file_url = imgDir;//默认上传地址为图片 /*其他上传格式的地址*/ if (ActionType === &apos;uploadfile&apos;) { file_url = &apos;/file/ueditor/&apos;; //附件保存地址 } if (ActionType === &apos;uploadvideo&apos;) { file_url = &apos;/video/ueditor/&apos;; //视频保存地址 } res.ue_up(file_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;); } //客户端发起图片列表请求 else if (ActionType === &apos;listimage&apos;){ res.ue_list(imgDir); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/ueditor/ueditor.config.json&apos;) }})); 其实这个插件已经不止用于搭配ueditor了，所有图片及文件的上传基本都可以使用了，不过对数据的处理比较死，没有更多的对上传文件进行加工。 3. at.js用at.js实现 ‘@’ 书写功能。 github地址：https://github.com/ichord/At.js 必须要引入的文件：jquery.atwho.cssjquery.min.jsjquery.caret.jsjquery.atwho-2.js 一定要注意at的版本，1.0以下好像与ueditor不兼容，@功能会有问题。 使用： &lt;script type=&quot;text/javascript&quot;&gt; var ue = UE.getEditor(&apos;container&apos;); $(function(){ var at_config = { at: &quot;@&quot;, data:[&apos;Peter&apos;, &apos;Tom&apos;, &apos;Anne&apos;, &apos;zhangsan&apos;, &apos;lisi&apos;], limit: 20 } var ue = UE.getEditor(&apos;container&apos;,{ autoClearinitialContent:true, //关闭字数统计 wordCount:false, //关闭elementPath elementPathEnabled:false, }); ue.addListener(&apos;ready&apos;, function(editor){ $(this.document.body).atwho(at_config); }); }); &lt;/script&gt; 以上3个插件就实现了富文本编辑器的常见使用功能，是不是比自己写方便多了呢~ THE END！","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"判断浏览器是否是移动设备","date":"2017-07-14T14:34:53.000Z","path":"2017/07/14/判断浏览器是否是移动设备/","text":"判断浏览器是否是移动设备function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { return false; //是移动设备 } else { return true; //是pc } } THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"CSS实现侧边栏等高布局","date":"2017-07-04T13:20:59.000Z","path":"2017/07/04/CSS实现侧边栏等高布局/","text":"CSS实现侧边栏等高布局用纯CSS来实现侧边栏等高布局： html: &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边，无高度属性，自适应于最高一栏的高度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边，无高度属性，自适应于最高一栏的高度&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;中间，高度600像素，左右两栏的高度与之自适应&lt;/div&gt; &lt;/div&gt; css: #content{ overflow:hidden; } .left{ width:200px; margin-bottom:-3000px; padding-bottom:3000px; background:#cad5eb; float:left; } .right{ width:400px; margin-bottom:-3000px; padding-bottom:3000px; background:#f0f3f9; float:right; } .center{ margin:0 410px 0 210px; background:#ffe6b8; height:600px; } 最终起作用的就是父元素的 overflow:hidden，子元素的 margin-bottom:-3000px;padding-bottom:3000px ；3000这个数值是根据可能存在的最大高度来算的。 THE END！","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"node将excel转换为json","date":"2017-07-03T13:19:20.000Z","path":"2017/07/03/node将excel转换为json/","text":"nodeJs将excel转化为json1.直接转换var xlsx = require(&quot;node-xlsx&quot;); var fs = require(&apos;fs&apos;); var list = xlsx.parse(&quot;myexcel.xlsx&quot;); //console.log(JSON.stringify(list)); console.log(list); writeFile(&quot;myexcel.json&quot;, JSON.stringify(list)); function writeFile(fileName, data) { fs.writeFile(fileName, data, &apos;utf-8&apos;, complete); function complete(err) { if (!err) { console.log(&quot;文件生成成功&quot;); } } } 这种基础的转换会生成这样一个数组： [ { &quot;name&quot;: &quot;Sheet1&quot;, &quot;data&quot;: [ [&quot;id&quot;, &quot;name&quot;, &quot;sex&quot;, &quot;age&quot;], [1, &quot;nali&quot;, &quot;male&quot;, 25], [2, &quot;naliomg&quot;, &quot;female&quot;, 22] ] }, { &quot;name&quot;: &quot;Sheet2&quot;, &quot;data&quot;: [] }, { &quot;name&quot;: &quot;Sheet3&quot;, &quot;data&quot;: [] } ] 其中，每一个大对象为一个sheet中的内容，name为sheet命名，data为表格里每一行的数据。 2.对数据进行一些对象化处理以上直接转换的方式主要转换成了数组内容，不太方便读取与使用，将excel定义好后做一些基本处理就好用得多。 excel数据为如下： var xlsx = require(&quot;node-xlsx&quot;); var fs = require(&apos;fs&apos;); var list = xlsx.parse(&quot;Camp.xlsx&quot;); praseExcel(list); //解析Excel function praseExcel(list) { // sheet循环 for (var i = 0; i &lt; list.length; i++) { var excleData = list[i].data; // body数据 var sheetArray = []; // sheet存储 var typeArray = excleData[1]; // 数据类型 var keyArray = excleData[2]; // 关键字或者属性名 // 开始循环数据内容 for (var j = 3; j &lt; excleData.length ; j++) { var curData = excleData[j]; if(curData.length == 0) continue; var item = changeObj(curData,typeArray,keyArray); sheetArray.push(item); } if(sheetArray.length &gt;0) writeFile(list[i].name+&quot;.json&quot;,JSON.stringify(sheetArray)); } console.log(&quot;qqq&quot;); } //转换数据类型，用对象保存起来 function changeObj(curData,typeArray,keyArray) { var obj = {}; for (var i = 0; i &lt; curData.length; i++) { //字母 obj[keyArray[i]] = changeValue(curData[i],typeArray[i]); } return obj; } function changeValue(value,type) { if(value == null || value ==&quot;null&quot;) return &quot;&quot;; if(type ==&quot;int&quot;) return Math.floor(value); if(type ==&quot;Number&quot;) return value; if(type ==&quot;String&quot;) return value; } //写文件 function writeFile(fileName,data) { fs.writeFile(fileName,data,&apos;utf-8&apos;,complete); function complete(err) { if(!err) { console.log(&quot;文件生成成功&quot;); } } } 这样就将excel转换为有属性的对象了。 THE END！","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"js获取url地址中参数","date":"2017-07-02T10:09:39.000Z","path":"2017/07/02/js获取url地址中参数/","text":"js获取url中地址参数写页面时，常会有需要获取url中参数的需求，以下为常用的一些方法： 1.正则法function getQueryString(name) { var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;); var r = window.location.search.substr(1).match(reg); if (r != null) { return unescape(r[2]); } return null; } console.log(getQueryString(&apos;paramName&apos;)); // 及时查询 2.split拆分法function GetRequest() { var url = location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) { var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) { theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]); } } return theRequest; } // 返回一个参数对象，包含当前url中所有参数 THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"nodejs文件压缩与解压","date":"2017-07-02T09:48:52.000Z","path":"2017/07/02/nodejs文件压缩与解压/","text":"nodejs文件压缩与解压nodejs现在常用比较靠谱的压缩与解压方式，archiver 与 unzip 结合。archiver：https://github.com/ctalkington/node-archiverunzip：https://github.com/EvanOxfeld/node-unzip 以下为基本使用： 文件压缩：npm install archiver --save var fs = require(&apos;fs&apos;) var archiver = require(&apos;archiver&apos;) // 压缩工具 // 注意fs.createWriteStream()会重写整个文件 // 压缩 // 定义输出文件路径及文件名 var output = fs.createWriteStream(&apos;./example.zip&apos;); var archive = archiver(&apos;zip&apos;, { zlib: { level: 9 } // 设置压缩等级 }); // 压缩完毕的回调 output.on(&apos;close&apos;, function() { console.log(archive.pointer() + &apos; total bytes&apos;); console.log(&apos;压缩完毕&apos;); }); // 监听警告 archive.on(&apos;warning&apos;, function(err) { if (err.code === &apos;ENOENT&apos;) { console.log(&apos;warning&apos;) } else { throw err; } }); // 监听错误 archive.on(&apos;error&apos;, function(err) { throw err; }); // 将解压数据添加到写入的文件 archive.pipe(output); // 向archive添加需要压缩的文件 // 打开一个已有文件，并以特定文件名将打开内容保存到压缩文件 // var file1 = &apos;./zip/test1.txt&apos;; // archive.append(fs.createReadStream(file1), { name: &apos;file1.txt&apos; }); // 将字符串添加到压缩文件 // archive.append(&apos;这是字符串内容&apos;, { name: &apos;file2.txt&apos; }); // 将缓冲区内容添加到压缩文件 // var buffer3 = Buffer.from(&apos;buff it!&apos;); // archive.append(buffer3, { name: &apos;file3.txt&apos; }); // 直接添加一个文件 // archive.file(&apos;./zip/test1.txt&apos;, { name: &apos;file4.txt&apos; }); // 添加一个文件夹下所有内容到新命名的文件夹中压缩,注意不要添加输出文件夹，会有小问题 // archive.directory(&apos;./zip/&apos;, &apos;newdirc&apos;); // 添加一个文件夹下所有内容到压缩文件的根目录 archive.directory(&apos;./zip/&apos;, false); // 添加特定匹配模式的文件 // archive.glob(&apos;./zip/*.txt&apos;); // 压缩完成 archive.finalize(); 文件解压：npm install unzip --save var fs = require(&apos;fs&apos;) var unzip = require(&apos;unzip&apos;) // 解压工具 // 直接解压 fs.createReadStream(&apos;./example.zip&apos;).pipe(unzip.Extract({ path: &apos;./unzip/&apos; })); // 可以自定义提取中的事件处理 // var extract = unzip.Extract({ path: &apos;./unzip/&apos; }); // extract.on(&apos;error&apos;, function(err) { // console.log(&quot;error++++++++++++++++++++++&quot;); // console.log(err); // //解压异常处理 // }); // extract.on(&apos;finish&apos;, function() { // console.log(&quot;解压完成!!&quot;); // //解压完成处理 // }); // fs.createReadStream(&apos;./zip/test.zip&apos;).pipe(extract); // // 对每一个解压文件做处理 // fs.createReadStream(&apos;./zip/test.zip&apos;) // .pipe(unzip.Parse()) // .on(&apos;entry&apos;, function(entry) { // 遍历每一个文件 // var fileName = entry.path // 文件名 // var type = entry.type // &apos;Directory&apos; or &apos;File&apos;，表明解压的项是文件夹还是文件 // var size = entry.size // 文件大小 // if (fileName === &quot;test1.txt&quot;) { // entry.pipe(fs.createWriteStream(&apos;./unzip/dest.txt&apos;)); // 读取test.txt中文件内容并copy到目标文件中 // } else { // entry.autodrain(); // 关闭文件读取缓冲，释放内存。 // } // }); 以上两者可以结合起来用，比较靠谱。美中不足的是unzip解压不能解压压缩文件中某个特定的文件，并且在linux环境下unzip去解压windows环境下的压缩包，会出现中文文件名乱码的情况。解决办法为将unzip的parse.js源码中用utf8对文件名解码转换为gbk文件名解码。 THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"随笔笔记01","date":"2017-06-08T00:55:55.000Z","path":"2017/06/08/随笔笔记01/","text":"随笔笔记011. npm与bower的区别npm 和bower 的最大区别，就是 npm 支持嵌套的依赖管理，而 bower只能支持扁平的依赖（嵌套的依赖，由程序员自己解决）。现在不建议使用bower了。官方已经停止维护，建议直接使用npm就可以了。 2. gulp有无return的区别依据gulp官方文档，gulp的task方法是按最大并发执行的，也就是说所有的task都会同时执行，而对于依赖于其他任务的异步task来说，就需要一个通知来告知该什么时候执行。故需要一个return。 gulp.task(&apos;js&apos;, [&apos;css&apos;], function() { // 做一些事 }); // js这个异步任务就需要css任务执行完毕后给一个提示，可以为如下3种方式 // 1.返回一个stream，就是直接return的方式 gulp.task(&apos;css&apos;, function() { var stream = gulp.src(&apos;client/**/*.css&apos;) .pipe(gulp.dest(&apos;build&apos;)); return stream; }); // 2. 返回一个promise gulp.task(&apos;css&apos;, function() { var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() { deferred.resolve(); }, 1); return deferred.promise; }); // 3. 执行一个回调 gulp.task(&apos;css&apos;, function(cb) { exec(&apos;jekyll build&apos;, function(err) { if (err) return cb(err); // 返回 error cb(); // 完成 task }); });","tags":[{"name":"笔记","slug":"笔记","permalink":"https://naliomg.github.io/tags/笔记/"}]},{"title":"stiky-footer","date":"2017-06-04T02:27:13.000Z","path":"2017/06/04/stiky-footer/","text":"stiky-footer 的实现方式html: &lt;div class=&quot;detail&quot;&gt; &lt;div class=&quot;detail-wrap&quot;&gt; &lt;div class=&quot;detail-main&quot;&gt; &lt;p&gt;123&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;X&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; less: .detail { position: fixed; top: 0; left: 0; z-index: 2; width: 100%; height: 100%; overflow: auto; .detail-wrap{ box-sizing: border-box; min-height: 100%; padding-top: 64px; padding-bottom: 64px; } .detail-close{ position: relative; width: 32px; height: 32px; margin: -64px auto 0; font-size: 32px; } } DONE!","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"less基本语法","date":"2017-06-02T01:45:12.000Z","path":"2017/06/02/less/","text":"less基本语法编译自动编译软件有很多，sublime、koala都可以，自选。 定义变量变量使用 @test_num: 30px; .test{ width: @test_num; } // 会被编译为： .test{ width: 30px; } 混合样式中嵌套别的样式名，类似class控制 ul{ height: 30px; .mix; } .mix{ border: 1px solid #ddd; } //会被编译为： ul{ height: 30px; border: 1px solid #ddd; } .mix{ border: 1px solid #ddd; } 带参数的混合混合的参数名是只属于当前的混合函数的，可以设置默认值；没有设置默认值的变量不可以缺省，不然会报错。 ul{ height: 30px; .mix(15px); } .mix(@width: 15px){ border: @width solid #ddd; } //会被编译为： ul{ height: 30px; border: 15px solid #ddd; } 匹配模式类似于switch函数，可以加载传入的参数的某类css样式。若没有匹配到值，则对应语句解析为空,sublime插件会报错。 .test_pipei(red){ color: red; } .test_pipei(green){ color: green; } .test{ .test_pipei(red); } // 以上代码会解析为： .test{ color: red; } // 若 .test{.test_pipei(green)} 则会解析为 .test{color:green} 运算可以对数值及变量进行基础运算，颜色也可以计算不过不常用。 @num: 300px; .test{ width: @num + 20; } // 以上代码会解析为： .test{ width: 320px; } 嵌套规则对相应的html结构进行嵌套的css书写。“&amp;”代表上一层选择器。 // html结构 &lt;ul class=&quot;test&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; // less嵌套语法 .test{ background-color: #eee; li{ background-color: #ddd; a{ display: inline-block; background-color: #ccc; &amp;:hover{ color: red; } } } &amp;nali:{ margin-top: 10px; } } // 以上代码解析为: .test { background-color: #eee } .test li { list-style: none; background-color: #ddd } .test li a { display: inline-block; background-color: #ccc } .test li a:hover { color: red } .testnali { margin-top: 10px } @arguments变量用于全部的参数的直接使用。使用比较少。 .border_arg(@w: 30px, @c: red, @xx: solid){ border: @arguments; } 避免编译有时需要输出不用less编译或者less不认识的语句，就需要less对这些语句不做处理。 // ~&quot;words&quot; 引号内的语句将不会被less解析 .test{ width: ~&quot;calc(30px + 20px)&quot;; } 变量与字符串拼接在less中定义好路径变量对路径迁移是一件非常重要的事情，所以定义路径变量非常有必要，此处就会用到路径变量与字符串之间的拼接问题。 @iconUrl: &quot;/img&quot;; // mixin .c-icon(@bgImg) { background-image: url(@bgImg); } .bg { @someImgUrl: &quot;/icon.png&quot;; // call mixin .c-icon(); .c-icon(&quot;@{iconUrl}@{someImgUrl}&quot;); // or below // .c-icon(&quot;@{iconUrl}/icon.png&quot;); } important在混合的样式后面加入 !important 后，该样式下的全部样式都不被添加上 !important ，用处不大，一般用于调试。 .test{ .test_detail !important; } .test_detail{ width: 120px; height: 50px; } // 以上代码会被编译为 .test { width: 120px!important; height: 50px!important } .test_detail { width: 120px; height: 50px } vue组件中使用less语法，需要安装less依赖以及将 &lt; &lt;style lang=&quot;less&quot;&gt;&lt;/style&gt; 的语言指定为less。THE END!","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"ios下js中newDate的坑","date":"2017-03-06T05:24:11.000Z","path":"2017/03/06/ios下js中newDate的坑/","text":"ios下js中 new Date() 的坑ios中safari竟然不支持yyyy-mm-dd的日期格式，所以当你输入如下语句时，会返回空的时间。 new Date(&apos;2016-05-17&apos;); // Invalid Time Safari支持的格式是yyyy/mm/dd这样的，差别主要在于短横”-“与斜杠”/“，而斜杠这样的格式在其他常见的浏览器中也都是可以正常运行的，所以只需要都换成斜杠就可以了，转换函数如下所示： new Date(&apos;2016-05-17&apos;.replace(/-/g, &quot;/&quot;)); // 坑的ios总算认识了 THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"浏览器sessionid变化情况","date":"2017-02-27T08:39:55.000Z","path":"2017/02/27/浏览器sessionid变化/","text":"浏览器sessionid变化情况浏览器中sessionid一般不会因为浏览器标签页的开关而变化，是存储于浏览器内存中的。不同的域名，浏览器会存储不同的sessionid；但相同的域名不同的端口，浏览器会认为是同一地址，更新sessionid！！！ THE END!","tags":[{"name":"其他","slug":"其他","permalink":"https://naliomg.github.io/tags/其他/"}]},{"title":"网站从输入地址到展示基本简单过程","date":"2017-02-17T09:22:13.000Z","path":"2017/02/17/网站从输入地址到展示基本简单过程/","text":"网站从输入地址到展示基本简单过程 用户操作浏览器访问，浏览器向服务器发出一个 HTTP 请求； 服务器接收到 HTTP 请求，Web Server 进行相应的初步处理，使用服务器脚本生成页面； 服务器脚本（利用Web Framework）调用本地和客户端传来的数据，生成页面； Web Server 将生成的页面作为 HTTP 响应的 body，根据不同的处理结果生成 HTTP header，发回给客户端； 客户端（浏览器）接收到 HTTP 响应，通常第一个请求得到的 HTTP 响应的 body 里是 HTML 代码，于是对 HTML 代码开始解析；解析过程中遇到引用的服务器上的资源（额外的 CSS、JS代码，图片、音视频，附件等），再向 Web Server 发送请求，Web Server 找到对应的文件，发送回来； 浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步渲染，JS 代码也可能会对外观进行一定的处理； 用户与页面交互（点击，悬停等等）时，JS 代码对此作出一定的反应，添加特效与动画； 交互的过程中可能需要向服务器索取或提交额外的数据（局部的刷新，类似微博的新消息通知），一般不是跳转就是通过 JS 代码（响应某个动作或者定时）向 Web Server 发送请求，Web Server 再用服务器脚本进行处理（生成资源or写入数据之类的），把资源返回给客户端，客户端用得到的资源来实现动态效果或其他改变。","tags":[{"name":"网络","slug":"网络","permalink":"https://naliomg.github.io/tags/网络/"}]},{"title":"cache存储常用方法","date":"2017-01-14T13:40:52.000Z","path":"2017/01/14/cache存储常用方法/","text":"cache 存储常用方法/** * [设置cookie] * @param {[string]} key [键] * @param {[string]} value [值] * @param {[number]} t [过期时间(天)] */ function setCookie(key, value, t) { var oDate = new Date(); oDate.setDate(oDate.getDate() + t); document.cookie = key + &quot;=&quot; + value + &quot;;expires=&quot; + oDate.toGMTString(); } /** * [读取cookie] * @param {[string]} key [键] * @return {[type]} [description] */ function getCookie(key) { var arr1 = document.cookie.split(&quot;; &quot;); for (var i = 0; i &lt; arr1.length; i++) { var arr2 = arr1[i].split(&quot;=&quot;); if (arr2[0] == key) { return decodeURI(arr2[1]); } } } /** * [删除cookie] * @param {[string]} key [键] * @return {[type]} [description] */ function removeCookie(key) { myJsPag.setCookie(key, &quot;&quot;, -1); }","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"原生JS封装Ajax方法","date":"2017-01-14T13:27:11.000Z","path":"2017/01/14/原生JS封装Ajax方法/","text":"原生JS封装Ajax方法/** * [ajax description] * @param {[json]} opt [参数设置] * @return {[type]} [description] option设置： { method: &apos;GET&apos;, url: &apos;1.txt&apos;, responseType:&apos;xml/json&apos;, data: { name1:&apos;value1&apos;, name2:&apos;value2&apos; }, success: function (response) { alert(response); } } */ function ajax(opt) { // 参数初始化 opt = opt || {}; opt.method = opt.method.toUpperCase() || &apos;POST&apos;; opt.url = opt.url || &apos;&apos;; opt.async = opt.async || true; opt.responseType = opt.responseType || &apos;&apos;; opt.data = opt.data || null; opt.success = opt.success || function() {}; // 创建httpRequest var xmlHttp = createXHR(); // 向服务器传递的参数存放在params var params = []; for (var key in opt.data) { params.push(key + &apos;=&apos; + opt.data[key]); } var postData = params.join(&apos;&amp;&apos;); // 对请求做相应处理并发送 if (opt.method.toUpperCase() === &apos;POST&apos;) { xmlHttp.open(opt.method, opt.url, opt.async); xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;); xmlHttp.send(postData); } else if (opt.method.toUpperCase() === &apos;GET&apos;) { xmlHttp.open(opt.method, opt.url + &apos;?&apos; + postData + &apos;&amp;&apos; + Math.random(), opt.async); xmlHttp.send(null); } // 监听请求状态 xmlHttp.onreadystatechange = function() { if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) { if (opt.responseType == &apos;json&apos;) { var responseData = JSON.parse(xmlHttp.responseText); } else if (opt.responseType == &apos;xml&apos;) { var responseData = xmlHttp.responseXML; } else { var responseData = xmlHttp.responseText; } opt.success(responseData); } }; // 创建request请求方法 function createXHR() { var xmlHttp; try { xmlHttp = new XMLHttpRequest(); } catch (e) { try { xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e) { try { xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e) { alert(&quot;您的浏览器不支持AJAX！&quot;); return false; } } } return xmlHttp; } }","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"localStorage","date":"2017-01-14T09:57:54.000Z","path":"2017/01/14/localStorage/","text":"localStorage 的使用与说明HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 localStorage和sessionStorage均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 localStorage 和 sessionStorage 使用时使用相同的API： localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value” localStorage[&quot;key&quot;] = &quot;value&quot;;//以“key”为名称存储一个值“value” localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值 var item = localStorage[&quot;key&quot;];//获取名称为“key”的值 localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。 localStorage.clear();​//清空localStorage中所有信息 将上述的 localStorage 换成 sessionStorage 即为 sessionStorage 的用法。 THE END！","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"国内公共cdn资源库","date":"2017-01-06T04:34:44.000Z","path":"2017/01/06/国内公共资源库/","text":"国内公共cdn资源库 新浪 http://lib.sinaapp.com/ 微软 http://ajax.aspnetcdn.com/ jQuery http://code.jquery.com/ Staticfile https://www.staticfile.org/ (推荐) 百度 http://cdn.code.baidu.com/ 当然，用别人的 CDN 都是不保险的，所以建议在 CDN 读取失败的时候从自己服务器提供： &lt;script src=&quot;//http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; if (!window.jQuery) { var script = document.createElement(&apos;script&apos;); script.src = &quot;/js/jquery.min.js&quot;; document.body.appendChild(script); } &lt;/script&gt;","tags":[{"name":"cdn","slug":"cdn","permalink":"https://naliomg.github.io/tags/cdn/"}]},{"title":"常用正则验证表达式","date":"2017-01-03T15:16:25.000Z","path":"2017/01/03/window.location属性/","text":"window.location属性url: https://www.baidu.com:8080/nali#test?k=123 hash 设置或返回从井号 (#) 开始的 URL（锚）。host 设置或返回主机名和当前 URL 的端口号。hostname 设置或返回当前 URL 的主机名。href 设置或返回完整的 URL。pathname 设置或返回当前 URL 的路径部分。port 设置或返回当前 URL 的端口号。protocol 设置或返回当前 URL 的协议。search 设置或返回从问号 (?) 开始的 URL（查询部分）。 assign() 加载新的文档。reload() 重新加载当前文档。replace() 用新的文档替换当前文档。 Location 对象描述Location 对象存储在 Window 对象的 Location 属性中，表示那个窗口中当前显示的文档的 Web 地址。它的 href 属性存放的是文档的完整 URL，其他属性则分别描述了 URL 的各个部分。这些属性与 Anchor 对象（或 Area 对象）的 URL 属性非常相似。当一个 Location 对象被转换成字符串，href 属性的值被返回。这意味着你可以使用表达式 location 来替代 location.href。不过 Anchor 对象表示的是文档中的超链接，Location 对象表示的却是浏览器当前显示的文档的 URL（或位置）。但是 Location 对象所能做的远远不止这些，它还能控制浏览器显示的文档的位置。如果把一个含有 URL 的字符串赋予 Location 对象或它的 href 属性，浏览器就会把新的 URL 所指的文档装载进来，并显示出来。除了设置 location 或 location.href 用完整的 URL 替换当前的 URL 之外，还可以修改部分 URL，只需要给 Location 对象的其他属性赋值即可。这样做就会创建新的 URL，其中的一部分与原来的 URL 不同，浏览器会将它装载并显示出来。例如，假设设置了Location对象的 hash 属性，那么浏览器就会转移到当前文档中的一个指定的位置。同样，如果设置了 search 属性，那么浏览器就会重新装载附加了新的查询字符串的 URL。除了 URL 属性外，Location 对象的 reload() 方法可以重新装载当前文档，replace() 可以装载一个新文档而无须为它创建一个新的历史记录，也就是说，在浏览器的历史列表中，新文档将替换当前文档。","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"字符关系操作","date":"2017-01-02T15:33:46.000Z","path":"2017/01/02/字符关系操作/","text":"字符关系操作//操作符字符串的隐性转换 test//乘法 console.dir(&quot;-------以下乘法---------&quot;); console.dir(5*&quot;5&quot;); console.dir(5*&quot;a&quot;); console.dir(5*NaN); console.dir(5*null); console.dir(5*undefined); console.dir(5*5); console.dir(&quot;-------以上乘法---------&quot;); //除法 console.dir(&quot;-------以下除法---------&quot;); console.dir(5/&quot;5&quot;); console.dir(5/&quot;a&quot;); console.dir(5/NaN); console.dir(5/null); console.dir(null/5); console.dir(5/undefined); console.dir(5/5); console.dir(5/0); console.dir(0/5); console.dir(0/0); console.dir(&quot;-------以上除法---------&quot;); //取余、求模 console.dir(&quot;-------以下取余、求模--------&quot;); console.dir(16%&quot;5&quot;); console.dir(5%&quot;a&quot;); console.dir(5%NaN); console.dir(5%null); console.dir(null%5); console.dir(5%undefined); console.dir(5%5); console.dir(5%0); console.dir(0%5); console.dir(0%0); console.dir(&quot;-------以上取余、求模---------&quot;); //加法 console.dir(&quot;-------以下加法--------&quot;); console.dir(16+&quot;5&quot;); console.dir(5+&quot;a&quot;); console.dir(5+NaN); console.dir(5+null); console.dir(5+undefined); console.dir(5+5); console.dir(&quot;两个数的和是&quot;+5+5); console.dir(&quot;两个数的和是&quot;+(5+5)); console.dir(&quot;-------以上加法--------&quot;); //减法 console.dir(&quot;-------以下减法--------&quot;); console.dir(16-&quot;5&quot;); console.dir(5-&quot;a&quot;); console.dir(5-NaN); console.dir(5-null); console.dir(5-undefined); console.dir(5-5); console.dir(5-true); console.dir(5-&quot;true&quot;); console.dir(5-&quot;&quot;); console.dir(&quot;两个数的差是&quot;+5-5); console.dir(&quot;两个数的差是&quot;+(5-5)); console.dir(&quot;-------以上减法--------&quot;); //关系操作符 console.dir(&quot;-------以下关系操作符--------&quot;); console.dir(16&gt;&quot;5&quot;); console.dir(&quot;16&quot;&gt;&quot;5&quot;); console.dir(5&lt;&quot;a&quot;); console.dir(5&gt;=NaN); console.dir(5&lt;NaN); console.dir(NaN&gt;=NaN); console.dir(5&gt;=null); console.dir(5&gt;=undefined); console.dir(5&gt;=5); console.dir(5&gt;=true); console.dir(5&gt;=&quot;true&quot;); console.dir(5&gt;=&quot;&quot;); console.dir(&quot;Brick&quot;&gt;&quot;alphabet&quot;); console.dir(&quot;brick&quot;&gt;&quot;alphabet&quot;); console.dir(&quot;-------以上关系操作符--------&quot;); answers//乘法 console.dir(5*&quot;5&quot;); //25 console.dir(5*&quot;a&quot;);//NaN console.dir(5*NaN);//NaN console.dir(5*null);0 console.dir(5*undefined);//NaN console.dir(5*5);//25 //除法 console.dir(5/&quot;5&quot;);//1 将字符转化为数字进行相除 console.dir(5/&quot;a&quot;);//NaN 将“a”用Number()函数进行转化，出来的值是NaN，结果就是NaN console.dir(5/NaN);//NaN console.dir(5/null);//Infinity null用Number()函数进行转化，结果是0，那么5/0是正无穷 console.dir(null/5);//0 同上0/5是0 console.dir(5/undefined);//NaN undefined 用Number()进行转化，结果是NaN console.dir(5/5);//1 console.dir(5/0);//Infinity console.dir(0/5);//0 console.dir(0/0);//NaN //0除以0结果是NaN //取模 console.dir(16%&quot;5&quot;); //1 将字符串5通过Number()转化为5然后进行求余 console.dir(5%&quot;a&quot;);//NaN console.dir(5%NaN);//NaN console.dir(5%null);//NaN 将null 通过Number()转化，结果是0，然后计算5%0 ，结果是NaN console.dir(null%5);//0 同上0%5 取余，结果是0 console.dir(5%undefined);//NaN console.dir(5%5);//0 console.dir(5%0);//NaN console.dir(0%5);//0 console.dir(0%0);//NaN console.dir(Infinity%Infinity);//NaN console.dir(5%Infinity);//5 console.dir(Infinity%5); //NaN //减法 console.dir(16-&quot;5&quot;);//11 console.dir(5-&quot;a&quot;);//NaN console.dir(5-NaN);//NaN console.dir(5-null);//5 console.dir(5-undefined);//NaN console.dir(5-5);//0 console.dir(5-true);//4 console.dir(5-&quot;true&quot;);//NaN console.dir(5-&quot;&quot;);//5 console.dir(5-Infinity);//-Infinity console.dir(Infinity-Infinity);//NaN console.dir(&quot;两个数的差是&quot;+5-5);//NaN console.dir(&quot;两个数的差是&quot;+(5-5));//两个数的差是0 //关系操作符 console.dir(16&gt;&quot;5&quot;); //true console.dir(&quot;16&quot;&gt;&quot;5&quot;);//false console.dir(5&lt;&quot;a&quot;);//false console.dir(5&gt;=NaN);//false console.dir(5&lt;NaN);//false console.dir(NaN&gt;=NaN);//false console.dir(5&gt;=null);//true console.dir(5&gt;=undefined);//false console.dir(5&gt;=5);//true console.dir(5&gt;=true);//true console.dir(5&gt;=&quot;true&quot;);//false console.dir(5&gt;=&quot;&quot;);//true console.dir(&quot;Brick&quot;&gt;&quot;alphabet&quot;);//false B的字符串编码值是66 ，而a的字符串编码是97.因此false console.dir(&quot;brick&quot;&gt;&quot;alphabet&quot;);//true 小写字母b比a大，所以是true //加法 console.dir(16+&quot;5&quot;); //156 console.dir(5+&quot;a&quot;);//5a console.dir(5+NaN);//NaN console.dir(5+null);//5 console.dir(&apos;5&apos;+null);//5null console.dir(5+undefined);//NaN console.dir(null+undefined);//NaN console.dir(5+5);//10 console.dir(&quot;两个数的和是&quot;+5+5);//两个数的和是55 console.dir(&quot;两个数的和是&quot;+(5+5));//两个数的和是10","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"关于显示内容高度与宽度问题","date":"2017-01-02T15:27:01.000Z","path":"2017/01/02/关于显示内容高度与宽度问题/","text":"关于显示内容高度与宽度问题网页可见区域宽： document .body.clientWidth;网页可见区域高： document .body.clientHeight;网页可见区域宽： document .body.offsetWidth (包括边线的宽);网页可见区域高： document .body.offsetHeight (包括边线的宽);网页正文全文宽： document .body.scrollWidth;网页正文全文高： document .body.scrollHeight;网页被卷去的高： document .body.scrollTop;网页被卷去的左： document .body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度：window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth; scrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX: 相对文档的水平座标event.clientY: 相对文档的垂直座标 event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop相对文档的水平座标+垂直方向滚动的量 要获取当前页面的滚动条纵坐标位置，用：document .documentElement.scrollTop;而不是：document .body.scrollTop;documentElement 对应的是 html 标签，而 body 对应的是 body 标签。 在标准w3c下，document .body.scrollTop恒为0，需要用document .documentElement.scrollTop来代替;如果你想定位鼠标相对于页面的绝对位置时，你会发现google里面1000篇文章里面有999.99篇会让你使用event.clientX+document.body.scrollLeft，event.clientY+document .body.scrollTop，如果你发现你的鼠标定位偏离了你的想象，请不要奇怪，这是再正常不过的事情。ie5.5之后已经不支持document .body.scrollX对象了。所以在编程的时候，请加上这样的判断 if (document .body &amp;&amp; document .body.scrollTop &amp;&amp; document .body.scrollLeft) { top=document .body.scrollTop; left=document .body.scrollleft; } if (document .documentElement &amp;&amp; document .documentElement.scrollTop &amp;&amp; document .documentElement.scrollLeft) { top=document .documentElement.scrollTop; left=document .documentElement.scrollLeft; }","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"常用正则验证表达式","date":"2017-01-02T15:16:25.000Z","path":"2017/01/02/常用正则验证表达式/","text":"常用正则验证表达式匹配中文字符的正则表达式：[u4e00-u9fa5] 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 匹配双字节字符(包括汉字在内)：[^x00-xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：ns*r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^s*|s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 评注：表单验证时很实用 匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配国内电话号码：d{3}-d{8}|d{4}-d{7} 评注：匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,} 评注：腾讯QQ号从10000开始 匹配中国邮政编码：[1-9]d{5}(?!d) 评注：中国邮政编码为6位数字 匹配身份证：d{15}|d{18} 评注：中国的身份证为15位或18位 匹配ip地址：d+.d+.d+.d+ 评注：提取ip地址时有用 匹配特定数字：^[1-9]d*$ //匹配正整数 ^-[1-9]d*$ //匹配负整数 ^-?[1-9]d*$ //匹配整数 ^[1-9]d*|0$ //匹配非负整数（正整数 + 0） ^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） ^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 ^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） 评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串：^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 ^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 ^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 输入验证：只能输入数字：“^[0-9]*$” 只能输入n位的数字：“^d{n}$” 只能输入至少n位数字：“^d{n,}$” 只能输入m-n位的数字：“^d{m,n}$” 只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” 只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” 只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” 只能输入非零的正整数：“^+?[1-9][0-9]*$” 只能输入非零的负整数：“^-[1-9][0-9]*$” 只能输入长度为3的字符：“^.{3}$” 只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” 只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” 只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” 只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” 只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” 其他验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， 只能包含字符、数字和下划线。 验证是否含有^%&amp;&apos;&apos;,;=?$&quot;等字符：“[^%&amp;&apos;&apos;,;=?$x22]+” 只能输入汉字：“^[u4e00-u9fa5],{0,}$” 验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” 验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” 验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” 正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， “XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 验证身份证号（15位或18位数字）：“^d{15}|d{}18$” 验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” 验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” 正确格式为：“01”“09”和“1”“31”。 匹配中文字符的正则表达式： [u4e00-u9fa5] 匹配双字节字符(包括汉字在内)：[^x00-xff] 匹配空行的正则表达式：n[s| ]*r 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*|&lt;(.*) /&gt;/ 匹配首尾空格的正则表达式：(^s*)|(s*$) 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?*/","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"伪类与伪元素区别","date":"2017-01-01T03:45:31.000Z","path":"2017/01/01/伪类与伪元素区别/","text":"伪类与伪元素的区别伪类：用于向某些选择器添加特殊的效果。伪元素：用于向某些选择器内部的内容添加特殊效果。 伪类种类:active //将样式添加到被激活的元素 :focus //将样式添加到获得焦点的元素 :hover //当鼠标悬浮在元素上方时，向元素添加样式 :link //将样式添加到未被访问的链接 :visited //将样式添加到被访问过的链接 :first-child //将样式添加到元素的第一个子元素，记住，这个为伪类！！！ :lang //允许创作者来定义指定的元素中使用的语言 伪元素种类::first-letter //将样式添加到元素的文本首字母，只对块级元素有用 ::first-line //将样式添加到元素的文本首行，只对块级元素有用 ::before //在元素之前插入某些内容 ::after //在元素之后插入某些内容 区别这里用伪类:first-child和伪元素::first-letter来进行比较。 p&gt;i:first-child {color: red} &lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt; &lt;/p&gt; first单词会变为红色。 p:first-letter {color: red} &lt;p&gt;I am stephen lee.&lt;/p&gt; 字母 I 会变为红色。 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。 伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 但因为兼容性的问题（IE从9开始才支持双冒号伪元素写法），所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者。 THE END. 本文摘自：https://segmentfault.com/a/1190000000484493","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"清除浮动的几种方法","date":"2017-01-01T02:12:53.000Z","path":"2017/01/01/清除浮动的几种方法/","text":"清除浮动的几种常见方法1.clear方法.child{clear：both;} 适用于浮动元素后面容器之内有个非浮动元素，或是额外添加一个新的空元素。设置了clear 属性的元素，其上边框位置会紧贴浮动元素的 margin-bottom 边界位置渲染，使包含浮动元素的容器高度正常。 2.伪类添加新元素.parent::after{content:&quot;&quot;; display:block; clear:both;} 只适用于父容器最后一级子元素是浮动的，即浮动元素后面没有非浮动元素把它和父容器隔开。IE6/7不支持:after 伪元素。原理同上。 3.overflow:hidden/auto方法.parent{overflow:hidden;} .parent{overflow:auto;} 创建了overflow 样式值为非visilbe的元素，实际上是创建了 CSS 2.1 规范定义的 Block Formatting Contexts，会重新计算其内部元素位置，从而获得确切高度。这样父容器也就包含了浮动元素高度。这个名词过于晦涩，在 CSS 3 草案中被变更为名词 Root Flow，顾名思义，是创建了一个新的根布局流，这个布局流是独立的，不影响其外部元素的。测试时当子元素同时混有浮动元素和非浮动元素时效果并不好。IE6/7 中并不被支持。 4.display:table/table-cell方法.parent{display:table;} .parent{display:table-cell;} 当元素 display 值被设定为 table 或 table-cell 时，同样也创建了 CSS 2.1 规范定义的 Block Formatting Contexts。这样父容器也就包含了浮动元素高度。IE6/7 中并不被支持。 5.使用表格类元素作为浮动元素容器把浮动元素匡在td里就木有浮动问题，而且木有兼容问题。当使用 TABLE TD TH 等 TABLE 系列标签时， 元素的 display 值实际上说是 display: table 系列，这同样也创建了 CSS 2.1 规范定义的 Block Formatting Contexts。这样父容器也就包含了浮动元素高度。同时在 IE 6/7 中，TABLE TD TH 等 TABLE 系列标签天然拥有 haslayout 特性。 6.浮动父元素虽然这种方式并没有兼容问题，但实际使用中并不推荐。因为很容易推断出，页面中只要有一个浮动元素，使用该方法清理浮动将不可避免的使页面所有元素都浮动才可以达到预期效果。 7.触发 hasLayout‘Layout’ 是 IE 的专有概念，它决定了元素如何对其内容进行定位和尺寸计算，与其他元素的关系和相互作用，以及对应用还有使用者的影响。‘Layout’ 可以被某些 CSS property（特性）不可逆的触发，而某些 HTML 元素本身就具有 layout 。‘Layout’ 在 IE 中可以通过 hasLayout 属性来判断一个元素是否拥有 layout ，如 object.currentStyle.hasLayout。‘Layout’ 是 IE 浏览器渲染引擎的一个内部组成部分。在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容。为了协调这两种方式的矛盾，渲染引擎采用了 ‘hasLayout’ 属性，属性值可以为 true 或 false。 当一个元素的 ‘hasLayout’ 属性值为 true 时，我们说这个元素有一个布局（layout），或拥有布局。 //常见触发 hasLayout 的 CSS： .haslayout-clear-float:{width:1px} .haslayout-clear-float:{height:1px} .haslayout-clear-float:{zoom:1} //默认拥有布局的元素： &lt;html&gt;, &lt;body&gt; &lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt; &lt;img&gt; &lt;hr&gt; &lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt; &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt; &lt;marquee&gt; IE7 还有一些额外的属性(不完全列表)可以触发 hasLayout ： min-height: (任意值) min-width: (任意值) max-height: (除 none 外任意值) max-width: (除 none 外任意值) overflow: (除 visible 外任意值，仅用于块级元素) overflow-x: (除 visible 外任意值，仅用于块级元素) overflow-y: (除 visible 外任意值，仅用于块级元素) position: fixed IE6 以前的版本（也包括 IE6 及以后所有版本的混杂模式，其实这种混杂模式在渲染方面就相当于 IE 5.5）， 通过设置任何元素的 ‘width’ 或 ‘height’（非auto）都可以触发 hasLayout ； 但在 IE6 和 IE7 的标准模式中的行内元素上却不行，设置 ‘display:inline-block’ 才可以。 注意兼容问题：haslayout 特性仅 IE 支持，其他浏览器并无此特性。可以依靠计算布局清理浮动的 haslayout 特性仅在 IE 6/7 中存在，IE8 之后将使用 CSS 2.1 的 Block Formatting Contexts 定义来达到同样效果。 使用推荐：.clearfix{zoom:1;} .clearfix::before,.clearfix::after{content:&quot;&quot;;display:block;clear:both;} THE END.","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"js遍历二叉树","date":"2016-12-31T13:16:50.000Z","path":"2016/12/31/js遍历树/","text":"javascript遍历二叉树本文记录JavaScript对二叉树的一些常见遍历算法。以下为一个二叉树的模拟结构： var tree = { value: 1, left: { value: 2, left: { value: 4 } }, right: { value: 3, left: { value: 5, left: { value: 7 }, right: { value: 8 } }, right: { value: 6 } } }; 对一个树的遍历分为先序遍历、中序遍历和后序遍历。若以以下表示顺序法： D：访问根结点，L：遍历根结点的左子树，R：遍历根结点的右子树表示遍历顺序的话，先序遍历：以从上到下，从左到右的顺序遍历；(DLR)中序遍历：以从下到上，从左到右的顺序遍历；(LDR)后序遍历：以从左到右，从下到上的顺序遍历；(LRD)以上遍历均为 深度优先遍历 ，还有一种为 广度优先遍历。 广度优先遍历：是以树的层级为遍历的原则的，首选从上到下遍历层，遍历层时以从左到右的原则将个整层遍历完后才会遍历下一个层级。 以下为代码实现： 广度优先遍历：首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该结点的左子树为非空，则将该结点的左子树入队列；如果该结点的右子树为非空，则将该结点的右子树入队列。其实就是把节点以队列的形式存放，抛出先存放的节点，获取其子节点存入队列，这样便实现了以层的形式去遍历。若不是二叉树而是树，则需要遍历该节点下的亲子节点存入队列，就可以实现对树的遍历 var levelOrderTraversal = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var que = []; que.push(node); while(que.length !== 0) { node = que.shift(); console.log(node.value); if(node.left) que.push(node.left); if(node.right) que.push(node.right); } } 递归深度优先遍历根据遍历时，所执行的输出顺序不同实现。 先序递归遍历：var preOrder = function (node) { if (node) { console.log(node.value); preOrder(node.left); preOrder(node.right); } } 中序递归遍历var inOrder = function (node) { if (node) { inOrder(node.left); console.log(node.value); inOrder(node.right); } } 后序递归遍历var postOrder = function (node) { if (node) { postOrder(node.left); postOrder(node.right); console.log(node.value); } } 非递归深度优先遍历非递归先序遍历：这种方法与广度优先遍历很相似，只是将 队列 的方式改为了 栈 的形式，一个是先入先出，一个是后入先出原则。 var preOrderUnRecur = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var stack = []; stack.push(node); while(stack.length !== 0) { node = stack.pop(); console.log(node.value); if(node.right) stack.push(node.right); if(node.left) stack.push(node.left); } } 非递归中序遍历：var inOrderUnRecur = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var stack = []; while(stack.length !== 0 || node) { if(node) { stack.push(node); node = node.left; } else { node = stack.pop(); console.log(node.value); node = node.right; } } } 非递归后序遍历：var posOrderUnRecur = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var stack = []; stack.push(node); var tmp = null; while(stack.length !== 0) { tmp = stack[stack.length - 1]; if(tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) { stack.push(tmp.left); } else if(tmp.right &amp;&amp; node !== tmp.right) { stack.push(tmp.right); } else { console.log(stack.pop().value); node = tmp; } } } 另外一种方法: var posOrderUnRecur = function(node) { if(node) { var s1 = []; var s2 = []; s1.push(node); while(s1.length !== 0) { node = s1.pop(); s2.push(node); if(node.left) { s1.push(node.left); } if(node.right) { s1.push(node.right); } } while(s2.length !== 0) { console.log(s2.pop().value); } } } Morris遍历这个方法即不用递归也不用栈实现三种深度遍历，空间复杂度为O(1)。 Morris先序:var morrisPre = function(head) { if(!head) { return; } var cur1 = head; var cur2 = null; while(cur1) { cur2 = cur1.left; if(cur2) { while(cur2.right &amp;&amp; cur2.right != cur1) { cur2 = cur2.right; } if(!cur2.right) { cur2.right = cur1; console.log(cur1.value); cur1 = cur1.left; continue; } else { cur2.right = null; } } else { console.log(cur1.value); } cur1 = cur1.right; } } Morris中序:var morrisIn = function(head) { if(!head) { return; } var cur1 = head; var cur2 = null; while(cur1) { cur2 = cur1.left; if(cur2) { while(cur2.right &amp;&amp; cur2.right !== cur1) { cur2 = cur2.right; } if(!cur2.right) { cur2.right = cur1; cur1 = cur1.left; continue; } else { cur2.right = null; } } console.log(cur1.value); cur1 = cur1.right; } } Morris后序:var morrisPost = function(head) { if(!head) { return; } var cur1 = head; var cur2 = null; while(cur1) { cur2 = cur1.left; if(cur2) { while(cur2.right &amp;&amp; cur2.right !== cur1) { cur2 = cur2.right; } if(!cur2.right) { cur2.right = cur1; cur1 = cur1.left; continue; } else { cur2.right = null; printEdge(cur1.left); } } cur1 = cur1.right; } printEdge(head); } var printEdge = function(head) { var tail = reverseEdge(head); var cur = tail; while(cur) { console.log(cur.value); cur = cur.right; } reverseEdge(tail); } var reverseEdge = function(head) { var pre = null; var next = null; while(head) { next = head.right; head.right = pre; pre = head; head = next; } return pre; } 本文摘自：https://segmentfault.com/a/1190000004620352","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"gulp简介及基本用法","date":"2016-12-30T13:40:36.000Z","path":"2016/12/30/gulp简介及基本用法/","text":"gulp简介及基本用法基本操作 全局安装：npm install --global gulp 作为项目的开发依赖（devDependencies）安装：npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp：gulp,只书写gulp的话只会执行default的任务，要执行其他任务，可以输入gulp &lt;task&gt; &lt;othertask&gt; 官方文档http://www.gulpjs.com.cn/docs/api/ API简单介绍gulp的方法只有5个：gulp.src() // 设置处理文件的路径gulp.dest() // 设置处理后的文件存放路径gulp.task() // 任务定义gulp.pipe() // 处理管道运行gulp.watch() // 文件监听 1. gulp.src(globs[,options])输出符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。目前常用为直接写文件路径。 gulp.task(&apos;image&apos;, function() { gulp.src(&apos;src/img/**/*.*&apos;) // src/img目录下的所有文件 .pipe(gulp.dest(&apos;dist/img&apos;)); // 存放到dist/img目录下 }); 2. gulp.dest(path[, options])将src匹配并处理后pipe过来的文件写到指定文件，也可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。path为文件存放路径。也可以传入一个函数，在函数中返回相应路径。 gulp.task(&apos;image&apos;, function() { gulp.src(&apos;src/img/**/*.*&apos;) // src/img目录下的所有文件 .pipe(gulp.dest(&apos;dist/img&apos;)) // 存放到dist/img目录下 .pipe(gulp.dest(&apos;test/&apos;)); // 再存放一份到test/目录 }); 3. gulp.task(name[, deps], fn)gulp.task(&apos;somename&apos;, function() { // 做一些事 }); 定义一个执行任务。name:任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。deps:类型:Array,非必须，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。依赖的异步任务必须要有异步执行方式：使用一个 callback，或者返回一个 promise 或 stream来通知主任务，前面的依赖任务已完成gulp的task任务是按最大并发执行的，也就是全部同时执行。 gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() { // 做一些事 }); // 常见的异步方式为返回一个stream，如下return gulp.task(&apos;array&apos;, function() { return gulp.src(&apos;*.*&apos;) .pipe(gulp.dest(&apos;test/&apos;)); }) fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。 4. gulp.src().pipe()任务的数据传递方法，将上一个插件处理后的文件数据传往下一个处理插件。 5. gulp.watch(glob[, opts], tasks)监视文件，并且可以在文件发生改动时候做一些事情。glob:一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动,常使用文件路径。opts：传给 gaze 的参数。不常用。tasks：类型：Array，需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字。 gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); // 当指定文件变动时，就会执行uglify和reload任务 也可以 gulp.watch(glob[, opts], fn); fn为文件改变后执行的自定义回调。 6. gulp有无return的区别依据gulp官方文档，gulp的task方法是按最大并发执行的，也就是说所有的task都会同时执行，而对于依赖于其他任务的异步task来说，就需要一个通知来告知该什么时候执行。故需要一个return。 gulp.task(&apos;js&apos;, [&apos;css&apos;], function() { // 做一些事 }); // js这个异步任务就需要css任务执行完毕后给一个提示，可以为如下3种方式 // 1.返回一个stream，就是直接return的方式 gulp.task(&apos;css&apos;, function() { var stream = gulp.src(&apos;client/**/*.css&apos;) .pipe(gulp.dest(&apos;build&apos;)); return stream; }); // 2. 返回一个promise gulp.task(&apos;css&apos;, function() { var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() { deferred.resolve(); }, 1); return deferred.promise; }); // 3. 执行一个回调 gulp.task(&apos;css&apos;, function(cb) { exec(&apos;jekyll build&apos;, function(err) { if (err) return cb(err); // 返回 error cb(); // 完成 task }); }); 基本的gulpfile.js示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//引入gulp及其插件模块var gulp = require(&apos;gulp&apos;); //gulp基本包var autoprefixer = require(&apos;gulp-autoprefixer&apos;); //css前缀处理var cssnano = require(&apos;gulp-cssnano&apos;); //css压缩var uglify = require(&apos;gulp-uglify&apos;); //压缩 JavaScriptvar htmlmin = require(&apos;gulp-htmlmin&apos;); //html压缩var imagemin = require(&apos;gulp-imagemin&apos;); //图片压缩//注册样式编译任务gulp.task(&apos;style&apos;, function() &#123; return gulp.src(&apos;src/css/*.css&apos;) .pipe(autoprefixer(&#123;browsers: [ &quot;ie &gt;= 8&quot;, &quot;ie_mob &gt;= 10&quot;, &quot;ff &gt;= 26&quot;, &quot;chrome &gt;= 30&quot;, &quot;safari &gt;= 6&quot;, &quot;opera &gt;= 23&quot;, &quot;ios &gt;= 5&quot;, &quot;android &gt;= 2.3&quot;, &quot;bb &gt;= 10&quot; ]&#125;)) .pipe(cssnano()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;);gulp.task(&apos;image&apos;, function() &#123; return gulp.src(&apos;src/img/**/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/img&apos;));&#125;);gulp.task(&apos;script&apos;, function() &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);gulp.task(&apos;html&apos;, function() &#123; return gulp.src(&apos;src/*.html&apos;) .pipe(htmlmin(&#123; collapseWhitespace: true, collapseBooleanAttributes: true, removeAttributeQuotes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, &#125;)) .pipe(gulp.dest(&apos;dist&apos;));&#125;);//监听文档gulp.task(&apos;serve&apos;, [&apos;style&apos;, &apos;image&apos;, &apos;script&apos;, &apos;html&apos;], function() &#123; gulp.watch(&apos;src/styles/*.css&apos;, [&apos;style&apos;]); gulp.watch(&apos;src/images/*.*&apos;, [&apos;image&apos;]); gulp.watch(&apos;src/scripts/*.js&apos;, [&apos;script&apos;]); gulp.watch(&apos;src/*.html&apos;, [&apos;html&apos;]);&#125;); THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"常用工具网站","date":"2016-12-30T09:43:28.000Z","path":"2016/12/30/常用工具网站/","text":"常用工具网站汇总 png/jpg在线压缩http://tinypng.com 浏览器兼容hack书写http://browserhacks.com/ 浏览器特性支持检测http://caniuse.com/ 字体下载http://www.youziku.com/图标下载http://www.iconfont.cn/字体图标http://fontawesome.dashgame.com/https://icomoon.ioSVG图标下载http://www.iconsvg.com/ npm官网https://www.npmjs.comgulp官网http://gulpjs.com 编程社区，练习https://www.codewars.com 二维码生成http://cli.im/ 贝瑟尔曲线计算函数http://cubic-bezier.com/ 雪碧图制作网站http://spritepad.wearekiss.com/","tags":[{"name":"工具","slug":"工具","permalink":"https://naliomg.github.io/tags/工具/"}]},{"title":"hexo常用指令","date":"2016-12-30T02:02:16.000Z","path":"2016/12/30/hexo常用指令/","text":"hexo常用指令hexonpm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold） hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作 hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git解决方法: npm install hexo-deployer-git --save 2.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 Deployment Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 3.xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt 4.RSS不显示安装RSS插件 npm install hexo-generator-feed --save 5.开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 6.开启评论1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的复制到 themes\\landscape\\layout_partial\\article.ejs把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 改为 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt; 文章摘自：https://segmentfault.com/a/1190000002632530 本主题文档：http://forsigner.com/2016/03/10/fexo-doc-zh-cn/","tags":[{"name":"hexo","slug":"hexo","permalink":"https://naliomg.github.io/tags/hexo/"}]},{"title":"MD基础语法记录","date":"2016-12-29T14:42:45.000Z","path":"2016/12/29/MD基础语法记录/","text":"Markdown 语法的简要规则1. 标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 2. 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 * 无序列表1 * 无序列表2 1. 有序列表1 2. 有序列表2 3. 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可。 例如这样书写 4. 图片与链接插入链接与插入图片的语法很像，区别在一个 ! 号： 图片为：![](){ImgCap}{/ImgCap}链接为：[]() 插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。 5. 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 6. 表格表格是我觉得 Markdown 比较累人的地方，例子如下： | Tables | Are | Cool | \\\\表头 | ------------- |:-------------:| -----:| \\\\表头与主体的分隔，定义对齐方式 | col 3 is | right-aligned | $1600 | \\\\对齐默认为左对齐 | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 7. 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，若要实现行间代码，只需要用两个 ` 把中间的代码包裹起来；若需要使用代码块，使用 tab 键缩进即可。 var a = 9; \\\\这里就是行间代码 var a = 9; \\\\这里就是代码块 8. 分割线分割线的语法只需要三个 * 号，效果如下： 以上就是 Markdown 的基本使用方法，官方说明可参见：http://www.appinn.com/markdown/","tags":[{"name":"md","slug":"md","permalink":"https://naliomg.github.io/tags/md/"}]}]