[{"title":"Git使用","date":"2020-06-18T12:47:43.000Z","path":"2020/06/18/git/","text":"Git常见使用 git clone http||ssh 代码拉取; git status 查看当前分支有哪些修改; git diff 查看当前没有add的内容 git add . 将本地所有新增文件提交到本地缓存区 git add [filepath] 将本地某个新增文件提交到本地缓存区 git commit -m &#39;log&#39; 把stage中所有的修改提交到本地库 git push 把本地库的修改提交到远程库中 git pull 把远程库的代码更新到工作台 git fetch 把远程库的代码更新到本地库，相较于git pull，fetch只更新了本地的origin分支，需要用户自行与工作区比较合并，但pull会更新本地origin，同时更新工作区。 git branch -a 查看全部分支 git checkout master/branch 切换到某个分支 git log 查看当前分支上面的日志信息 git remote -v 查看远程仓库地址 git branch 分支名 创建新的分支 git revert commitid 将本地修改还原回 线上的版本 git checkout -- a.txt 放弃某个文件在工作区的修改，不会修改缓存区(add)和HEAD(commit)版本，还原到缓存区状态 git checkout -- . 放弃整个工作区的修改 git reset HEAD --hard 放弃缓存区(add)的修改，–hard 同时更改工作区，不然只撤销对缓存区的修改 git reset HEAD a.txt 放弃缓存区某个文件的记录，但是不会更改文件 git reset HEAD . 放弃整个缓存区的文件记录，但是不会更改文件 git reset --hard commitid 回到某个提交的commit git reset --hard HEAD^ 回到当前HEAD的上一个版本 git checkout -b branchName 切换都某一个分支，如果没有此分支，则创建后切换到该分支 常见场景： 撤销：未进行git push前的所有操作，都是在“本地仓库”中执行的。 文件被修改了，但未执行git add操作(working tree内撤销)。 记住checkout是撤销对工作区的更改。 git checkout fileName git checkout . 同时对多个文件执行了git add操作，但本次只想提交其中一部分文件。记住reset是撤销对缓冲区的更改。HEAD代表回退操作的版本。 git add * git status # 取消暂存 git reset HEAD filename 文件执行了git add操作，但想撤销对其的修改（index内回滚）。 # 取消暂存 git reset HEAD fileName # 撤销修改 git checkout fileName 修改的文件已被git commit，但想再次修改不再产生新的Commit git add sample.txt git commit --amend -m &quot;说明&quot; 撤销指定文件到指定版本 # 查看指定文件的历史版本 git log &lt;filename&gt; # 回滚到指定commitID git checkout &lt;commitID&gt; &lt;filename&gt; 删除最后一次远程提交 # 使用revert git revert HEAD git push origin master # 使用reset git reset --hard HEAD^ git push origin master -f # revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在； # reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。 回滚某次提交 # 找到要回滚的commitID git log git revert commitID 分支合并 git checkout master git merge dev # 若有冲突，则处理冲突完毕后git add, git commit提交 git push 建议线上版本以tag的方式进行保存，而不是一个分支，分支更新如果出错就会回滚，而用tag就可以直接切换，方便快捷。 git强制拉取更新远程最新代码，当reset重置了本地head后。 git fetch --all # 重置head为远程head git reset --hard origin/master # 更新 git pull","tags":[{"name":"工具","slug":"工具","permalink":"https://naliomg.github.io/tags/工具/"}]},{"title":"CORS跨域与Express实现","date":"2020-05-23T14:47:43.000Z","path":"2020/05/23/CORS跨域与Express实现/","text":"CORS跨域与Express实现浏览器跨域问题不用多说，CORS是一个很好的解决办法，浏览器自动实现（IE10+）。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 // 手动书写 let corsWhiteList = [&apos;http://localhost:3001&apos;, &apos;http://localhost:3002&apos;] app.use(&apos;*&apos;, function (req, res, next) { let origin = req.header(&apos;Origin&apos;) if (corsWhiteList.indexOf(origin) == -1) { // 不在白名单列表中。如果全开放的话，将此判断取消即可，设置为“*”是无用的 origin = &apos;&apos; } res.header(&apos;Access-Control-Allow-Origin&apos;, origin) res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, Content-Length, Authorization, Accept, X-Requested-With, yourHeaderFeild&apos;) res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT, POST, GET, DELETE, OPTIONS&apos;) //设置方法 res.header(&apos;Access-Control-Allow-Credentials&apos;, true) if (req.method == &apos;OPTIONS&apos;) { res.send(200) // 意思是，在正常的请求之前，会发送一个验证，是否可以请求，非正常简单请求会先发起option询问。 } else { next() } }) // 使用cors中间件，cors中间件的使用与配置见其官方文档 let corsWhiteList = [&apos;http://localhost:3001&apos;, &apos;http://localhost:3002&apos;] let corsOptions = { origin: function (origin, callback) { if (corsWhiteList.indexOf(origin) !== -1 || !origin) { // 本机请求未跨域origin不存在 callback(null, true) } else { callback(new Error(&apos;Not allowed by CORS&apos;)) } }, credentials: true } app.use(cors(corsOptions)) THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"css长度单位","date":"2019-09-16T14:47:43.000Z","path":"2019/09/16/css单位/","text":"css长度单位1.px绝对长度单位，像素长度。类似的还有cm(厘米)、mm(毫米)、q(0.25毫米)、in(英寸)、pt(点)、pc(派卡)，当然，后面这些基本都不会使用。 2.em相对长度单位，相对于当前对象文本的字体尺寸。如此节点内font-size=16px，则1em=16px。 3.rem相对长度单位，相对于根元素(即html元素)font-size计算值的倍数。如html的font-size=16px，则1rem=16px。IE9以前不支持。 4.ex相对长度单位，相对于字符“x”的高度。了解即可。 5.ch相对长度单位，数字“0”的宽度。了解即可。 6.vm相对长度单位，相对于视口的宽度，视口被均分为100单位的vw。 7.vh相对长度单位，相对于视口的高度，视口被均分为100单位的vh。 8.vmax相对长度单位，相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax。IE不支持。 9.vmin相对长度单位，相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin。IE9以前不支持。","tags":[{"name":"css3","slug":"css3","permalink":"https://naliomg.github.io/tags/css3/"}]},{"title":"CSS3实现3D旋转","date":"2019-09-16T14:46:43.000Z","path":"2019/09/16/CSS3实现3D旋转/","text":"CSS3实现3D旋转常用的3D效果样式如下： perspective: 600px; // 透视效果，值越小，透视越明显 perspective-origin: center center; // 透视中心点位置 transform: rotateX(70deg) rotateY(15deg); // 3D旋转 transform: translateX(100px) translateY(100px) translateZ(100px); // 3D偏移 transform-style: preserve-3d; // 3D呈现，基本必须，不然就是2D的 例一： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; * { box-sizing: border-box; } body { margin: 0; position: absolute; width: 100%; height: 100%; perspective: 600px; /*透视效果*/ perspective-origin: center center; } #circleWrap { transform: rotateX(70deg) rotateY(15deg); position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; transform-style: preserve-3d; } #circle { width: 200px; height: 200px; border: 10px solid #eee; border-radius: 50%; animation: mytotate1 4s infinite linear; transform-style: preserve-3d; } #circle .dot { position: absolute; width: 26px; height: 26px; top: -13px; left: 100px; background-color: #999; border-radius: 50%; animation: mytotate2 4s infinite linear; transform: rotateX(-90deg); } #core { width: 120px; height: 120px; position: relative; left: 50%; top: -50%; margin-top: -60px; margin-left: -60px; border-radius: 50%; background-color: #666; transform: rotateX(-70deg); } @keyframes mytotate1 { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } @keyframes mytotate2 { from { transform: rotate(360deg) rotateX(-70deg); } to { transform: rotate(0deg) rotateX(-70deg); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;circleWrap&quot;&gt; &lt;div id=&quot;circle&quot;&gt; &lt;div class=&quot;dot&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;core&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 例二： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;3d-cube&lt;/title&gt; &lt;style&gt; * { box-sizing: border-box; } html { height: 100%; } body { background-color: #000; height: 100%; padding: 0; margin: 0; perspective: 1600px; /*透视效果*/ perspective-origin: center center; } .container { position: absolute; left: 50%; top: 50%; width: 200px; height: 200px; margin-top: -100px; margin-left: -100px; transform-style: preserve-3d; /*这个是很重要的*/ /*transform: rotateX(0deg) rotateY(0deg);*/ animation: rotate infinite 12s linear; } .cube { position: absolute; width: 200px; height: 200px; transform-style: preserve-3d; transform: rotateX(0deg) rotateY(90deg); } .side { /*主边*/ position: absolute; width: 200px; height: 200px; border: 2px dotted rgba(255, 213, 0, 0.35); border-radius: 50%; transform-style: preserve-3d; /*节点的伪节点不可继承，故需要重新声明*/ } .side::before, .side::after { content: &apos;&apos;; display: block; position: absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto; border-radius: 50%; border: 1px solid; box-shadow: inset 0 0 60px, 0 0 110px; } .side::before { /*内边*/ width: 100px; height: 100px; color: gold; } .side::after { /*内边*/ width: 80px; height: 80px; color: teal; box-shadow: inset 0 0 40px, 0 0 90px; transform: translateZ(-30px); /*3d处理，向内侧偏移*/ } .side-inner { position: absolute; left: 0; right: 0; bottom: 0; top: 0; width: 60px; height: 60px; margin: auto; border-radius: 50%; border: 1px solid; box-shadow: inset 0 0 30px, 0 0 80px; color: orangered; transform: translateZ(30px); transform-style: preserve-3d; } .side-inner::after { content: &apos;&apos;; display: block; position: absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto; border-radius: 50%; border: 1px solid; box-shadow: inset 0 0 20px, 0 0 60px; width: 40px; height: 40px; color: purple; transform: translateZ(30px); } .side-front { /*设置面位置*/ transform: translateZ(100px); } .side-back { transform: rotateY(180deg) translateZ(100px); } .side-left { transform: rotateY(-90deg) translateZ(100px); } .side-right { transform: rotateY(90deg) translateZ(100px); } .side-top { transform: rotateX(90deg) translateZ(100px); } .side-bottom { transform: rotateX(-90deg) translateZ(100px); } @keyframes rotate { 100% { transform: rotateX(360deg) rotateY(720deg) rotateZ(360deg); } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;cube&quot;&gt; &lt;div class=&quot;side side-front&quot;&gt;&lt;div class=&quot;side-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;side side-back&quot;&gt;&lt;div class=&quot;side-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;side side-left&quot;&gt;&lt;div class=&quot;side-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;side side-right&quot;&gt;&lt;div class=&quot;side-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;side side-top&quot;&gt;&lt;div class=&quot;side-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;side side-bottom&quot;&gt;&lt;div class=&quot;side-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"css3","slug":"css3","permalink":"https://naliomg.github.io/tags/css3/"}]},{"title":"vue-router简介","date":"2019-08-03T01:55:55.000Z","path":"2019/08/03/vue-router/","text":"vue-router1.安装npm install vue-router import Vue from &apos;vue&apos; import VueRouter from &apos;vue-router&apos; Vue.use(VueRouter) 2.使用需要在vue实例化时，将router挂载到实例对象上。 // html结构 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; // 路由脚本挂载 // 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter) // 1. 定义 (路由) 组件。 // 可以从其他文件 import 进来 const Foo = { template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos; } const Bar = { template: &apos;&lt;div&gt;bar&lt;/div&gt;&apos; } // 2. 定义路由 // 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是 // 通过 Vue.extend() 创建的组件构造器， // 或者，只是一个组件配置对象。 // 我们晚点再讨论嵌套路由。 const routes = [ { path: &apos;/foo&apos;, component: Foo }, { path: &apos;/bar&apos;, component: Bar } ] // 3. 创建 router 实例，然后传 `routes` 配置 // 你还可以传别的配置参数, 不过先这么简单着吧。 const router = new VueRouter({ routes // (缩写) 相当于 routes: routes }) // 4. 创建和挂载根实例。 // 记得要通过 router 配置参数注入路由， // 从而让整个应用都有路由功能 const app = new Vue({ router }).$mount(&apos;#app&apos;) 通过注入路由器，我们可以在任何组件内通过this.$router访问路由器，也可以通过this.$route访问当前路由。 this.$router.go(-1) this.$router.push(&apos;/&apos;) 当然，一般项目中会将路由模块化： import Vue from &apos;vue&apos; import Router from &apos;vue-router&apos; // 以下引入为页面的vue文件 import Page404 from &apos;@/views/Page404.vue&apos; import Home from &apos;@/views/Home.vue&apos; import Loan from &apos;@/views/Loan.vue&apos; import LoanChart from &apos;@/views/LoanChart.vue&apos; import RepayChart from &apos;@/views/RepayChart.vue&apos; import LoanHistory from &apos;@/views/LoanHistory.vue&apos; import LoanList from &apos;@/views/LoanList.vue&apos; import DoRepay from &apos;@/views/DoRepay.vue&apos; Vue.use(Router) // 初始化路由 export default new Router({ // 返回路由实例 mode: &apos;history&apos;, // history模式：不使用hash作为路由跳转依据，而使用正常的网页路径，服务器路由需要配置好主页面跳转 base: process.env.BASE_URL, // 基础url routes: [ // 具体路由列表 { path: &apos;/&apos;, name: &apos;home&apos;, // 路由命名后，使用路由跳转会更加方便 component: Home }, { path: &apos;/loan&apos;, name: &apos;loan&apos;, component: Loan }, { path: &apos;/loanList&apos;, name: &apos;loanList&apos;, component: LoanList }, { path: &apos;/doRepay/:id&apos;, // 路由动态参数 name: &apos;doRepay&apos;, component: DoRepay }, { path: &apos;*&apos;, name: &apos;Page404&apos;, component: Page404 } ] }) 3.动态路由this.$route.params对象中包含/:id传参；this.$route.query对象中包含?aid=1的query传参；若路由是同一个，但仅仅是路由的参数不同，vue则会利用原来的组件实例进行渲染而不会销毁后重新创建。因此，组件的生命周期也不会全部重新调用。若需要监听路由变化，可以有以下两种方法： // 在组件中检测$watch对象 watch: { &apos;$route&apos; (to, from) { // 对路由变化作出响应... } } // 使用beforeRouteUpdate钩子函数 beforeRouteUpdate (to, from, next) { // react to route changes... // don&apos;t forget to call next() } 路由按定义的先后顺序进行匹配，具体匹配规则与细则可参阅文档 https://github.com/pillarjs/path-to-regexp#parameters 4.嵌套路由当路由需要往下嵌套时，路由定义也十分方便： const router = new VueRouter({ routes: [ { path: &apos;/user/:id&apos;, component: User, children: [ { // 当 /user/:id时会匹配成功 path: &apos;&apos;, component: UserHome }, { // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;profile&apos;, component: UserProfile }, { // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;posts&apos;, component: UserPosts } ] } ] }) 5. 编程导航在vue实例内部，可以使用this.$router访问路由实例。路由跳转: 使用this.$router.push(url)实现同&lt;router-link :to=&quot;url&quot;&gt;点击一样的效果。push参数如下： router.push(&apos;home&apos;) // 字符串 router.push({ path: &apos;home&apos; }) // 对象 router.push({ name: &apos;user&apos;, params: { userId: &apos;123&apos; }}) // 命名的路由 router.push({ path: &apos;register&apos;, query: { plan: &apos;private&apos; }}) // 带查询参数的路由 若提供的path参数，params参数会被忽略，但query参数不会。同时，push和replace方法还存在第二个参数onComplete和第三个参数onAbort，分别代表导航成功完成和终止的时候的钩子函数。replace方法同push类似，只不过是替换当前路由而不是新添加路由。go方法同window.history.go(n)。 6. 命名视图当同一个组件或页面中有两个或者多个&lt;router-view&gt;视图需要同时不同展示时，需要使用命名视图： &lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; const router = new VueRouter({ routes: [ { path: &apos;/&apos;, components: { // 注意是components default: Foo, a: Bar, b: Baz } } ] }) 7. 重定向const router = new VueRouter({ routes: [ { path: &apos;/a&apos;, redirect: &apos;/b&apos; }, { path: &apos;/c&apos;, redirect: { name: &apos;foo&apos; } }, { path: &apos;/d&apos;, redirect: to =&gt; { // 方法接收 目标路由 作为参数 to = &apos;/d&apos; // return 重定向的 字符串路径/路径对象 } } ] }) 8. 别名当用户访问/b路由时，url显示的/b路由，但是展示的却是/a路由的内容，称/b路由是/a路由的别名。 const router = new VueRouter({ routes: [ { path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; } // 访问/a路由与/b路由一样 ] }) 9. 路由组件传参若路由的传参都需要通过$router去获取的话，导致组件就只能在某些特定的路由下使用，不利于组件的复用。故定义时，可以使用组件的props去接受路由参数。 const User = { props: [&apos;id&apos;], template: &apos;&lt;div&gt;User {{ id }}&lt;/div&gt;&apos; } const router = new VueRouter({ routes: [ { path: &apos;/user/:id&apos;, component: User, props: true }, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： { path: &apos;/user/:id&apos;, components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false } } ] }) 布尔模式：如果props被设置为true，route.params将会被设置为组件属性。对象模式：如果props是一个对象，它会被按该对象原样设置为组件属性，也就是将props对象内容传递到组件内。当props是静态的时候有用。函数模式：你可以创建一个函数返回props。 const router = new VueRouter({ routes: [ { path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; ({ query: route.query.q }) } ] }) // &quot;/search?q=vue&quot; 会将 {query: &apos;vue&apos;} 作为属性传递给 SearchUser 组件","tags":[{"name":"vue","slug":"vue","permalink":"https://naliomg.github.io/tags/vue/"}]},{"title":"Vue简介","date":"2019-08-03T00:55:55.000Z","path":"2019/08/03/vue/","text":"Vue1.通过脚手架安装npm install -g @vue/cli // 全局安装vue/cli脚手架 vue --version // 查看vue版本 vue create hello-world // 创建项目 vue ui // 以图形化界面管理项目 2.目录结构/public目录下存放的index.html为基础html，vue生成的html页面文件均是以此文件为模板基础产生的。/src目录下为项目源文件，分为assets资源文件夹、components组件文件夹、views页面文件夹、store状态管理文件夹、modules多入口文件夹，单入口时不需要。/dist目录为发布目录。 3.简介单页面单入口时，main.js为入口文件，会将vue实例挂载到#app节点上。.vue文件包含&lt;template&gt;&lt;/template&gt;、&lt;script&gt;&lt;/script&gt;、&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;。注意style样式要注明样式文件语言，template内首层节点为单节点。 4.vue.config.js文件配置简介module.exports = { publicPath: &apos;/wxapp/&apos;, // 一般为public根路径 outputDir: &apos;dist/wxapp&apos;, // build的项目存放路径 assetsDir： &apos;&apos;, // 放置生成的静态资源(js、css、img、fonts)的(相对于 outputDir 的)目录 indexPath: &apos;index.html&apos;, // 指定生成的 index.html 的输出路径 (相对于 outputDir)，也可以是一个绝对路径 pages: { // 多页面入口配置 page1: { entry: &apos;src/modules/page1/page1.js&apos;, // 应用入口配置，相当于单页面应用的main.js，必需项 template: &apos;public/index.html&apos;, // 应用的模版，相当于单页面应用的public/index.html，可选项，省略时默认与模块名一致 filename: &apos;page1.html&apos;, // 编译后在dist目录的输出文件名，可选项，省略时默认与模块名一致 title: &apos;page1标题&apos;, // 标题，可选项，一般情况不使用，通常是在路由切换时设置title；需要注意的是使用title属性template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; }, page2: {} }, // 其余项目配置详见 } 5.多入口页面多页面入口时，不仅需要配置vue.config.js文件中的pages字段，还要将多页面文件的入口文件脚本、入口vue文件分别处理，若有router路由配置的话，还应分别配置路由router文件。入口JS文件: import Vue from &apos;vue&apos; import axios from &apos;axios&apos; import VueAxios from &apos;vue-axios&apos; import store from &apos;@/store/store.js&apos; import MainLoan from &apos;./MainLoan.vue&apos; import &apos;@/assets/css/cssreset-mobile.css&apos; import &apos;we-vue/lib/style.css&apos; import WeVue from &apos;we-vue&apos; import &apos;@/assets/css/main-mobile.css&apos; import router from &apos;./router&apos; import Fastclick from &apos;fastclick&apos; Vue.config.productionTip = false Vue.use(WeVue) Vue.use(VueAxios, axios) Fastclick.attach(document.body) new Vue({ router, // 挂载路由 store, // 挂载全局状态 render: h =&gt; h(MainLoan) // 初始模板选择 }).$mount(&apos;#app&apos;) 6.vue实例&lt;script&gt;&lt;/script&gt;脚本标签内，基本类型如下： import HelloWorld from &apos;./components/HelloWorld.vue&apos; export default { name: &apos;app&apos;, // 页面或者组件名称 components: { // 本组件需要使用的下级组件声明 HelloWorld }, props: { prop1: String/Object/Number // 上级组件传递的参数 }, data() { // data数据，需要使用函数返回 return { index: 1, temp: &apos;nali&apos;, title: &apos;ttx&apos;, watchIndex: 1, } }, computed: { // 计算属性，监听值无变化时，会有计算缓存，不会重复求值 getIndex() { return this.index + 1 } }, methods: { // 内部方法定义 test() { console.log(&apos;test&apos;) } }， watch: { // 监听实例数据变动，可用于异步或开销较大的处理，一般无返回值 index(value) { this.watchIndex = this.index } }, filters: { // 过滤器，对传入的值进行包装处理 capitalize(value) { return value.toString() }, }, // 以下为生命周期回调 beforeCreate() {}, // 实例创建之前调用 created() {}, // 实例创建成功，此时 data 中的数据显示出来了 beforeMount() {}, // 数据中的 data 在模版中先占一个位置 mounted() {}, // 模版中的 data 数据直接显示出来了 beforeUpdate() {}, // 当 data 数据发生变化调用，发生在虚拟 DOM 重新渲染和打补丁之前 updated() {}, // 数据更改导致的虚拟 DOM 重新渲染和打补丁 beforeDestroy() {}, // 在 vue 实例销毁之前调用，此时实例任然可用 destroyed() {}, // 在vue实例销毁之后调用，实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 } 7.数据展示绑定模板展示内容内，通过进行绑定，如&lt;div&gt;&lt;/div&gt;；若要进行一次性插值，节点上加入v-once指令即可，次节点内数据绑定一次后将不会随data数据变化而更新。这个称为 Mustache 语法。Mustache语法不能用于HTML节点上，节点上应该使用vue指令。Mustache语法内可以使用JS表达式，且只能为单个表达式。 {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} 8.vue指令指令是带有v-前缀的特殊特性。指令后数据绑定直接使用data属性即可，不用Mustache语法。 v-bind:指令可以用于响应式地更新HTML特性：&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;，v-bind:可简写为:；v-on:用于监听 DOM 事件：&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;，v-on:可简写为@；v-if:用于条件性地渲染一块内容，&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no&lt;/h1&gt;；v-show:用于节点的显示与隐藏；v-for:用于循环渲染；v-model:用于数据双向绑定； 9.指令修饰符.修饰符半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。修饰符可以级联使用。 &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 常用修饰符：事件修饰： `.stop`: event.stopPropagation()，防止事件冒泡; `.prevent`: event.preventDefault()，防止执行预设的行为; `.capture`: 与事件冒泡的方向相反，事件捕获由外到内; `.self`: 只会触发自己范围内的事件，不包含子元素; `.once`: 只会触发一次; `.passive`: 不会等待事件回调执行完毕才继续执行下一次事件，等于事件回调时异步的。有助于提升连续触发事件的性能。 键盘修饰符： `.enter`：回车键; `.tab`：制表键; `.delete`：含delete和backspace键; `.esc`：返回键; `.space`: 空格键; `.up`：向上键; `.down`：向下键; `.left`：向左键; `.right`：向右键; 类似于`@keyup.esc`。 鼠标修饰符： `.left`：鼠标左键; `.middle`：鼠标中间滚轮; `.right`：鼠标右键; 自定义按键修饰符别名： &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt; &lt;/div&gt; Vue.config.keyCodes.f5 = 116 10.class与style绑定通过v-bind:class=指令动态地切换节点class属性。这个元素上已经存在的类不会被覆盖。 对象语法： &lt;div class=&quot;static&quot; v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;&lt;/div&gt; // vue实例中 data() { return { isActive: true, hasError: 1 } } 也可以直接使用class的对象： &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; data: { classObject: { // 此对象放于计算属性最好，可以动态结算更新 active: true, &apos;text-danger&apos;: false } } 数组语法，类似于直接将class名列出给节点： &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; data: { activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos; } // &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 内联样式绑定： &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt; data: { activeColor: &apos;red&apos;, fontSize: 30 } // 或者 &lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; data: { // 同样，计算属性更加灵活方便 styleObject: { color: &apos;red&apos;, fontSize: &apos;13px&apos; } } // 数组语法可以将多个样式对象应用到同一个元素上 &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 11.条件渲染v-if预计传值得真假判断去确定是否需要渲染html结构； &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; 当需要批量显示与隐藏多节点时，可以使用&lt;template&gt;加v-if指令进行包裹，最终渲染不会包含&lt;template&gt;节点。 &lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/template&gt; v-if对应的v-else与v-else-if指令： &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt; 另外，vue在切换渲染时，会服用已有的元素，若要表明两元素不可服用，需要在元素节点上定义不同key值： &lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt; &lt;/template&gt; v-show用于节点的显示与隐藏，仅仅变换了display值；v-show不支持&lt;template&gt;元素。 12.循环渲染v-for:循环渲染。v-for节点渲染时，节点会被不断复用，当数据顺序变更或减少时，节点不会全部重新渲染，但会就近更新节点简单数据，因此只适用于不依赖子组件状态的情况。当节点需要跟踪每个节点身份时，请使用v-bind:key为节点添加唯一标示。 &lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; {{ item.message }} &lt;/li&gt; &lt;/ul&gt; var example1 = new Vue({ el: &apos;#example-1&apos;, data: { items: [ { message: &apos;Foo&apos; }, { message: &apos;Bar&apos; } ] } }) // index为渲染索引 &lt;ul id=&quot;example-2&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; {{ parentMessage }} - {{ index }} - {{ item.message }} &lt;/li&gt; &lt;/ul&gt; var example2 = new Vue({ el: &apos;#example-2&apos;, data: { parentMessage: &apos;Parent&apos;, items: [ { message: &apos;Foo&apos; }, { message: &apos;Bar&apos; } ] } }) 也可以用of替代in作为分隔符，当使用in时，可以遍历对象属性。 &lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; {{ value }} &lt;/li&gt; &lt;/ul&gt; new Vue({ el: &apos;#v-for-object&apos;, data: { object: { title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2016-04-10&apos; } } }) // name为属性名 &lt;div v-for=&quot;(value, name) in object&quot;&gt; {{ name }}: {{ value }} &lt;/div&gt; // index为索引 &lt;div v-for=&quot;(value, name, index) in object&quot;&gt; {{ index }}. {{ name }}: {{ value }} &lt;/div&gt; 为循环节点添加唯一标示，不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值： &lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;&lt;!-- 内容 --&gt;&lt;/div&gt; v-for也可以接受整数。在这种情况下，它会把模板重复对应次数。 &lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;{{ n }} &lt;/span&gt; &lt;/div&gt; v-for指令与v-if指令同时使用时，v-for指令优先级高于v-if指令。 13.数组数据的更新检测vue数据长度隐式更新或数组被替换时，vue会触发数据更新与视图更新；如push();pop();shift();unshift();splice();sort();reverse()或数组替换方法均会触发数据更新。但当用索引更新某一个数组项或者显示地定义数组长度时，数据更新不会检测到。如arr[1] = 2; arr.length = 5;当需要使用上述方式时，可以使用以下方式变更触发视图更新： Vue.set(vm.items, indexOfItem, newValue) vm.items.splice(indexOfItem, 1, newValue) vm.$set(vm.items, indexOfItem, newValue) vm.items.splice(newLength) 同理，对象数据变更时，vue也不能检测对象属性的添加与删除。对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性，但可以通过Vue.set向对象中添加响应属性。 var vm = new Vue({ data: { userProfile: { name: &apos;Anika&apos; } } }) Vue.set(vm.userProfile, &apos;age&apos;, 27) vm.$set(vm.userProfile, &apos;age&apos;, 27) // 或直接调用通用方法 若有多个属性要一次性添加，不应该将多个属性直接添加到原对象上，而是应该创建一个新对象去替换原对象： vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: &apos;Vue Green&apos; }) 14.事件处理v-on指令监听DOM事件；若需要在内联语句处理器中访问原始的DOM事件。可以用特殊变量$event把它传入方法； &lt;button @click=&quot;test($event)&quot;&gt;&lt;/button&gt; // ... methods: { test(e) { e.stopPropagation() } } 15.表单输入绑定用v-model指令在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定。v-model会忽略表单元素的value、checked、selected的初始值。input和textarea输入时，中文、日文和韩文等输入法，没有输入完毕不会更新数据。 修饰符：.lazy：v-model在每次input事件触发后将输入框的值与数据进行同步(除了上述输入法组合文字时)。你可以添加.lazy修饰符，从而转变为使用change 事件进行同步; &lt;input v-model.lazy=&quot;msg&quot; &gt; .trim: 自动过滤用户输入的首尾空白字符; 16.组件基础对于重复性的结构，组件的使用将大大简化节点结构的书写。组件和页面类似，均有自己独立的实例与作用域。组件使用时，需要先注册才能被使用。注册分全局注册和局部注册。组件使用时，需要使用短横线分隔命名。 &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; // 使用 import HelloWorld from &apos;@/components/HelloWorld.vue&apos; // 引入 export default { name: &apos;home&apos;, inheritAttrs: false, // 组件不继承使用父组件传入的prop为定义的属性 components: { // 注册 HelloWorld } } 向子组件传递数据props // HelloWorld组件中 export default { name: &apos;HelloWorld&apos;, props: { msg: String } } 每一个组件必须只有一个根节点，多个时会报错。父组件的数据变化可以引起子组件的数据变化，但子组件内数据变化不会传递到父组件，但子组件需要通知父组件时，可以使用$emit()向父组件派发事件，当父组件由对该事件进行监听时，就会触发父组件事件，达到子组件通知父组件的效果。 // 父组件 &lt;blog-post v-on:enlarge-text=&quot;enlargeText&quot;&gt;&lt;/blog-post&gt; data() { postFontSize: 16 }, methods: { enlargeText(addition) { // 也可以用$event进行访问 this.postFontSize += addition } } // 子组件 &lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;, 0.1)&quot;&gt; Enlarge text &lt;/button&gt; 当在组件上使用v-model进行值绑定时，等价于： &lt;input v-model=&quot;searchText&quot;&gt; &lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; // value和input必须绑定才有效果 &lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt; Vue.component(&apos;custom-input&apos;, { props: [&apos;value&apos;], // 组件的props必须包含value template: &apos;&lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;&gt; // 事件需通过input传出 }) 组件的prop可以是数组，可以是对象集。当使用对象集时，可以指定各个属性的接受值类型。任何类型的值都可以传递给prop。 props: [&apos;title&apos;, &apos;likes&apos;, &apos;isPublished&apos;, &apos;commentIds&apos;, &apos;author&apos;] props: { title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor } Vue.component(&apos;my-component&apos;, { props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number, Date, Symbol], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: &apos;hello&apos; } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 } } } }) 若需要向prop传入一个对象的所有属性，可使用不带参数的v-bind： post: { id: 1, title: &apos;My Journey with Vue&apos; } &lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt; // 等价于 &lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 注意组件的数据传递请遵守单项数据原则，由父组件去改变传递的数据值，子组件不应该改变传递的值，若有需要，请使用子组件事件派发通知父组件改变。 组件的prop接收到未定义的属性时，未定义的属性会直接添加到组件的根节点上。另外，父节点传入的属性一般会覆盖子组件的同名属性，但class与style会并存叠加。 17.自定义事件自定义事件的事件名不会用作一个JS变量名或者属性名，所有没有必要使用驼峰结构，且v-on事件监听时，会自动转换为小写，故推荐使用-分隔的命名方式。 18.插槽自定义的组件中，可以使用模板代码或html结构对组件进行合成，可以理解为prop接收的是JS数据，而插槽接收的是html结构。如果组件内没有包含&lt;slot&gt;元素，则组件标签内所有内容均会被舍弃。 &lt;navigation-link url=&quot;/profile&quot;&gt;Your Profile&lt;/navigation-link&gt; // 模板 &lt;a v-bind:href=&quot;url&quot; class=&quot;nav-link&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; // 渲染为 &lt;a v-bind:href=&quot;/profile&quot; class=&quot;nav-link&quot;&gt;Your Profile&lt;/a&gt; 卡槽的作用域与组件的作用域一致，父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 预置内容：当一个组件中有&lt;slot&gt;结构但是父组件使用该组件时，没有传递slot值，则会展示出默认的预置内容。 &lt;button type=&quot;submit&quot;&gt;&lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; // 使用 &lt;submit-button&gt;&lt;/submit-button&gt; // 渲染 &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; // 使用 &lt;submit-button&gt;save&lt;/submit-button&gt; // 渲染 &lt;button type=&quot;submit&quot;&gt;save&lt;/button&gt; 具名插槽：&lt;slot&gt;插槽带有name属性值，可以让父组件在使用时，传递特定的内容到指定的位置。&lt;slot&gt;属性在不设置name属性时，默认name属性值为default。父组件中任何没有被包裹在带有v-slot的&lt;template&gt;中的内容均会被视为默认&lt;slot&gt;的内容。注意v-slot指令只能用于&lt;template&gt;节点上，除非组件只有默认插槽，不过这时候有无v-slot已经不重要了。 &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; // 使用 &lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/template&gt; &lt;/base-layout&gt; // 渲染 &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 作用域插槽：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译；若需要向卡槽中传递数据，则可以使用插槽prop。在&lt;slot&gt;上绑定具名属性值，在父组件中给v-slot带一个值来定义我们提供的插槽prop的名字。 &lt;span&gt;&lt;slot v-bind:user=&quot;user&quot;&gt;{{ user.lastName }}&lt;/slot&gt;&lt;/span&gt; &lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; {{ slotProps.user.firstName }} &lt;/template&gt; &lt;/current-user&gt; 19.动态组件当组件通过is属性进行动态切换时，不能组件之间会进行不断的销毁与创建。若需要将组件销毁前的状态保存下来，可以使用&lt;keep-alive&gt;元素进行包裹。当使用&lt;keep-alive&gt;时，内部组件必须要有唯一名字，否则无效。 &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; &lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; 20.边界情况访问根实例：在每个new Vue实例的子组件中，其根实例可以通过$root属性进行访问。 new Vue({ data: { foo: 1 }, computed: { bar: function () { /* ... */ } }, methods: { baz: function () { /* ... */ } } }) // 子组件中，可以把根vue实例作为一个简单的全局store来使用：如下 this.$root.foo this.$root.foo = 2 this.$root.bar this.$root.baz() 访问父组件实例：$parent属性可以用来从一个子组件访问父组件的实例。与$root类似，但不建议使用。 访问子组件实例或者子元素：可以在子组件或者节点上添加ref属性赋予一个标记ID，然后通过$refs访问这个组件或者元素。注意$refs属性只在定义ref的组件实例内有效。同样地，ref也应尽量减少使用。 // base-input组件 &lt;input ref=&quot;input&quot;&gt; // 使用base-input组件 &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt; methods: { // 用来从父级组件聚焦输入框 focus: function () { this.$refs.input.focus() } } 21.进入离开过渡动画单元素/组件的过渡:使用&lt;transition name=&quot;actionName&quot;&gt;&lt;/transition&gt;包裹。若过渡没有检测到CSS动画定义，也没有检测到钩子函数，则节点的显示与隐藏将会在下一帧（显示动画帧update）执行 &lt;div id=&quot;demo&quot;&gt; &lt;button v-on:click=&quot;show = !show&quot;&gt; Toggle &lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt; new Vue({ el: &apos;#demo&apos;, data: { show: true } }) .fade-enter-active, .fade-leave-active { // 动画执行时样式 transition: opacity .5s; } .fade-enter, .fade-leave-to { // 渐入状态和渐出状态 opacity: 0; } 过渡类名:v-enter: 元素被插入之前状态，插入之后下一帧移除；v-enter-active: 元素被插入的前一帧生效，进入动画执行时间内有效，动画完成后移除；v-enter-to: 元素被插入后的下一帧生效，动画完成后移除；有点类似于enter-active，但生效时间晚3帧；v-leave: 元素离开动画触发那一帧生效，下一帧移除；v-leave-active: 元素离开动画触发那一帧生效，离开动画执行时间内有效，动画完成后移除；v-leave-to: 元素离开动画触发下一帧生效，离开动画执行时间内有效，动画完成后移除； 自定义过渡类名：用enter-class、enter-active-class、enter-to-class、leave-class、leave-active-class、leave-to-class自定义动画类名，他们的优先级高于普通类名。用于vue过渡动画和第三方库结合较好。 &lt;transition name=&quot;custom-classes-transition&quot; enter-active-class=&quot;animated tada&quot; leave-active-class=&quot;animated bounceOutRight&quot; &gt; &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt; &lt;/transition&gt; 多元素多节点动画：&lt;transition-group&gt;&lt;/transition-group&gt; 22.混入类似于对象继承的一个东西，组件在实例化之前将预先设定或者公共的属性添加到实例化对象上。当有许多组件有公共的部分的时候使用起来就比较方便。data对象会如下方式合并： // 混入对象 var mixin = { data: function () { return { message: &apos;hello&apos;, foo: &apos;abc&apos; } } } // 组件使用 new Vue({ mixins: [mixin], data: function () { return { message: &apos;goodbye&apos;, bar: &apos;def&apos; } }, created: function () { console.log(this.$data) // =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; } } }) 混入对象会依次优先被复制到组件上，组件定义的内容会最后复制到组件上，产生自定义修改效果。另外：同名的钩子函数将会被合并为一个数组，同名钩子函数会依次执行。其实可以将钩子函数看做一个订阅事件，当此事件被多次订阅后，肯定也会多次执行。 var mixin = { created: function () { console.log(&apos;混入对象的钩子被调用&apos;) } } new Vue({ mixins: [mixin], created: function () { console.log(&apos;组件钩子被调用&apos;) } }) // =&gt; &quot;混入对象的钩子被调用&quot; // =&gt; &quot;组件钩子被调用&quot; 值为对象的选项，例如methods、components和directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。与data合并方式类似。Vue.extend()也是如此。 var mixin = { methods: { foo: function () { console.log(&apos;foo&apos;) }, conflicting: function () { console.log(&apos;from mixin&apos;) } } } var vm = new Vue({ mixins: [mixin], methods: { bar: function () { console.log(&apos;bar&apos;) }, conflicting: function () { console.log(&apos;from self&apos;) } } }) vm.foo() // =&gt; &quot;foo&quot; vm.bar() // =&gt; &quot;bar&quot; vm.conflicting() // =&gt; &quot;from self&quot; 全局混入：我们可以使用Vue.mixin({})进行全局混入，当使用全局混入时，以后使用的每一个vue实例都会受到此影响(包括第三方组件)，所有不建议使用。 23.自定义指令全局定义时，可以使用Vue.directive(&#39;directive-name&#39;, {})进行定义；当然也可以在组件内使用局部定义directives属性。 // 注册一个全局自定义指令 `v-focus` Vue.directive(&apos;focus&apos;, { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) // 局部定义 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 定义时，需要定义指令的触发时间，也就是指令的钩子函数：bind: 只调用一次，指令第一次绑定到元素时调用。insert: 被绑定元素插入父节点时调用(仅保证父节点存在，但不一定已被插入文档中)。update: 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。componentUpdated: 指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind: 只调用一次，指令与元素解绑时调用。 钩子函数的参数请参考vue文档。","tags":[{"name":"vue","slug":"vue","permalink":"https://naliomg.github.io/tags/vue/"}]},{"title":"移动端HTML适配","date":"2019-02-02T13:40:52.000Z","path":"2019/02/02/移动端HTML适配/","text":"移动端HTML适配&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;App-Config&quot; content=&quot;fullscreen=yes,useHistoryState=yes,transition=yes&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;PUBSRC/favicon.ico&quot;&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;style&gt; #indexPage .newsWrap{ padding: 105px 0 90px; } &lt;/style&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 移动端适配脚本// 淘宝适配方案 (function flexible(window, document) { var docEl = document.documentElement var dpr = window.devicePixelRatio || 1 // adjust body font size function setBodyFontSize() { if (document.body) { document.body.style.fontSize = 16 + &apos;px&apos; } else { document.addEventListener(&apos;DOMContentLoaded&apos;, setBodyFontSize) } } setBodyFontSize(); // set 1rem = viewWidth / 10 function setRemUnit() { var rem = docEl.clientWidth / 3.75 docEl.style.fontSize = rem + &apos;px&apos; } setRemUnit() // reset rem unit on page resize window.addEventListener(&apos;resize&apos;, setRemUnit) window.addEventListener(&apos;pageshow&apos;, function(e) { if (e.persisted) { setRemUnit() } }) // detect 0.5px supports if (dpr &gt;= 2) { var fakeBody = document.createElement(&apos;body&apos;) var testElement = document.createElement(&apos;div&apos;) testElement.style.border = &apos;.5px solid transparent&apos; fakeBody.appendChild(testElement) docEl.appendChild(fakeBody) if (testElement.offsetHeight === 1) { docEl.classList.add(&apos;hairlines&apos;) } docEl.removeChild(fakeBody) } }(window, document))","tags":[{"name":"html","slug":"html","permalink":"https://naliomg.github.io/tags/html/"}]},{"title":"JS常用工具函数","date":"2019-02-01T13:40:52.000Z","path":"2019/02/01/js工具函数/","text":"JS常用工具函数1.isArray：判断数据是不是数组类型的数据function isArray(arr) { return Object.prototype.toString.call(arr) === &apos;[object Array]&apos; } Array.isArray = Array.isArray || isArray // 将isArray挂载到Array上 2.isFunction：检查 value 是不是函数function isFunction(value) { return Object.prototype.toString.call(value) === &apos;[object Function]&apos; } 3.capitalize：字符串首位大写function capitalize(str){ return str.charAt(0).toUpperCase() + str.slice(1) } 4.extend：将属性混合到目标对象中function extend(to, _from) { for(let key in _from) { to[key] = _from[key]; } return to } 5.识别各种浏览器及平台// 运行环境是浏览器 let inBrowser = typeof window !== &apos;undefined&apos;; // 运行环境是微信 let inWeex = typeof WXEnvironment !== &apos;undefined&apos; &amp;&amp; !!WXEnvironment.platform; let weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase(); // 浏览器 UA 判断 let UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase(); let isIE = UA &amp;&amp; /msie|trident/.test(UA); let isIE9 = UA &amp;&amp; UA.indexOf(&apos;msie 9.0&apos;) &gt; 0; let isEdge = UA &amp;&amp; UA.indexOf(&apos;edge/&apos;) &gt; 0; let isAndroid = (UA &amp;&amp; UA.indexOf(&apos;android&apos;) &gt; 0) || (weexPlatform === &apos;android&apos;); let isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === &apos;ios&apos;); let isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge; 6.getExplorerInfo：获取浏览器信息function getExplorerInfo() { let t = navigator.userAgent.toLowerCase(); return 0 &lt;= t.indexOf(&quot;msie&quot;) ? { //ie &lt; 11 type: &quot;IE&quot;, version: Number(t.match(/msie ([\\d]+)/)[1]) } : !!t.match(/trident\\/.+?rv:(([\\d.]+))/) ? { // ie 11 type: &quot;IE&quot;, version: 11 } : 0 &lt;= t.indexOf(&quot;edge&quot;) ? { type: &quot;Edge&quot;, version: Number(t.match(/edge\\/([\\d]+)/)[1]) } : 0 &lt;= t.indexOf(&quot;firefox&quot;) ? { type: &quot;Firefox&quot;, version: Number(t.match(/firefox\\/([\\d]+)/)[1]) } : 0 &lt;= t.indexOf(&quot;chrome&quot;) ? { type: &quot;Chrome&quot;, version: Number(t.match(/chrome\\/([\\d]+)/)[1]) } : 0 &lt;= t.indexOf(&quot;opera&quot;) ? { type: &quot;Opera&quot;, version: Number(t.match(/opera.([\\d]+)/)[1]) } : 0 &lt;= t.indexOf(&quot;Safari&quot;) ? { type: &quot;Safari&quot;, version: Number(t.match(/version\\/([\\d]+)/)[1]) } : { type: t, version: -1 } } 7.isPCBroswer：检测是否为PC端浏览器模式function isPCBroswer() { let e = navigator.userAgent.toLowerCase() , t = &quot;ipad&quot; == e.match(/ipad/i) , i = &quot;iphone&quot; == e.match(/iphone/i) , r = &quot;midp&quot; == e.match(/midp/i) , n = &quot;rv:1.2.3.4&quot; == e.match(/rv:1.2.3.4/i) , a = &quot;ucweb&quot; == e.match(/ucweb/i) , o = &quot;android&quot; == e.match(/android/i) , s = &quot;windows ce&quot; == e.match(/windows ce/i) , l = &quot;windows mobile&quot; == e.match(/windows mobile/i); return !(t || i || r || n || a || o || s || l) } 8.dateFormater：格式化时间function dateFormater(formater, t){ let date = t ? new Date(t) : new Date(), Y = date.getFullYear() + &apos;&apos;, M = date.getMonth() + 1, D = date.getDate(), H = date.getHours(), m = date.getMinutes(), s = date.getSeconds(); return formater.replace(/YYYY|yyyy/g,Y) .replace(/YY|yy/g,Y.substr(2,2)) .replace(/MM/g,(M&lt;10?&apos;0&apos;:&apos;&apos;) + M) .replace(/DD/g,(D&lt;10?&apos;0&apos;:&apos;&apos;) + D) .replace(/HH|hh/g,(H&lt;10?&apos;0&apos;:&apos;&apos;) + H) .replace(/mm/g,(m&lt;10?&apos;0&apos;:&apos;&apos;) + m) .replace(/ss/g,(s&lt;10?&apos;0&apos;:&apos;&apos;) + s) } // dateFormater(&apos;YYYY-MM-DD HH:mm&apos;, t) ==&gt; 2019-06-26 18:30 // dateFormater(&apos;YYYYMMDDHHmm&apos;, t) ==&gt; 201906261830 9.dateStrForma：将指定字符串由一种时间格式转化为另一种function dateStrForma(str, from, to){ //&apos;20190626&apos; &apos;YYYYMMDD&apos; &apos;YYYY年MM月DD日&apos; str += &apos;&apos; let Y = &apos;&apos; if(~(Y = from.indexOf(&apos;YYYY&apos;))){ Y = str.substr(Y, 4) to = to.replace(/YYYY|yyyy/g,Y) }else if(~(Y = from.indexOf(&apos;YY&apos;))){ Y = str.substr(Y, 2) to = to.replace(/YY|yy/g,Y) } let k,i [&apos;M&apos;,&apos;D&apos;,&apos;H&apos;,&apos;h&apos;,&apos;m&apos;,&apos;s&apos;].forEach(s =&gt;{ i = from.indexOf(s+s) k = ~i ? str.substr(i, 2) : &apos;&apos; to = to.replace(s+s, k) }) return to } // dateStrForma(&apos;20190626&apos;, &apos;YYYYMMDD&apos;, &apos;YYYY年MM月DD日&apos;) ==&gt; 2019年06月26日 // dateStrForma(&apos;121220190626&apos;, &apos;----YYYYMMDD&apos;, &apos;YYYY年MM月DD日&apos;) ==&gt; 2019年06月26日 // dateStrForma(&apos;2019年06月26日&apos;, &apos;YYYY年MM月DD日&apos;, &apos;YYYYMMDD&apos;) ==&gt; 20190626 // 一般的也可以使用正则来实现 // &apos;2019年06月26日&apos;.replace(/(\\d{4})年(\\d{2})月(\\d{2})日/, &apos;$1-$2-$3&apos;) ==&gt; 2019-06-26 10.GetUrlParam：获取Url参数，返回一个对象function GetUrlParam(){ let url = document.location.toString(); let arrObj = url.split(&quot;?&quot;); let params = Object.create(null) if (arrObj.length &gt; 1){ arrObj = arrObj[1].split(&quot;&amp;&quot;); arrObj.forEach(item=&gt;{ item = item.split(&quot;=&quot;); params[item[0]] = item[1] }) } return params; } // ?a=1&amp;b=2&amp;c=3 ==&gt; {a: &quot;1&quot;, b: &quot;2&quot;, c: &quot;3&quot;} 11.toFullScreen：全屏function toFullScreen(){ let elem = document.body; elem.webkitRequestFullScreen ? elem.webkitRequestFullScreen() : elem.mozRequestFullScreen ? elem.mozRequestFullScreen() : elem.msRequestFullscreen ? elem.msRequestFullscreen() : elem.requestFullScreen ? elem.requestFullScreen() : alert(&quot;浏览器不支持全屏&quot;); } 12.exitFullscreen：退出全屏function exitFullscreen(){ let elem = parent.document; elem.webkitCancelFullScreen ? elem.webkitCancelFullScreen() : elem.mozCancelFullScreen ? elem.mozCancelFullScreen() : elem.cancelFullScreen ? elem.cancelFullScreen() : elem.msExitFullscreen ? elem.msExitFullscreen() : elem.exitFullscreen ? elem.exitFullscreen() : alert(&quot;切换失败,可尝试Esc退出&quot;); } 13._isNaN：检查数据是否是非数字值function _isNaN(v){ return !(typeof v === &apos;string&apos; || typeof v === &apos;number&apos;) || isNaN(v) } 14.max：求取数组中非NaN数据中的最大值function max(arr){ arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.max.apply(null, arr) : undefined } // max([1, 2, &apos;11&apos;, null, &apos;fdf&apos;, []]) ==&gt; 11 15.min：求取数组中非NaN数据中的最小值function min(arr){ arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.min.apply(null, arr) : undefined } // min([1, 2, &apos;11&apos;, null, &apos;fdf&apos;, []]) ==&gt; 1 16.random：返回一个lower-upper之间的随机数，包含lowerfunction random(lower, upper){ lower = +lower || 0 upper = +upper || 0 return Math.random() * (upper - lower) + lower // 不包含upper return Math.random() * (upper - lower + 1) + lower // 包含upper return Math.floor(Math.random() * (upper - lower)) + lower // 整数 return Math.floor(Math.random() * (upper - lower + 1)) + lower // 整数 } // random(0, 0.5) ==&gt; 0.3567039135734613 // random(2, 1) ===&gt; 1.6718418553475423 // random(-2, -1) ==&gt; -1.4474325452361945","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"css-reset","date":"2019-02-01T13:40:52.000Z","path":"2019/02/01/css-reset/","text":"css-reset移动端/********** * cssreset for mobile *********/ * { box-sizing: border-box; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } body, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, legend, input, textarea, p, blockquote, th, td, hr, button, article, aside, details, figcaption, figure, footer, header, menu, nav, section { margin: 0; padding: 0; border: 0; } /* 默认不要下划线 */ a { text-decoration: none; } /* 按钮文本不可选 */ button { user-select: none; } img { display: inline-block; vertical-align: middle; } /* 加载不出来的图片不要显示灰色边框 */ img:not([src]), img[src=&quot;&quot;] { opacity: 0; } ul, ol { list-style: none; } table { border-collapse: collapse; border-spacing: 0; } input, select, button, textarea { font-size: 100%; font: inherit; } html, body { height: 100%; overflow-x: hidden; } .clearfix:after, .clearfix:before { /*清除浮动*/ content: &quot; &quot;; display: table; } .clearfix:after { clear: both; } .fl { float: left; } .fr { float: right; } *, *:before, *:after { box-sizing: border-box; /*所有元素以border开始计算盒子大小*/ } .justify-between { -webkit-box-pack: justify; -webkit-justify-content: space-between; -ms-flex-pack: justify; justify-content: space-between; } .justify-center { -webkit-box-pack: center; -webkit-justify-content: center; -ms-flex-pack: center; justify-content: center; } .vertical { -webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; } button { border: none; } /*input*/ button, html input[type=&apos;button&apos;], input[type=&apos;reset&apos;], input[type=&apos;submit&apos;] { -webkit-appearance: button; /*渲染成button的风格*/ text-transform: none; outline: none; } input::-webkit-input-placeholder, textarea::-webkit-input-placeholder { color: #999; /*输入框提示语的字体样式*/ } input::-webkit-inner-spin-button { /*解决input的type=&quot;number&quot;在部分手机端会出现一个小按钮*/ -webkit-appearance: none; /*去除系统默认appearance的样式,常用于IOS下移除原生样式*/ } input::-webkit-outer-spin-button { /*解决input的type=&quot;number&quot;在部分手机端会出现一个小按钮*/ -webkit-appearance: none; } textarea { vertical-align: top; } button, input { line-height: normal; } select { margin: 0; outline: 0; } input.fixAKeyboard:focus, textarea.fixAndroidKeyboard:focus { -webkit-tap-highlight-color: rgba(255, 255, 255, 0); -webkit-user-modify: read-write-plaintext-only; } input:-webkit-autofill { -webkit-box-shadow: 0 0 0 1000px white inset !important; } button, input[type=button], input[type=checkbox], input[type=reset], input[type=submit], label { cursor: pointer; user-select: none; -ms-user-select: none; -moz-user-select: none; -webkit-user-select: none; } input[type=submit] { -webkit-user-modify: read-plaintext-only; -moz-user-modify: read-plaintext-only; -ms-user-modify: read-plaintext-only; -o-user-modify: read-plaintext-only; user-modify: read-plaintext-only; } input[type=&apos;search&apos;]::-webkit-search-cancel-button, input[type=&apos;search&apos;]::-webkit-search-decoration { -webkit-appearance: none; } input[type=&apos;search&apos;] { -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; -webkit-appearance: textfield; } PC端html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } img { display: inline-block; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: &apos;&apos;; content: none; } table { border-collapse: collapse; border-spacing: 0; } .clearfix { zoom: 1; } .clearfix::before, .clearfix::after { content: &quot;&quot;; display: block; clear: both; visibility: hidden; } .fl { float: left; } .fr { float: right; }","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"Koa2使用简介","date":"2019-01-05T04:33:44.000Z","path":"2019/01/05/koa/","text":"Koa2使用简介1.安装npm install koa 2.简单使用const Koa = require(&apos;koa&apos;) const app = new Koa() app.use(ctx =&gt; { ctx.body = &apos;ttx&apos; }) app.listen(3000) 网络请求访问时，就会响应”ttx”。当然koa2也支持异步函数输入： app.use(async ctx =&gt; { await delay(3000) ctx.body = &apos;ttx&apos; })) 3.中间件使用链app.use(async (ctx, next) =&gt; { await next() console.log(&apos;ttx&apos;) }) app.use(async (ctx, next) =&gt; { console.log(&apos;jss&apos;) }) app.use(async (ctx, next) =&gt; { console.log(&apos;nali&apos;) }) 请求触发时依次输出jss、ttx，形成中间件处理链，截止在没有使用next将中间件调用权转出的中间件。 4.路由模块express内置了router路由模块，但koa需要自行添加；koa的app.use()不能直接像express一样进行路由区分。 // app.js const Koa = require(&apos;koa&apos;) const bodyParser = require(&apos;koa-bodyparser&apos;) // 处理post请求，上下文的表单数据解析到ctx.request.body中 const router = require(&apos;koa-router&apos;)() const page1Router = require(&apos;./routes/page1.js) const app = new Koa() app.use(bodyParser()) router.use(&apos;/page1&apos;, page1Router) // 注意起始的/是必须的 app.use(router.routes()) // 路由挂载 app.listen(3000) // page1.js const router = require(&apos;koa-router&apos;)() const page2Router = require(&apos;./page2.js&apos;) router.get(&apos;/&apos;, async (ctx, next) =&gt; { ctx.body = &apos;page1&apos; }) router.use(&apos;/page2&apos;, page2Router) module.exports = router.routes() // page2.js const router = require(&apos;koa-router&apos;)() router.get(&apos;/&apos;, async (ctx, next) =&gt; { ctx.body = &apos;page2&apos; }) module.exports = router.routes() 上述是模块化的样式及路由嵌套的使用。 5.模板引擎模块// app.js // ... const views = require(&apos;koa-views&apos;) // view中间件 const path = require(&apos;path&apos;) // 路径处理中间件 const router = require(&apos;koa-router&apos;)() const app = new Koa() app.use(views(path.join(__dirname, &apos;./views&apos;), { extension: &apos;ejs&apos; })) router.get(&apos;/page1&apos;, async (ctx, next) =&gt; { await ctx.render(&apos;page1&apos;, {name: &apos;ttx&apos;}) // 注意await是需要的 }) // ... 6.快速构建项目npm install koa-generator -g koa2 myProject 7.小计总的来说，koa和express大同小异，koa精简了许多内置中间件，可以使用async/await进行异步书写，更方便；但koa中间件少，很多需要的配置都要自己去写一遍，项目构建时相对麻烦。 THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"TypeScript小记(1)","date":"2018-10-01T00:55:55.000Z","path":"2018/10/01/TypeScript小计(1)/","text":"TypeScript小计(1)1. 基本简介2. 安装npm install typescript -g tsc index.ts sublime有ts高亮及自动编译插件 https://blog.csdn.net/u012510478/article/details/54930554 参考 https://ts.xcatliu.com/ ts数据类型 布尔值: boolean、数值: number、字符串: string、null: void、undefined: void、数组: array、元祖: tuple、枚举: enum","tags":[{"name":"ts","slug":"ts","permalink":"https://naliomg.github.io/tags/ts/"}]},{"title":"kue任务队列使用","date":"2018-03-22T13:58:54.000Z","path":"2018/03/22/kue任务队列使用/","text":"kue任务队列使用kue三方库用于构建node的任务队列非常方便有效。注意kue是基于redis的，kue的队列将会存储于redis中，避免了主进程中的node内存的分配与阻塞。 // 安装 npm install kue --save var kue = require(&apos;kue&apos;) var cluster = require(&apos;cluster&apos;) var config = require(&apos;../configs/configs&apos;) var queues = kue.createQueue({ prefix: &apos;q&apos;, redis: { port: config.REDIS_PORT, host: config.REDIS_HOST, auth: config.REDIS_PASSWORD, db: 15 } }) function createJob() { // 注意创建的任务名不要为&apos;test&apos;，不然任务执行会有问题，此处有坑！ let job = queues.create(&quot;jobName&quot;, { data: &apos;test&apos; }) .attempts(5) .backoff(true) .save(function(err) { if(err) { console.log(err) return } console.log(&apos;创建任务&apos; + job.id + &apos;成功!&apos;) }); setTimeout(createJob, 0); } if (cluster.isMaster) { console.log(&quot;主线程 %s 工作!创建任务！&quot;, process.pid) for (let i = 0; i &lt; 4; i++) { cluster.fork(); } createJob(); cluster.on(&apos;exit&apos;, function (worker, code) { console.log(&quot;worker线程 %s is died by %s&quot;, worker.process.pid, code); }); } else { queues.process(&apos;jobName&apos;, (job, done)=&gt; { console.log(&quot;worker线程 %s 处理 job[%d][%s]&quot;, process.pid, job.id, job.data.name); setTimeout(done, 0); }); } THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"redis-cli指令","date":"2018-03-22T13:35:43.000Z","path":"2018/03/22/redis-cli指令/","text":"redis-cli 常用指令redis cli命令 redis安装后，在src和/usr/local/bin下有几个以redis开头的可执行文件，称为redis shell，这些可执行文件可做很多事情。 可执行文件作用 redis-server 启动redis redis-cli redis命令行工具 redis-benchmark 基准测试工具 redis-check-aof AOF持久化文件检测工具和修复工具 redis-check-dump RDB持久化文件检测工具和修复工具 redis-sentinel 启动redis-sentinel 本文重点介绍的redis-cli命令。 可以使用两种方式连接redis服务器。 第一种：交互式方式 redis-cli -h {host} -p {port}方式连接，然后所有的操作都是在交互的方式实现，不需要再执行redis-cli了。 $redis-cli -h 127.0.0.1-p 6379 127.0.0.1：6379>set hello world OK 127.0.0.1：6379>get hello \"world\" 第二种方式：命令方式 redis-cli -h {host} -p {port} {command}直接得到命令的返回结果。 $redis-cli -h 127.0.0.1-p 6379 get hello \"world\" redis-cli包含很多参数，如-h，-p，要了解全部参数，可用redis-cli -help命令。 第一部分 命令方式介绍一些重要参数以及使用场景。 1、-r 代表将命令重复执行多次 $redis-cli -r 3 ping PONG PONG PONG ping 命令可用于检测redis实例是否存活，如果存活则显示PONG。 2、-i 每隔几秒(如果想用ms，如10ms则写0.01)执行一次命令，必须与-r一起使用。 $redis-cli -r 3 -i 1 ping PONG PONG PONG $redis-cli -r 10 -i 1 info|grep used_memory_human used_memory_human:2.95G ..................................... used_memory_human:2.95G 每隔1秒输出内存的使用量，一共输出10次。 $redis-cli -h ip -p port info server|grep process_id process_id:999 获取redis的进程号999 3、-x 代表从标准输入读取数据作为该命令的最后一个参数。 $echo \"world\" |redis-cli -x set hello Ok 4、-c 连接集群结点时使用，此选项可防止moved和ask异常。 5、-a 如配置了密码，可用a选项。 6、--scan 和 --pattern 用于扫描指定模式的键，相当于scan命令。 7、--slave 当当前客户端模拟成当前redis节点的从节点，可用来获取当前redis节点的更新操作。合理利用可用于记录当前连接redis节点的一些更新操作，这些更新可能是实开发业务时需要的数据。 8、--rdb 会请求redis实例生成并发送RDB持久化文件，保存在本地。可做定期备份。 9、--pipe 将命令封装成redis通信协议定义的数据格式，批量发送给redis执行。 10、--bigkeys 统计bigkey的分布，使用scan命令对redis的键进行采样，从中找到内存占用比较大的键，这些键可能是系统的瓶颈。 11、--eval 用于执行lua脚本 12、--latency 有三个选项，--latency、--latency-history、--latency-dist。它们可检测网络延迟，展现的形式不同。 13、--stat 可实时获取redis的重要统计信息。info命令虽然比较全，但这里可看到一些增加的数据，如requests（每秒请求数） 14、--raw 和 --no-raw: --no-raw 要求返回原始格式。--raw 显示格式化的效果。 第二部分redis-cli 命令有很多。比如 连接操作相关的命令 默认直接连接 远程连接-h 192.168.1.20 -p 6379 ping：测试连接是否存活如果正常会返回pong echo：打印 select：切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值 quit：关闭连接（connection） auth：简单密码认证 服务端相关命令 time：返回当前服务器时间 client list: 返回所有连接到服务器的客户端信息和统计数据 参见http://redisdoc.com/server/client_list.html client kill ip:port：关闭地址为 ip:port 的客户端 save：将数据同步保存到磁盘 bgsave：将数据异步保存到磁盘 lastsave：返回上次成功将数据保存到磁盘的Unix时戳 shundown：将数据同步保存到磁盘，然后关闭服务 info：提供服务器的信息和统计 config resetstat：重置info命令中的某些统计数据 config get：获取配置文件信息 config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出 config rewrite：Redis 服务器时所指定的 redis.conf 文件进行改写 monitor：实时转储收到的请求 slaveof：改变复制策略设置 发布订阅相关命令 psubscribe：订阅一个或多个符合给定模式的频道 例如psubscribe news.* tweet.* publish：将信息 message 发送到指定的频道 channel 例如publish msg \"good morning\" pubsub channels：列出当前的活跃频道 例如PUBSUB CHANNELS news.i* pubsub numsub：返回给定频道的订阅者数量 例如PUBSUB NUMSUB news.it news.internet news.sport news.music pubsub numpat：返回客户端订阅的所有模式的数量总和 punsubscribe：指示客户端退订所有给定模式。 subscribe：订阅给定的一个或多个频道的信息。例如 subscribe msg chat_room unsubscribe：指示客户端退订给定的频道。 对KEY操作的命令 exists(key)：确认一个key是否存在 del(key)：删除一个key type(key)：返回值的类型 keys(pattern)：返回满足给定pattern的所有key randomkey：随机返回key空间的一个 keyrename(oldname, newname)：重命名key dbsize：返回当前数据库中key的数目 expire：设定一个key的活动时间（s） ttl：获得一个key的活动时间 move(key, dbindex)：移动当前数据库中的key到dbindex数据库 flushdb：删除当前选择数据库中的所有key flushall：删除所有数据库中的所有key 对String操作的命令 set(key, value)：给数据库中名称为key的string赋予值value get(key)：返回数据库中名称为key的string的value getset(key, value)：给名称为key的string赋予上一次的value mget(key1, key2,…, key N)：返回库中多个string的value setnx(key, value)：添加string，名称为key，值为value setex(key, time, value)：向库中添加string，设定过期时间time mset(key N, value N)：批量设置多个string的值 msetnx(key N, value N)：如果所有名称为key i的string都不存在 incr(key)：名称为key的string增1操作 incrby(key, integer)：名称为key的string增加integer decr(key)：名称为key的string减1操作 decrby(key, integer)：名称为key的string减少integer append(key, value)：名称为key的string的值附加value substr(key, start, end)：返回名称为key的string的value的子串 对List操作的命令 rpush(key, value)：在名称为key的list尾添加一个值为value的元素 lpush(key, value)：在名称为key的list头添加一个值为value的 元素 llen(key)：返回名称为key的list的长度 lrange(key, start, end)：返回名称为key的list中start至end之间的元素 ltrim(key, start, end)：截取名称为key的list lindex(key, index)：返回名称为key的list中index位置的元素 lset(key, index, value)：给名称为key的list中index位置的元素赋值 lrem(key, count, value)：删除count个key的list中值为value的元素 lpop(key)：返回并删除名称为key的list中的首元素 rpop(key)：返回并删除名称为key的list中的尾元素 blpop(key1, key2,… key N, timeout)：lpop命令的block版本。 brpop(key1, key2,… key N, timeout)：rpop的block版本。 rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 对Set操作的命令 sadd(key, member)：向名称为key的set中添加元素member srem(key, member) ：删除名称为key的set中的元素member spop(key) ：随机返回并删除名称为key的set中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为key的set的基数 sismember(key, member) ：member是否是名称为key的set的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合 sdiff(key1, (keys)) ：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合 smembers(key) ：返回名称为key的set的所有元素 srandmember(key) ：随机返回名称为key的set的一个元素 对Hash操作的命令 hset(key, field, value)：向名称为key的hash中添加元素field hget(key, field)：返回名称为key的hash中field对应的value hmget(key, (fields))：返回名称为key的hash中field i对应的value hmset(key, (fields))：向名称为key的hash中添加元素field hincrby(key, field, integer)：将名称为key的hash中field的value增加integer hexists(key, field)：名称为key的hash中是否存在键为field的域 hdel(key, field)：删除名称为key的hash中键为field的域 hlen(key)：返回名称为key的hash中元素个数 hkeys(key)：返回名称为key的hash中所有键 hvals(key)：返回名称为key的hash中所有键对应的value hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value 实例 query在线分析 redis-cli MONITOR | head -n 5000 | ./redis-faina.py 监控正在请求执行的命令 在cli下执行monitor，生产环境慎用。 模拟oom redis-cli debug oom 模拟宕机 redis-cli debug segfault 模拟hang redis-cli -p 6379 DEBUG sleep 30 获取慢查询 SLOWLOG GET 10 结果为查询ID、发生时间、运行时长和原命令 默认10毫秒，默认只保留最后的128条。单线程的模型下，一个请求占掉10毫秒是件大事情，注意设置和显示的单位为微秒，注意这个时间是不包含网络延迟的。 slowlog get 获取慢查询日志 slowlog len 获取慢查询日志条数 slowlog reset 清空慢查询 配置： config set slow-log-slower-than 20000 config set slow-max-len 1000 config rewrite","tags":[{"name":"redis","slug":"redis","permalink":"https://naliomg.github.io/tags/redis/"}]},{"title":"node将json转换为excel","date":"2018-03-22T13:10:22.000Z","path":"2018/03/22/node将json转换为excel/","text":"node将json转换为excel如题，需要的材料为：ejsExcel，此三方库功能比较强大，可以将json数据根据设定的模板输出为ejs; // 安装 npm install ejsExcel --save // 主程序 var fs = require(&apos;fs&apos;) var ejsExcel = require(&quot;ejsExcel&quot;); var data = require(&apos;./ban.js&apos;) // json数据 var results = data //获得Excel模板的buffer对象 var exlBuf = fs.readFileSync(&quot;./bannedWords.xlsx&quot;); //用数据源(对象)data渲染Excel模板 ejsExcel.renderExcel(exlBuf, results).then(function(exlBuf2) { fs.writeFileSync(&quot;./test2.xlsx&quot;, exlBuf2); console.log(&quot;生成test2.xlsx&quot;); }).catch(function(err) { console.error(err); }); git链接 THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"co模块异步书写","date":"2018-02-09T14:46:43.000Z","path":"2018/02/09/co模块异步书写/","text":"ES6 co模块的异步书写es6之前，异步的回调嵌套太多，书写与阅读都非常麻烦。若用promise写法，数据从头到尾必须包含在promise内，也不是很方便。 此处介绍基于generator和yeild的co模块，阅读与书写就比较方便了。使用方法如下： npm install co // 安装 const co = require(&apos;co&apos;) function step1() { return new Promise(function(resolve, reject) { setTimeout(function() { console.log(&apos;step1&apos;) resolve(&apos;step1&apos;) }, 1000) }) } function step2() { return new Promise(function(resolve, reject) { setTimeout(function() { console.log(&apos;step2&apos;) resolve(&apos;step2&apos;) }, 1000) }) } function step3() { return new Promise(function(resolve, reject) { setTimeout(function() { console.log(&apos;step3&apos;) resolve(&apos;step3&apos;) }, 1000) }) } co(function *() { // 这样顺序书写，会在step1执行完毕后再执行step2； // 且resolve传递的值脱离了promise，被传递给了a,b var a = yield step1() var b = yield step2() }).then(function(data) { // co方法返回的也是一个promise对象，当然可以用then和catch继续书写 console.log(data) }).catch(function(err) { console.log(err) }) co(function *() { // 这样用数组书写，step1和step2并行执行； // 等到step1和step2都执行完毕之后，此个yeild才算执行完毕，才会执行step3 var res = yeild [ step1(), step2() ] // res = [&apos;step1&apos;, &apos;step2&apos;] var c = yeild step3() }) // 以下代码也是并行处理的一种书写方式 co(function *() { var res = yeild { 1: step1(), 2: step2() } var c = yeild step3() }) THE END！","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"发布订阅模式的事件BUS","date":"2017-12-09T08:36:17.000Z","path":"2017/12/09/发布订阅模式的事件BUS/","text":"发布订阅模式下的事件BUS// 事件bus，不考虑事件延迟订阅的情况，后端可以用promise替代，此脚本在于简化前端异步的情况； // 此处没有创建事件的命名空间，请使用者自行管理自定义事件名作为命名空间； // 后绑定的先执行 var Event = (function() { var clientList = {}; var listen = null; var trigger = null; var remove = null; var one = null; // 事件绑定，可以重复绑定相同的事件，触发时会全部触发 // 注意绑定的事件最好不要用匿名函数，事件移除不会移除匿名函数 listen = function(key, fn) { if (!clientList[key]) { clientList[key] = []; } clientList[key].push(fn); } // 事件触发 trigger = function() { var key = Array.prototype.shift.call(arguments); var fns = clientList[key]; if (!fns || fns.length === 0) { return false; } for (var i = fns.length - 1, fn; i &gt;= 0; i--) { fn = fns[i]; fn.apply(this, arguments); } } // 移除绑定 remove = function(key, fn) { var fns = clientList[key]; if (!fns) { // 未绑定对应事件 return false } if (!fn) { // 清除key绑定的全部事件 fns &amp;&amp; (fns.length = 0) } else { for (var l = fns.length - 1; l &gt;= 0; l--) { var _fn = fns[l]; if (_fn == fn) { fns.splice(l, 1); } } } } // 绑定一次 one = function(key, fn) { var _self = this; var once = fn; var handler = function() { once.apply(this, arguments); _self.remove(key, handler) } _self.listen(key, handler) } return { listen: listen, one: one, trigger: trigger, remove: remove } })(); module.exports = Event; THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"策略模式文本校验","date":"2017-12-03T14:19:54.000Z","path":"2017/12/03/策略模式文本校验/","text":"策略模式的文本校验策略模式由两部分组成：一部分是由可以替换的算法对象集合组成的策略类，另一部分是接受外部请求并将请求委托给策略组中某个对象的环境类。 以下为策略模式下的文本校验，以后用时可以随意添加策略类： // 策略模式表单校验 var strategies = { isNoEmpty: function(value) { if (value === &apos;&apos;) { return false } return true }, minLength: function(value, exdata) { var length = exdata[0] if (value.length &lt; length) { return false } return true }, maxLength: function(value, exdata) { var length = exdata[0] if (value.length &gt; length) { return false } return true }, isMobile: function(value) { if (!(/^1[3|4|5|8][0-9]\\d{4,8}$/.test(value))) { return false } return true } } var validataTest = function(str, arr) { if (!(arr instanceof Array) || (typeof str !== &apos;string&apos;)) { return { state: false, errmsg: &apos;参数错误！&apos; } } if (arr.length == 0) { return { state: true, errmsg: &apos;无规则，直接通过校验&apos; } } var result = { state: true, errmsg: &apos;通过校验！&apos; } for (var i = 0; i &lt; arr.length; i++) { if (!strategies[arr[i].strategy](str, arr[i].exdata)) { result.state = false result.errmsg = arr[i].errmsg break } } return result } module.exports = validataTest THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"stylus语法简介","date":"2017-10-27T12:13:30.000Z","path":"2017/10/27/stylus语法简介/","text":"stylus的安装与使用stylus介绍就不需要了，直接进入主题吧。 stylus的安装此处只介绍sublime中使用stylus编译的安装方法，因个人比较喜欢使用sublime。 node肯定是要有的； 全局安装stylus: npm install stylus -g； sublime中搜索stylus插件，下载安装，设置stylus的个人配置； 重启sublime，创建 .styl 文件保存就会自动编译了。 以上的stylus插件只提供了编译与高亮，并不会有语法补与提示，所以还要安装一个stylus-clean-completions插件就ok了！ 如果需要自动前置添加的话，最好还是工程化后结合gulp对编译后的css进行处理，此点less也是如此。 基本配置如下： { &quot;envPATH&quot;: &quot;&quot;, //环境的路径 &quot;binDir&quot;: &quot;&quot;, //项目路径 &quot;compileOnSave&quot;: true, //是否编辑保存 &quot;compileDir&quot;: true, //编译到指定目录 &quot;compress&quot;: true, //是否压缩 &quot;compilePaths&quot;: {&quot;&quot;: &quot;&quot;} //输出路径，此项不要默认在styl相同路径生成css } stylus语法简介语法的话参考 张鑫旭翻译的stylus文档 就行了，本文只挑选一些常用的语法出来，便于及时查看。感谢张大大的无私奉献！ 选择器 stylus的冒号、花括号、分号均可以省略替代； stylus通过空格，缩排来代替花括号，故缩进很重要； body color #fff Stylus就跟CSS一样，允许你使用逗号为多个选择器同时定义属性，使用新行是一样的效果： textarea input border 1px solid #eee //等同于： textarea, input border 1px solid #eee 父级引用，同less一样，用 &amp; 代表； 消除歧义，类似padding - n的表达式可能既被解释成减法运算，也可能被释义成一元负号属性。为了避免这种歧义，用括号包裹表达式： pad(n) padding (- n) body pad(5px) 然而，只有在函数中才会这样（因为函数同时用返回值扮演混合或回调）。 变量 stylus以等式的方式定义变量，变量替换时，会将变量值全部替换到使用的变量名位置，变量值中还可以包含变量；标识符（变量名，函数等），也可能包括$字符。变量冒失只能在冒号右边有效，左边属性名内会被当成属性名而无效。 font-size = 14px font = font-size &quot;Lucida Grande&quot;, Arial body font font sans-serif //会被编译为： body { font: 14px &quot;Lucida Grande&quot;, Arial sans-serif; } 属性查找，Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下： #logo position: absolute top: 50% left: 50% width: w = 150px height: h = 80px margin-left: -(w / 2) margin-top: -(h / 2) 我们不使用这里的变量w和h, 而是简单地前置 `@` 字符在属性名前来访问该属性名对应的值： #logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 若 `@` 的属性没有被定义，则属性会“向上冒泡”查找堆栈直到被发现，或者返回null（如果属性搞不定）。下面这个例子，@color被弄成了blue。 body color: red ul li color: blue a background-color: @color 变量赋值时，若后面的值内容有空格分隔，则变量可以当做数组来看待： size = 10px 15px body font-size size[0] padding size //编译为： body { font-size:10px; padding:10px 15px } 插值 Stylus支持通过使用{}字符包围 表达式 来插入值，其会变成标识符的一部分。例如，-webkit-{‘border’ + ‘-radius’}等同于-webkit-border-radius。感觉就是变量名的字符串链接，若用变量直接放在属性中的话，会被当成属性名处理的。 vendor(prop, args) -webkit-{prop} args -moz-{prop} args {prop} args border-radius() vendor(&apos;border-radius&apos;, arguments) button border-radius 1px 2px / 3px 4px // 编译为 button { -webkit-border-radius: 1px 2px / 3px 4px; -moz-border-radius: 1px 2px / 3px 4px; border-radius: 1px 2px / 3px 4px; } table for row in 1 2 tr:nth-child({row}) height: 10px * row // 编译为 table tr:nth-child(1) { height: 10px; } table tr:nth-child(2) { height: 20px; } 运算符 这一部分比较杂乱，复杂的运用一般不多，若遇到了可以参考 此文档。 混合书写 混入和函数定义方法一致，但是应用却大相径庭。mixins作为状态调用，而非表达式调用，仅仅是一些模块化的状态封装而已；minxins使用的时候，其内部属性会被复制到对应的选择器中。 border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius n form input[type=button] border-radius(5px) form input[type=button] border-radius 5px // 编译为如下，mix调用时，甚至不需要编写括号。 form input[type=button] { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; } 更进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式。 border-radius() -webkit-border-radius arguments -moz-border-radius arguments border-radius arguments border-radius 1px 2px / 3px 4px 另外一个很赞的应用是特定的私有前缀支持——例如IE浏览器的透明度： support-for-ie ?= true opacity(n) opacity n if support-for-ie filter unquote(&apos;progid:DXImageTransform.Microsoft.Alpha(Opacity=&apos; + round(n * 100) + &apos;)&apos;) #logo &amp;:hover opacity 0.5 // 编译为 #logo:hover { opacity: 0.5; filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=50); } 混合书写可以利用父级引用字符 &amp;, 继承父业而不是自己筑巢，也就是mixins最外层的 &amp; 引用引的是mixins调用的环境父级。 自然，混合书写可以利用其它混合书写，建立在它们自己的属性和选择器上。 方法 语言函数定义，其定义与混入(mixins)一致，却可以返回值。 add(a, b) a + b body padding add(10px, 5) // 渲染为： body { padding: 15px; } 注意到方法和混入的区别了吗？简介片面的来说，方法可以看做一个定义的变量，而混入是一个相较独立的属性包。 默认参数：可选参数往往有个默认的给定表达。在Stylus中，我们甚至可以超越默认参数。 add(a, b = a) a + b add(10, 5) // =&gt; 15 add(10) // =&gt; 20 返回多值：Stylus的函数可以返回多个值，就像你给变量赋多个值一样。 sizes() 15px 10px sizes()[0] // =&gt; 15px 有个小小的例外就是返回值是标识符。例如，下面看上去像一个属性赋值给Stylus（因为没有操作符）。为避免歧义，我们可以使用括号，或是return关键字。 swap(a, b) b a swap(a, b) (b a) swap(a, b) return b a 条件：简单的 if…else… 应用。 stringish(val) if val is a &apos;string&apos; or val is a &apos;ident&apos; yes else no stringish(&apos;yay&apos;) == yes // =&gt; true stringish(yay) == yes // =&gt; true stringish(0) == no // =&gt; true 注意：yes和no并不是布尔值。本例中，它们只是简单的未定义标识符。 别名：给函数起别名类似于定义变量。 add(a, b) a + b plus = add plus(1, 2) // =&gt; 3 变量函数：把函数当作变量传递到新的函数中。 invoke(a, b, fn) fn(a, b) add(a, b) a + b body padding invoke(5, 10, add) padding invoke(5, 10, sub) body { padding: 15; padding: -5; } 参数：arguments是所有函数体都有的局部变量，包含传递的所有参数。mixins中也有arguments变量，同函数一致。 sum() n = 0 for num in arguments n = n + num sum(1,2,3,4,5) // =&gt; 15 关键字参数 Stylus支持关键字参数，或”kwargs”. 允许你根据相关参数名引用参数，参数的顺序可以打乱，因为有的关键字，但这种情况一般使用的很少，个人感觉其实是加大了开发的复杂度，故此处就不再讨论。 内置方法 red(color)：返回color中的红色比重。 green(color)：返回color中的绿色比重。 blue(color)：返回color中的蓝色比重。 alpha(color)：返回color中的透明度比重。 dark(color)：检查color是否是暗色。 light(color)：检查color是否是亮色。 hue(color)：返回给定color的色调。 push(expr, args…)：后面推送给定的args给expr，别名为append()。 nums = 1 2 push(nums, 3, 4, 5) nums // =&gt; 1 2 3 4 5 unshift(expr, args…)：起始位置插入给定的args给expr，别名为prepend()，单个单个数据的操作，不是一次将所有args按给定顺序插入。 nums = 4 5 unshift(nums, 3, 2, 1) nums // =&gt; 1 2 3 4 5 keys(pairs)：返回给定pairs中的键。 pairs = (one 1) (two 2) (three 3) keys(pairs) // =&gt; one two three values(pairs)：返回给定pairs中的值。 pairs = (one 1) (two 2) (three 3) values(pairs) // =&gt; 1 2 3 typeof(node)：字符串形式返回node类型，别名有type-of和type。 type(12) // =&gt; &apos;unit&apos; typeof(12) // =&gt; &apos;unit&apos; typeof(#fff) // =&gt; &apos;rgba&apos; type-of(#fff) // =&gt; &apos;rgba&apos; unit(unit[, type])：返回unit类型的字符串或空字符串，或者赋予type值而无需单位转换。 unit(10) // =&gt; &apos;&apos; unit(15in) // =&gt; &apos;in&apos; unit(15%, &apos;px&apos;) // =&gt; 15px unit(15%, px) // =&gt; 15px match(pattern, string):检测string是否匹配给定的pattern。 abs(unit)：绝对值。 abs(-5px) // =&gt; 5px ceil(unit)：向上取整。 floor(unit)：向下取整。 round(unit)：四舍五入取整。 min(a, b)：取较小值。 max(a, b)：取较大值。 even(unit)：是否为偶数。 even(6px) // =&gt; true odd(unit)：是否为奇数。 sum(nums)：求和。 avg(nums)：求平均数。 join(delim, vals…)：给定vals使用delim连接。 join(&apos; &apos;, 1 2 3) // =&gt; &quot;1 2 3&quot; join(&apos;,&apos;, 1 2 3) // =&gt; &quot;1,2,3&quot; join(&apos;, &apos;, foo bar baz) // =&gt; &quot;foo, bar, baz&quot; join(&apos;, &apos;, foo, bar, baz) // =&gt; &quot;foo, bar, baz&quot; join(&apos;, &apos;, 1 2, 3 4, 5 6) // =&gt; &quot;1 2, 3 4, 5 6&quot; s(fmt, …)：s()方法类似于unquote()，不过后者返回的是Literal节点，而这里起接受一个格式化的字符串，非常像C语言的sprintf(). 目前，唯一标识符是%s。 s(&apos;bar()&apos;); // =&gt; bar() s(&apos;bar(%s)&apos;, &apos;baz&apos;); // =&gt; bar(&quot;baz&quot;) s(&apos;bar(%s)&apos;, baz); // =&gt; bar(baz) s(&apos;bar(%s)&apos;, 15px); // =&gt; bar(15px) s(&apos;rgba(%s, %s, %s, 0.5)&apos;, 255, 100, 50); // =&gt; rgba(255, 100, 50, 0.5) s(&apos;bar(%Z)&apos;, 15px); // =&gt; bar(%Z) s(&apos;bar(%s, %s)&apos;, 15px); // =&gt; bar(15px, null) length([expr])：括号表达式扮演元组，length()方法返回该表达式的长度。 length((1 2 3 4)) // =&gt; 4 length((1 2)) // =&gt; 2 length((1)) // =&gt; 1 length(()) // =&gt; 0 length(1 2 3) // =&gt; 3 length(1) // =&gt; 1 length() // =&gt; 0 warn(msg)：使用给定的error警告，并不退出。 error(msg)：伴随着给定的错误msg退出。 last(expr)：返回给定expr的最后一个值。 opposite-position(positions)：返回给定positions相反内容。 opposite-position(right) // =&gt; left opposite-position(top left) // =&gt; bottom right 其余参数 Stylus支持 name... 形式的其余参数。这些参数可以消化传递给混写或函数的参数们。 box-shadow(offset-x, args...) got-offset-x offset-x -webkit-box-shadow offset-x args -moz-box-shadow offset-x args box-shadow offset-x args #login box-shadow 1px 2px 5px #eee // 编译为 #login { got-offset-x: 1px; -webkit-box-shadow: 1px 2px 5px #eee; -moz-box-shadow: 1px 2px 5px #eee; box-shadow: 1px 2px 5px #eee; } offset-x设定一个专门的变量接收第一个传入的参数，剩余的参数统统传到args类数组中，不过传入的数据好像不能实现表达式的精确传递，比如逗号就有问题，故推荐直接使用 arguments 参数处理。 注释 Stylus支持三种注释，单行注释，多行注释，以及多行缓冲注释。 // 我是注释! body padding 5px // 蛋疼的padding /* * 给定数值合体 */ add(a, b) a + b /*! * 给定数值合体 */ add(a, b) a + b 单行注释跟JavaScript一样，双斜杠，CSS中不输出；多行注释看起来有点像CSS的常规注释。然而，它们只有在compress选项未启用的时候才会被输出；多行缓冲注释跟多行注释类似，不同之处在于开始的时候，这里是/*!. 这个相当于告诉Stylus压缩的时候这段无视直接输出。 条件 if / else if / else：跟一般的语言一致，if表达式满足(true)的时候执行后面语句块，否则，继续后面的else if或else。 box(x, y, margin-only = false) if margin-only margin y x else padding y x unless：除非，基本上与if相反，本质上是(!(expr))。 后缀条件：Stylus支持后缀条件，这就意味着if和unless可以当作操作符；当右边表达式为真的时候执行左边的操作对象，有点类似于三目运算； negative(n) error(&apos;无效数值&apos;) unless n is a &apos;unit&apos; return yes if n &lt; 0 no 迭代 Stylus允许你通过for/in对表达式进行迭代形式如下： for &lt;val-name&gt; [, &lt;key-name&gt;] in &lt;expression&gt; 例如： body for num in 1 2 3 foo num // 编译为： body { foo: 1; foo: 2; foo: 3; } 加上key-name的情况： body fonts = Impact Arial sans-serif for font, i in fonts foo i font // 编译为 body { foo: 0 Impact; foo: 1 Arial; foo: 2 sans-serif; } 后缀：就跟if/unless可以利用后面语句一样，for也可以。如下后缀解析的例子： sum(nums) sum = 0 sum += n for n in nums 不过为了方便理解，个人不建议使用这种方式。 导入 Stylus支持字面@import CSS, 也支持其他Stylus样式的动态导入。 @import &quot;reset.css&quot; 当使用@import没有 .css 扩展，会被认为是Stylus片段（如：@import &quot;mixins/border-radius&quot;）。 媒体 @media 工作原理和在常规CSS中一样，但是，要使用Stylus的块状符号。 @media print #header #footer display none 自定义字体 @font-face 跟其在CSS中作用表现一样，在后面简单地添加个块状属性即可，类似下面： @font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf) .ingeo font-family Geo 动画定义 Stylus支持@keyframes规则，当编译的时候转换成@-webkit-keyframes，使用@keyframes，通过vendors变量，会自动添加私有前缀(webkit moz official)，official 为标准解析。 继承 Stylus的 @extend 指令受SASS实现的启发，基本一致，除了些轻微差异。此功能大大简化了继承其他语义规则集的语义规则集的维护；把对应的选择器传给 @extend 即可继承已存在的选择器规则；此方式用 mixins 也可以实现，两种方式均比较简便，对于已有的规则集，一般使用 extend，若公共的规则比较多，建议使用 mixins 。 .message { padding: 10px; border: 1px solid #eee; } .warning { @extend .message; color: #E2E21E; } 目前Stylus与SASS不同之处在于SASS不允许@extend嵌套选择器，Stylus中，只要选择器匹配，就可以生效。 CSS字面量 不管什么原因，如果遇到Stylus搞不定的特殊需求，你可以使用@css使其作为CSS字面量解决之。 @css { body { font: 14px; } } // 编译为 body { font: 14px; } 字符转码 Stylus可以字符转码。这可以让字符变成标识符，或是渲染成字面量。注意Stylus中 / 当作为属性使用的时候需要用括号括起来： body padding 1 \\+ 2 body font 14px/1.4 font (14px/1.4) // 编译为 body { padding: 1 + 2; } body { font: 14px/1.4; font: 10px; } 慢慢回味学习吧~","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"chrome中圆角遮盖不住transform动画导致子元素溢出","date":"2017-10-24T14:17:45.000Z","path":"2017/10/24/chrome中圆角遮盖不住transform动画导致子元素溢出/","text":"chrome中圆角遮盖不住transform动画导致子元素溢出在chrome浏览器下（webkit内核），overflow:hidden;border-radus:*px;在静态的情况可以遮盖住超出圆角的子元素，但一旦子元素有transform移动时，圆角就会变为直角（子元素在圆角的地方溢出了）而出现闪烁的情况，非常糟糕！ 究其原因，是因为transform会创建新的stacking context，会压住没有此层级的父元素而出现溢出的现象。 哪些情况下会创建新的stacking context呢？1.the root element (HTML)（html层级自带）,2.positioned (absolutely or relatively) with a z-index value other than “auto”（position:absolute/relative;z-index不是auto的）,3.a flex item with a z-index value other than “auto”,4.elements with an opacity value less than 1（小于1的opacity也有）,5.elements with a transform value other than “none”（transform属性）,6.elements with a mix-blend-mode value other than “normal”,7.elements with isolation set to “isolate”, on mobile WebKit and Chrome 22+, 8.position: fixed always creates a new stacking context, even when z-index is “auto”（position:fixed;自带）,9.specifing any attribute above in will-change even you don’t write themselves directly 故常用解决办法： 1.给border-radius的父元素设置z-index即可；2.给border-radius的父元素设置transform: rotate(0)也可以;","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"ES6小记(6)","date":"2017-10-06T00:55:55.000Z","path":"2017/10/06/ES6小结(6)/","text":"ES6小计(6)17. Class17.1 Class基本语法JavaScript中其实是没有类这个概念的，有的只是对象的引用。 function Point(x, y) { this.x = x this.y = y } Point.prototype.toString = function() { return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos; } 上面这种写法不方便，且封装不完全。故ES6引入了Class概念做为对象模板，新的这个写法仅仅是让对象原型的写法更加清晰而已。 class Point { constructor(x, y) { this.x = x this.y = y } toString() { return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos; } } 可以看出ES6中类的写法中，有一个constructor方法，称为构造函数方法，类中this代表实例对象，另类内部函数类似于对象，但是属性之间不要加,，否则会报错。自定义属性需要放在constructor构造函数中。 typeof Point // function Point === Point.prototype.constructor 类的数据类型就是一个函数，类本身指向构造函数。类的所有方法(包括构造方法)均定义在类的prototype属性上。实例方法的调用，就是调用原型上的方法。类内部定义的所有方法都是不可枚举的，这点与ES5中prototype上的方法不同，但很有意义。 constructor方法是类的默认方法，在实例化类new时执行，若没有显示定义constructor方法，系统将会自动为类添加一个空的constructor方法。 类的实例化同ES5的构造函数一致，使用new关键字，若没有使用new实例化，将会报错。类的所有实例共享一个原型对象，同ES5的继承一致。 类的name属性总是返回class关键字后面的类名。class Point {}; Point.name // Point Class定义不存在变量提升，与let一致，必须先定义，再使用，当使用未定义的Class时，会报错。 类和模块的内部默认为严格模式，所以不需要使用use strict指定运行模式。 17.2 Class的继承Class之间可以通过extends关键字实现继承。 class ColorPoint extends Point { constructor(x, y, color) { super(x, y) this.color = color } toString() { return this.color + &apos; &apos; + super.toString() } } let cp = new ColorPoint(25, 7, &apos;green&apos;) cp instanceof ColorPoint // true cp instanceof Point // true Class内部的super指代父类的实例。子类必须在constructor方法中调用super方法，否则在新建实例的时候会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其加工。如不调用super方法，则得不到this对象，自然也就无法返回this实例。故必须在使用super后再使用this。 类的prototype属性和__proto__属性：大多数浏览器的ES5实现中，每一个对象均有__proto__属性，指向对应构造函数的prototype属性。而类同时有prototype属性和__proto__属性，因此存在两条继承链。 子类的__proto__属性表示构造函数的继承，总指向父类(实例继承实例)； 子类prototype属性的__proto__属性表示方法的继承，总指向父类的prototype属性(原型继承原型)。 class A {} class B extends A {} B.proto === A // true B.prototype.proto === A.prototype // true B.Proto.proto === A.proto // true Object.getPrototypeOf()Object.getPrototypeOf()可以用于从子类上获取父类，可以用此方法判断一个类是否继承了另一个类。 Object.getPrototypeOf(ColorPoint) === Point // true 17.3 原生构造函数的继承ECMAScript的原生构造函数： Boolean() Number() String() Array() Date() Function() Regexp() Error() Object() ES6之前，由于子类无法获取原生构造函数的内部属性，故无法对原生构造函数进行继承。而通过extends进行继承，是通过先建立父类实例对象的this，再对this对象进行修饰，故extends的继承可以继承原生构造函数，也就意味着可以在原生构造函数的基础上进行新的类定义。 class MyArray extends Array { constructor(...args) { super(...args) } } 17.4 Class的getter和setter与ES5一致，在Class内部可以使用get和set关键字对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() {} get prop() { return &apos;getter&apos; } set prop(value) { console.log(&apos;setter:&apos;, value) } } let inst = new MyClass() inst.prop = 123 // setter: 123 inst.prop // getter 17.5 Class的Generator方法同对象的Generator函数一致，只需要在属性函数名前加上*即可。 17.6 Class的静态方法在类中定义的方法均会被实例继承，但若在方法前加上static关键字，则表示该方法不会被实例继承。而只能通过类取调用，称之为“静态方法”。 class Foo { static classMethod() { return &apos;abc&apos; } } Foo.classMethod() // abc var foo = new Foo() foo.classMethod() // classMethod is not a function class Bar extends Foo {} Bar.clasMethod() // abc 静态方法可以被子类继承及调用。 17.7 Class的静态属性静态属性是指在Class本身的属性，即Class.propName，而不是在实例对象this上的属性。ES6规定类内只能定义属性，不能定义方法，故想给Class定义属性，需要在外部定义，且Class实例的属性也只能在constructor方法内定义。 class Foo {} Foo.prop = 1 Foo.prop // 1 17.8 new.target属性new.target是构造函数的内部属性，只能在构造函数内使用。new.target返回通过new命令所作用的构造函数，若构造函数不是通过new调用，则返回undefined。此属性可以用于指定类实例的创建方式。 function Person(name) { if (new.target !== undefined) { // 或 new.target === Person this.name = name } else { throw new Error(&apos;请使用new进行实例化&apos;) } } 注意子类继承父类时，new.target会返回子类。 18. Module模块加载规范：CommonJS: 模块就是对象，通过对象的加载而引用，运行时加载，同步执行。Node中，主要就是使用CommonJS进行模块加载。 // file exports.sum = function() {} // file2 module.exports = {sum: 123} // main let {sum} = require(&apos;file&apos;) AMD: 异步的加载模块，先定义所有依赖，然后在加载完成后的回调函数中执行。 define([&apos;clock&apos;],function(clock){ clock.start() }) CMD: 依赖就近，用的时候再require。 define(function(require, exports, module) { var clock = require(&apos;clock&apos;) clock.start() }) ES6模块加载: ES6模块不是对象，而是通过export命令显示指定输出的代码，编译时加载。 import {stat, exists, readFile} from &apos;fs&apos; // 从fs模块加载3个方法，其它不加载 另ES6的模块自动采用严格模式。 18.1 export命令export用于规定模块对外接口。 // file.js export var firstName = &apos;Michael&apos; export var lastName = &apos;Jackson&apos; // file2.js var firstName = &apos;Michael&apos; var lastName = &apos;Jackson&apos; export {firstName, lastName} export命令可以出现在模块的任意位置，只要处于模块的顶层即可，当处于块级作用域时，会报错。 18.2 import命令import用于加载文件模块。 import {firstName as fName, lastName as lName} from &apos;file2.js&apos; import的变量名可以用as进行重命名。注意import命令具有变量提升效果，会优先定义。建议不去掉大括号，当多变量引用时，方便阅读。 18.3 模块的整体加载当需要加载整个模块时，可用*和as指定一个对象用于承接export的所有属性和方法。 import * as total from &apos;file.js&apos; total // {firstName, lastName} 18.4 module命令module命令可以取代import做整体模块输入。 module total from &apos;file.js&apos; total // {firstName, lastName} 18.5 export default命令export default用于指定模块的默认输出，当文件需要引用一个模块的默认输出时，直接import到自定义变量即可。显然export default一个模块只能有一个。 // file.js export default { a: 1, b: function() {} } // main.js import file from &apos;file.js&apos; file // {a: 1, b: function() {}} 18.6 ES6模块加载实质ES6模块输出的是对象的引用，而CommonJS输出的是值得拷贝。 // file.js var counter = 3 function incCounter() { counter++ } module.exports = { counter, incCounter } // main.js var counter = require(&apos;file.js&apos;).counter var incCounter = require(&apos;file.js&apos;).incCounter console.log(counter) // 3 incCounter() console.log(counter) // 3 // file2.js export let counter = 3 export function incCounter() { counter++ } // main2.js import {counter, incCounter} from &apos;file2.js&apos; console.log(counter) // 3 incCounter() console.log(counter) // 4 THE END!","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"ES6小记(5)","date":"2017-10-05T00:55:55.000Z","path":"2017/10/05/ES6小结(5)/","text":"ES6小计(5)15. Promise对象15.1 Promise含义Promise是一个用来传递异步操作的消息对象。Promise对象的两个特点：1. 对象的状态不受外界影响；2. 对象状态改变后就不会再次改变。Promise有3种状态，Pending(进行中)、Resolved(已完成)、Rejected(已失败)。状态改变只能从进行中-&gt;已完成、进行中-&gt;已失败这两种改变。 15.2 基本使用Promise是一个构造函数，用于生成Promise实例。构造函数接收一个函数作为参数，该函数两个参数分别为resolve和reject。它们是两个函数，由JS引擎提供，不用自己部署。resolve(data)用于进行中-&gt;已完成的状态改变，并将改变时需要传递的值传递出去。reject(error)用于进行中-&gt;已失败的状态改变，并将失败的错误信息传递出去。 var promise = new Promise(function(resolve, reject) { if (true) { resolve(&apos;ok&apos;) } else { reject(&apos;err&apos;) } }) resolve(data)中的data除了普通值以外，还可以为另一个promise实例，此时，外层的promise实例的状态取决于传递的promise状态，并会将传递的实例传递的值传递出去。 let p1 = new Promise(function(resolve, reject) { setTimeout(function() { reject(1) }, 1000); }) let p2 = new Promise(function(resolve, reject) { resolve(p1) }) p2.then(function(data) { console.log(&apos;ok&apos;); console.log(data); }, function(err) { console.log(&apos;err&apos;); console.log(err); }) // err // 1 15.3 Promise.prototype.then()Promise实例的then()方法，用于添加Promise状态改变后的回调。then(f1, f2)接收两个函数参数，f1是状态为已完成的回调，f2是状态为已失败的回调。f2不是必须的。 let p1 = new Promise(function(resolve, reject) { setTimeout(function() { reject(1) }, 1000); }) let p2 = new Promise(function(resolve, reject) { resolve(2) }) p1.then(function(data) { console.log(&apos;ok:&apos;, data) }, function(err) { console.log(&apos;err:&apos;, err) }) // err: 1 p2.then(function(data) { console.log(&apos;ok:&apos;, data) }, function(err) { console.log(&apos;err:&apos;, err) }) // ok: 2 then()方法返回的是一个新的Promise对象实例，因此可以链式调用。then()回调内的函数，默认最外层包裹了一次Promise构造函数。当then内有遇到return时，类似于执行了resolve方法。因此，return一个Promise对象实例也是可以的。 15.4 Promise.prototype.catch()Promise实例的catch(fn)方法用于指定发生错误时(失败时)的回调函数。Promise的失败状态有冒泡性质，会一直向后传递，直到被捕获。 let p1 = new Promise(function(resolve, reject) { reject(2) }) p1.then(function(data) { console.log(&apos;ok:&apos;, data) }).then(null, function(err) { console.log(&apos;reject:&apos;, err) }).catch(function(err) { console.log(&apos;err:&apos;, err) }) // reject: 2 上述例子中，一般不会这样处理，then的第二个函数参数一般使用，而应用catch进行统一捕获。Promise内部的错误在状态未改变之前，不会传递到Promise外。catch方法也返回一个Promise对象，故后面可以继续使用then、catch方法。若catch方法前没有报错，则会跳过catch方法继续执行后面的调用链，若catch后面的调用链出现错误，不会影响前面的catch方法。 15.5 Promise.all()Promise.all([p1, p2, ...pn])方法用于将多个Promise实例包装成一个新的Promise实例。Promise.all()的参数不一定是数组，只要有遍历器接口便可以。并且要求每一个返回的成员都是Promise实例，若不是，默认会用Promise.resolve()将其转化为Promise实例。 返回的新的Promise实例的状态由传递的多个实例共同决定，1. 当多个实例状态全部为已完成时，新的实例状态才会变为已完成；后面的then回调参数为所有实例对象返回传参组成的数组；2. 当多个实例中有一个实例状态变为已失败，新的实例状态会变为已失败；后面的错误捕获的传参为第一个错误的返回传参。 let p1 = new Promise(function(resolve, reject) { resolve(1) }) let p2 = new Promise(function(resolve, reject) { resolve(2) }) let p3 = new Promise(function(resolve, reject) { reject(3) }) Promise.all([p1, p2]).then(function(data) { console.log(&apos;ok:&apos;, data); }).catch(function(err) { console.log(&apos;err:&apos;, err); }) // ok: [1, 2] Promise.all([p1, p3]).then(function(data) { console.log(&apos;ok:&apos;, data); }).catch(function(err) { console.log(&apos;err:&apos;, err); }) // err: 3 15.6 Promise.race()Promise.race([p1, p2, ...pn])方法同all()的传参一致，不过返回的实例状态同传递的多个实例中第一个变化的状态一致。故取名为race。传递的返回参数也同第一个变化的返回参数一致。 15.7 Promise.resolve()Promise.resolve(obj)将传递的参数包装成Promise对象，若传参是一个普通类型，则会返回一个状态为已完成的Promise实例，并传递obj参数；若传参是一个Promise对象，则会原封不动地将该Promise对象返回。 15.8 Promise.reject()Promise.reject(obj)将传递的参数包装成Promise对象，会返回一个状态为已失败的Promise实例，并传递obj参数，不管obj参数是什么类型。 16. 异步操作和async函数异步与同步的概念不多说。对于异步的书写，ES6前主要用回调，但容易出现回调地狱的情况，不易阅读与维护。ES6出现了Promise，时写法有了顺序性，但需要自己包装异步函数，冗余代码较多。后续又有Generator状态机进行异步操作，但流程管理需要自己控制，也不方便。 16.1 co模块co(gen)函数中，传参gen为一个Generator函数，co函数会返回一个Promise对象，故co().then().catch()均为可行。co函数要求yield指令后必须传Promise对象或Thunk函数。 co(function *() {}).then(function(data) {}).catch(function(err) {}) 当需要处理并发的异步操作时，可以用Promise.all()或者以对象或数组的形式进行书写。 co(function *() { var res = yield [ Promise.resolve(1), Promise.resolve(2) ] return res }) // 数组 co(function *() { var res = yield { 1: Promise.resolve(1), 2: Promise.resolve(2) } return res }) // 对象 co(function *() { var res = yield Promise.all([ Promise.resolve(1), Promise.resolve(2) ]) return res }) // 对象 16.2 async函数ES8中提供了async函数，使异步书写更为方便。async函数是Generator的语法糖。所有异步书写均为回调函数的语法糖。 var readFileAsync = async function () { var f1 = await readFile(&apos;/file1&apos;) var f2 = await readFile(&apos;/file2&apos;) console.log(f1.toString()) console.log(f2.toString()) } readFileAsync() 比较就会发现，async函数就是讲Generator函数的*变为await，将yield变为await，仅此而已。当然也有改进。 async函数类似于co模块，自带执行器，不需要像Generator函数一样需要自己去控制流程执行。 async包含的异步操作不会立即执行，需要像普通函数一样调用才会执行，不像co模块一样会立即执行，在需要的时候才会执行。 更好的语义，async直接表明是异步函数，await表示等待执行结果，比*和yield更易理解。 更广的适应性，co模块的yield语句后只能接Promise对象或Thunk函数，而await后面可以是Promise对象和原始类型的值。 返回值为Promise对象，同co模块。 let p1 = Promise.resolve(1) let p2 = Promise.reject(2) let f = async function () { let a = await p1 let b = await p2 return {a, b} } f().then(function(data) { console.log(data); }).catch(function(err) { console.log(&apos;err:&apos;, err); }) console.log(123); // 123 // err: 2 注意async函数只是说明内部函数是异步函数，自身并不会让外部函数执行暂停，故先输出的时123。相较于co函数来说，少了一层Promise的包装。await不能用于普通函数中。 TO BE CONTINUED!","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"ES6小记(4)","date":"2017-10-04T00:55:55.000Z","path":"2017/10/04/ES6小结(4)/","text":"ES6小计(4)13. Iterator和for…of13.1 Iterator遍历器遍历器创建一个指针对象，通过不断调用指针对象的next方法移动指针指向，不断对对象成员进行遍历。拥有遍历器接口的对象，均可以使用for...of进行遍历。数组、类数组、Set结构、Map结构自带遍历器接口，可直接使用for...of进行遍历。 调用遍历器接口的场合：数组和Set的结构赋值、扩展运算符、yield*状态机、for...of、Array.from()、Map()、Set()、Promise.all()、Promise.race() 字符串为类数组解构，也具有遍历器解构。 13.2 for…of循环for...of用于遍历所有数据结构的统一方法。只要一个数据结构有Symbol.iterator属性，就可以用for...of进行遍历。 var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] for (let a in arr) { console.log(a) } // 0 1 2 for (let a of arr) { console.log(a) } // a b c for...in用于遍历键名，for...of用于遍历键值。如果要通过for...of遍历键名，可以借助数组实例的entries()和keys()方法进行遍历。for...of遍历数组时，只会遍历数字索引的属性，与for...in有点不一致。 Set和Map的for...of遍历： var engines = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;c&apos;]) for (var e of engines) { console.log(e) } // a // b // c var es6 = new Map() es6.set(&apos;a&apos;, 1) es6.set(&apos;b&apos;, 2) es6.set(&apos;c&apos;, 3) for (var [key, value] of es6) { console.log(key + &apos;:&apos; + value) } // a:1 // b:2 // c:3 遍历的顺序是按添加顺序进行的，Set遍历为一个值，Map遍历时一个键和值组成的数组。对于有的不含遍历接口的类数组{0: &#39;a&#39;, 1: &#39;b&#39;, length: 2}，可以先用Array.from()将其转换为数组后遍历。for...of不能遍历普通对象。但可以用Object.keys()将对象的键名生成数组后进行遍历。 13.3 遍历比较for循环：最原始，书写较麻烦。数组的forEach循环：arr.forEach(function(value) { console.log(value) })，缺点是无法跳出循环。for...in循环：不仅遍历数字键名，还遍历原型链上的键，这往往不是我们想要的，且遍历有时顺序随机。for...of循环：没有上述的缺点。 14. Generator函数14.1 简介Generator函数是一种新的JS异步编程解决方案。可以把它理解为一个状态机，在这个状态机内，有多个需要依次去检测其状态的异步函数。Generator函数会返回一个遍历器对象，故其也是一个遍历器对象生成函数。 Generator函数有两个特征：一是在function与函数名之间有一个*号；而是内部用yield定义不同的状态。 function *temp() { yield &apos;a&apos;; yield &apos;b&apos;; return &apos;c&apos; } let hw = temp() hw.next() // {value: &apos;a&apos;, done: false} hw.next() // {value: &apos;b&apos;, done: false} hw.next() // {done: true} Generator函数的调用方法与普通函数一样，但因Generator函数返回的是一个遍历器对象，故函数内容并没有执行，需要用遍历器对象的next方法去遍历执行。每次调用next方法，内部指针就从函数的头部或上一次停下来的地方开始执行，执行到下一个yield(会执行完遇到的这个yield语句)或者return语句为止。 从上述变现看，Generator函数是一个可以暂停执行的函数，yield就是暂停语句。yield暂停语句不能用在普通函数中，会报错。若yield语句在表达式中用于计算时，需要在()内使用。用于赋值表达式的又边时，可以不加括号。 14.2 next 方法参数yield语句本身没有返回值，但next()方法可以带一个参数，携带的这个参数会被当做上一条yeild语句的返回值。故可以通过next()方法向函数内部注入控制值，但又有函数的上下文环境。 function *foo(x) { var y = 2 * (yield (x + 1)) var z = yield (y / 3) return x + y + z } var a = foo(5) a.next() // {value: 6, done: false} a.next() // {value: NaN, done: false} 注意yield无返回值，y = 2 * undefined == NaN a.next() // {value: NaN, done: true} var b = foo(5) b.next() // {value: 6, done: false} b.next(12) // {value: 8, done: false} // y = 2 * 12 b.next(13) // {value: 42, done: true} // x = 5, y = 24, z = 13 第一条next语句不能有参数，因参数代表上一条语句的返回值。当然，可以在Generator函数外再包一层已有一个自执行的next()方法的状态机函数就行了。 14.3 for...of循环for...of可以自动遍历Generator函数，不需要使用next方法。当next方法返回对象的done属性为true时，for...of循环终止，并且不包含返回对象。 function *foo() { yield 1 yield 2 yield 3 return 4 } for (let v of foo()) { console.log(v) } // 1 2 3 14.4 Generator.prototype.throw()Generator函数返回的遍历器对象都有一个throw方法，可以在函数体外抛出错误，但是错误的冒泡，会从函数体内开始。类似于错误注入到状态机内。注入的位置为yield关键字位置，在后续语句执行前。若此处上下文没有进行错误捕获，错误则会冒泡到函数外部。类似于Promise的reject。 var g = function *() { while (true) { try { yield; } catch (e) { if (e != &apos;a&apos;) throw e console.log(&apos;内部捕获&apos;, e) } } } var i = g() i.next() try { i.throw(&apos;a&apos;) i.throw(&apos;b&apos;) } catch (e) { console.log(&apos;外部捕获&apos;, e) } // 内部捕获 a // 外部捕获 b 这就意味着，将状态机内用try...catch包装起来后，可以用防止状态机内错误外泄，且便于统一处理。若状态机内执行过程中抛出错误，就不会再执行了。若此后再调用next方法，将返回{value: undefined, done: true}对象。 14.5 Generator.prototype.return()Generator函数返回的遍历器对象都有一个return方法，可以返回给定的值，并终止遍历。 function *gen() { yield 1 yield 2 yield 3 } var g = gen() g.next() // {value: 1, done: false} g.return(&apos;foo&apos;) // {value: &apos;foo&apos;, done: true} g.next() // {value: undefined, done: true} 当return()不传值时，返回值value为undefined。 function *numbers() { yield 1 try { yield 2 yield 3 } finally { yield 4 yield 5 } yield 6 } var g = numbers() g.next() // {value: 1, done: false} g.next() // {value: 2, done: false} g.return(7) // {value: 4, done: false} g.next() // {value: 5, done: false} g.next() // {value: 7, done: true} 注意当return在try代码块内返回时，要等到finally结束后才会执行return返回值。finally内等同于try外部，但是try后会执行。 14.6 yield* 语句如果在Generator函数内部调用另外一个Generator函数，默认情况下是没有效果的，因为Generator函数仅仅返回的是一个遍历器对象。但我们想要这个遍历器对象也生效时，就要用yield*方法调用内部Generator函数了，类似于对于这个遍历器对象做for...of遍历。其实yield*语法完全可以用for...of进行转换。 function *foo() { yield &apos;a&apos;; yield &apos;b&apos;; } function *bar() { yield &apos;x&apos;; foo(); yield &apos;y&apos; } function *set1() { yield &apos;x&apos;; yield* foo(); yield &apos;y&apos; } function *set2() { yield &apos;x&apos;; for (let v of bar()) { yield v }; yield &apos;y&apos; } for (let v of bar()) { console.log(v) } // x // y for (let v of set1()) { console.log(v) } // x // a // b // y for (let v of set2()) { console.log(v) } 上面例子最后set2输出同set1一致，不过set2中for…of循环需要自己做yield处理。并不是像yield 语句一样，将内部遍历器对象与外部遍历器对象合并了。准确的说，是`yield`将内部遍历器对象提取到外部来了。 任何数据结构，具有Iterator接口，就可以使用yield*进行遍历，与for...of表现一致。若内部Generator函数内有return语句进行返回时，可以向外部Generator函数进行数据返回。如用yield*进行处理内部状态机时，有两步：将内部状态机遍历器对象提取到外部，返回内部return的返回值。 function *g() { yield &apos;a&apos; yield &apos;b&apos; return &apos;result:&apos; } function *g2(send) { let result = yield* send() console.log(result) } console.log([...g2(g)]) // result: // [ &apos;a&apos;, &apos;b&apos; ] 故可以很方便地取出多重数组内部的值。 14.7 作为对象属性的Generator函数let obj = { gen: function *() {} } // 等同于 let obj = { * gen() {} } 14.8 Generator函数内的this因为Generator函数返回的时一个遍历器对象，故在没有对遍历器遍历时，Generator内部逻辑是没有执行的，故内部的this无效。但可以使用bind显式地对内部this进行绑定，并且对遍历器对象进行遍历后，this才会有正确的指向。 function *g() { this.a = 1 } let obj = g() obj.a // undefined function *f() { yield this.x = 2 yield this.y = 3 } let obj = {} let temp = f.bind(obj)() temp.next() // {value: 2, done: false} temp.next() // {value: 3, done: false} temp.next() // {value: undefined, done: true} obj // {x: 2, y: 3} 14.9 应用Generator函数的暂停执行效果，意味着把异步操作写在yield语句后，就可以通过next方法进行异步调用，顺序执行。 TO BE CONTINUED!","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"ES6小记(3)","date":"2017-10-03T00:55:55.000Z","path":"2017/10/03/ES6小结(3)/","text":"ES6小计(3)10. Proxy和Reflect10.1 ProxyProxy用于修改目标对象的某些默认行为，在语言层做出改变。Proxy可理解为对目标对象外做一层拦截。了解即可。 let target = {} let proxy = new Proxy(target, { get: function(target, property) { return 35 }, set: function(target, key, value, receiver) { return Reflect.set(target, key, value, receiver) } }) proxy.time // 35 proxy.name // 35 构造函数new Proxy(target, handler)接收两个参数，target目标对象，handler配置操作对象，用于定义代理的动作。要是Proxy有用，使用时需要针对Proxy实例进行操作，而不是target对象。Proxy支持的拦截操作包含：get、set、has、deleteProperty、enumerate、hasOwn、ownKeys、Object.keys()、getOwnPropertyDescriptior、definProperty、preventExtensions、getPrototypeOf、isExtensible、setPrototypeOf、apply、construct。 10.2 ReflectReflect对象有同Proxy代理的相同的方法，Reflect对象用于获取被代理的对象的默认行为，故一般Proxy代理内，均会用Reflex执行默认行为。 11. 二进制数组二进制数组由3类对象组成：ArrayBuffer对象、TypedArray视图、DataView视图。TypedArray视图支持9种数据类型： |数据类型|字节长度|含义 |对应C语言类型 ||Int8 |1 |8位带符号整数 |signed char ||Uint8 |1 |8位无符号整数 |unsigned char ||Uint8C |1 |8位无符号整数 |unsigned char ||Int16 |2 |16位带符号整数 |short ||Uint16 |2 |16位无符号整数 |unsigned char ||Int32 |4 |32位带符号整数 |int ||Uint32 |4 |32位无符号整数 |unsigned int ||Float32 |4 |32位浮点数 |float ||Float64 |8 |64位浮点数 |double | 11.1 ArrayBuffer对象ArrayBuffer对象代表存储二进制数据的一段内存，不能直接读写，只能通过视图读写。创建ArrayBuffer对象用new ArrayBuffer(length)构造函数创建，lengt代表分配的内存字节空间长度。 let buffer = new ArrayBuffer(12) let x1 = new Int32Array(buffer) x1[0] = 1 let x2 = new Uint8Array(buffer) // x1,x2均是代表同一段二进制空间，只是表示的视图不同，故内存空间变化后，两个都变。 x2[0] = 2 x1[0] // 2 node的Buffer对象其实就是Uint8Array视图对象的另一种封装。在node里，使用Buffer对象更为方便。 TypedArray视图除了接收ArrayType作为实例外，也可以直接接收普通数组作为参数，生成底层ArrayBuffer实例，完成对内存的赋值。 let typedArray = new Uint8Array([0, 1, 2]) typedArray.length // 3 typedArray[0] = 5 typedArray // [5, 1, 2] ArrayBuffer.prototype.byteLength，ArrayBuffer实例的byteLength属性返回所分配内存空间的字节长度。注意若ArrayBuffer分配的内存空间很大，有可能分配失败，故可以用byteLength检查内存分配是否如逾期，是否成功。 ArrayBuffer.prototype.slice(startIndex, endIndex)，ArrayBuffer实例所在的内存空间的复制，返回一个新的ArrayBuffer实例，新的内存空间。类似于String.prototype.slice()。除slice方法外，ArrayBuffer对象不提供任何其他直接读写内存的方法，只能通过视图对象。 ArrayBuffer.isView()，判断传入对象是否是一个视图对象。是，返回true；不是，返回false。 11.2 TypedArray视图TypedArray视图的数组成员为同一数据类型。目前TypedArray视图一共9种，每种均是一种构造函数。Int8Array：8位有符号整数，1个字节长度；Uint8Array：8位无符号整数，1个字节长度；Uint8ClampedArray：8位无符号整数，1个字节长度，溢出处理不同；Int16Array：16位有符号整数，2个字节长度；Uint8Array：16位无符号整数，2个字节长度；Int32Array：32位有符号整数，4个字节长度；Uint32Array：32位无符号整数，4个字节长度；Float32Array：32位浮点数，4个字节长度；Float32Array：32位浮点数，4个字节长度； 用这9个构造函数生成的数组，统称为TypedArray视图。该数组成员类型唯一，连续，不会有空位，默认值为0，数组存储的是指向buffer内存的指针。 字节序：二进制数据低位在前为小端字节序，高位在前为大端字节序。这直接影响读数。TypedArray只能处理小端字节序。大端字节序需要用DataArray视图去定义处理。 11.3 DataView视图DataView视图可以根据读取内容的方式不同而获取不同数据展示方式。 var buffer = new ArrayBuffer(24) var dv = new DataView(buffer) var v1 = dv.getUint16(1, true) // 从第二个字节读取一个16位无符号整数，小端字节序 var v2 = dv.getUint16(3, false) // 从第四个字节读取一个16位无符号整数，大端字节序 var v2 = dv.getUint16(3) // 从第四个字节读取一个16位无符号整数，大端字节序 dv.setInt32(0, 25, false) // 在第一个字节，以大端字节序写入值为25的32位整数 DataView实例读取内存方法：getInt8, getUint8, getInt16, getUint16, getInt32, getUint32, getFloat32, getFloat64 DataView实例写内存的方法：setInt8, setUint8, setInt16, setUint16, setInt32, setUint32, setFloat32, setFloat64 12. Set和Map数据结构12.1 SetSet是一个类似于数组的解构，其实可以理解为一个具有Iterator接口的对象。Set成员值是唯一的，没有重复。 var s = new Set() [2, 3, 4, 5, 4, 2, 2].map(x =&gt; s.add(x)) for (i of s) { console.log(i) } // 2 3 4 5 var set = new Set([1, 2, 3, 4, 4]) [...set] // [1, 2, 3, 4] set.size // 4 Array.from(set) // [1, 2, 3, 4] 向Set对象添加成员时，不会发生类型转换，但NaN会判断为相等。Set对象方法如下：add(value) 添加成员，返回成员总数。delete(value) 删除某个成员，返回boolean值，是否删除成功。has(value) 返回boolean，是否为Set成员。clear() 清除所有成员，无返回值。 Set对象的遍历方法：keys() 返回一个键名的遍历器。values() 返回一个键值的遍历器。entries() 返回一个键值对的遍历器，意义不大。forEach() 使用回调遍历每个成员。因Set解构的键名和键值相同，故keys()和values()返回值一样。entries()每次输出一个数组[key, value]，key和value值一样。注意使用数组与Set对象的相互转换，可以让Set解构使用数组的各种方法。 let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]) for (let item of set.keys()) { console.log(item) } for (let item of set.values()) { console.log(item) } for (let item of set) { console.log(item) } // 上诉3种方法结果一致 用Set解构可以很容易实现并集、交集、差集。 let a = new Set([1, 2, 3]) let b = new Set([4, 2, 3]) let union = new Set([...a, ...b]) // 并集 let intersect = new Set([...a].filter(x =&gt; b.has(x))) // 交集 let difference = new Set([...a].filter(x =&gt; !b.has(x))) // 差集，a-b 12.2 WeakSetWeakSet解构也是不重复的值的结合，不过值只能为对象。内部对象的引用为若引用，垃圾回收机制不会计算WeakSet对成员对象的应用。不能遍历。没有size属性。感觉意义不是很大。 12.3 Map结构js中对象的键名只能为字符串或者Symbol(es6新增)，Map结构与普通对象类似，但是可以以对象作为键名。 var m = new Map() var o = {p: &apos;hello&apos;} m.set(o, &apos;content&apos;) m.get(o) // content m.has(o) // true m.delete(o) // true m.has(o) // false Map()构造函数也可以接收一个数组，数组成员是键名和键值的数组。 var map = new Map([[&apos;name&apos;, &apos;张三&apos;], [&apos;title&apos;, &apos;author&apos;]]) map.size // 2 map.has(&apos;name&apos;) // true map.get(&apos;name&apos;) // 张三 map.has(&apos;title&apos;) // true map.get(&apos;title&apos;) // author 重复设置键时，后面的会覆盖前面的；以对象为键时，注意对象引用为同一个时，才会认为是同一个键。+0和-0视为同一个，NaN和NaN视为同一个键。 Map实例let m = new Map()的属性和方法：m.size 返回成员数目。m.set(key, value) 设置key对应的键值，返回整个Map实例。m.get(key) 返回key的键值，若没有此键，则返回undefined。m.has(key) 返回boolean，表示该键是否在Map中。m.delete(key) 删除key键，返回boolean，表示操作成功或失败。 Map遍历同Set遍历很相似，只不过键名和键值一般不一致：keys() 返回一个键名的遍历器。values() 返回一个键值的遍历器。entries() 返回一个键值对的遍历器，意义不大。forEach() 使用回调遍历每个成员。 Map相关数据结构转换：Map转数组：用扩展运算符 let myMap = new Map().set(true, 7).set({foo: 3}, [&apos;abc&apos;]) [...myMap] // [[true, 7], [{foo: 3}, [&apos;abc&apos;]]] 数组转Map，构造函数传入数组即可。 Map转对象，遍历一遍赋值即可，同理对象转Map也是。 12.4 WeakMapWeakMap结构与Map结构基本类似，不过它只接收对象作为键名，键名指向的对象不计入引用次数，不会对垃圾回收造成影响。 TO BE CONTINUED!","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"ES6小记(2)","date":"2017-10-02T00:55:55.000Z","path":"2017/10/02/ES6小结(2)/","text":"ES6小计(2)7. 函数的扩展7.1 参数的默认值函数定义时，可以直接用等于为参数设定默认值。传参全等于undefined的时候，默认值有效。参数默认值与解构赋值同时使用时，参数默认值先有效，其次再进行解构赋值。函数添加了length属性，表示函数参数总个数-已设定默认值的参数个数。 function log(x, y = &apos;Y&apos;) { console.log(x, y) } log(&apos;X&apos;) // XY (function(a, b, c = 5) {}).length // 2 函数的变量初始化的作用域不属于函数内部，而在函数外层。 let x = 1 function f(y = x) { let x = 2 console.log(y) } f() // 1 7.2 rest参数函数传参时，可以使用...变量名的方式定义函数参数，变量名为一个传参组成的数组。rest参数后不能再有参数。 function f(...arr) { console.log(arr) } f(1, 2, 3) // [1, 2, 3] 7.3 ...扩展运算符类似于rest参数的逆运算。将数组返还为多个项目参数。 console.log(...[1, 2, 3]) // 1 2 3 常有以下使用方法： 7.3.1 不定参数个数的传参。 let ag = [&apos;name1&apos;, 1, &apos;name2&apos;, 2, &apos;name3&apos;, 3] redis.client.hmset(&apos;key&apos;, ...ag, function(err, data) {}) // 简化传参的书写，此句等同于下句 redis.client.hmset(&apos;key&apos;, &apos;name1&apos;, 1, &apos;name2&apos;, 2, &apos;name3&apos;, 3, function(err, data) {}) 7.3.2 数据合并 let arr1 = [1, 2, 3] let arr2 = [4, 5, 6] arr1.push(...arr2) // arr1 = [1, 2, 3, 4, 5, 6] arr1.concat(arr2) [...arr1, ...arr2] 7.3.3 字符串转数组 [...&apos;hello&apos;] // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] 可识别UTF-16，依据数组长度，可有效判断字符串长度 7.3.4 类数组对象转换为真数组 [].slice.call(arrLike) Array.from(arrLike) [...arrLike] 7.4 箭头函数用箭头=&gt;定义的函数。 var f = v =&gt; v // 等同于如下： var f = function(v) { return v } var sum = (num1, num2) =&gt; { return num1 + num2 } 箭头函数仅仅是简化了函数定义的书写，并没有新增多少实际有用的功能。为了便于阅读，建议箭头函数的参数部分的()不要省略。箭头函数与普通函数的区别有以下四点： 箭头函数的this指向定义时所在对象，不是使用时所在对象；也可以说是箭头函数没有自己的this对象，在其内使用this其实是查找到外层的this； 不能使用new，不可当做构造函数； 不能使用arguments对象，但可以使用rest参数；箭头函数没有自己的arguments参数； 不可使用yield命令。 7.5 尾调用优化与尾递归优化函数尾调用时，不需要用到上层函数的环境时，使用尾调用就会不将上层环境保留在内存中，从而节省内存。尾递归同理。但是，只有开启严格模式，尾调用优化才会生效。 8. 对象的扩展8.1 对象属性与方法名的简洁缩写es6允许在对象中只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。 let x = 1, y = 2 let obj = {x, y} // let obj = {x: 1, y: 2} let objF = { testFunc(x) { return x } } 8.2 属性名可用表达式定义用表达式作为属性名时，表达式要放在[]内。属性名表达式与简洁表示法不能同时使用，否则会报错。 obj[&apos;a&apos; + &apos;b&apos;] = 123 obj = { abc: 123, [&apos;a&apos; + &apos;b&apos;]: 321 } var foo = &apos;bar&apos; var baz = { [foo] } // error var baz = { [foo]: &apos;abc&apos; } // {bar: &apos;abc&apos;} 8.3 Object.is()Object.is()用来比较两个值是否严格相等，类似于===，但有以下两点不同： +0 === -0 // true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true 8.4 Object.assign()Object.assign(目标obj, 源obj1, 源obj2...)，将源obj的可枚举属性复制到目标obj上，靠后的源obj属性会覆盖靠前的源obj的同名属性。继承的属性不会复制。该复制只是浅复制，只会复制当前层。 var target = {a: 1, b: 1}, source1 = {b: 2, c: 2}, source2 = {c: 3} Object.assign(target, source1, source2) target // {a: 1, b: 2, c: 3} 常用的应用有：克隆对象、合并多个对象、为属性指定默认值 8.5 属性的可枚举性遍历对象属性时，注意使用的遍历方法与可遍历属性的关系。for...in遍历时，会遍历继承属性，不会遍历不可枚举属性。Object.keys()返回自身可枚举属性组成的数组。JSON.stringify()只字符串化自身可枚举属性。Object.assign()只复制自身可枚举属性。Reflect.enumerate()返回for...in会遍历的属性组成的数组。故，循环遍历时，为了避免继承上的属性，建议用Object.keys()获取属性名后再循环属性名数组进行遍历。 9. SymbolSymbol是一个新的原始数据类型，表示独一无二的值。成为第七种数据类型：undefined、null、boolean、string、number、object、symbol。Symbol就是一个类似于不会重复的字符串。 9.1 Symbol类型的创建Symbol类型不是对象，不能用new方式创建。创建函数为Symbol(str)，创建时，可以传入一个字符串参数，用来描述该Symbol值。Symbol值不能与其余类型值进行运算，但可以显示转换为字符串和布尔值。 let s1 = Symbol(&apos;s1&apos;) let s2 = Symbol(&apos;s1&apos;) let s3 = Symbol(&apos;s3&apos;) s1 === s2 // false console.log(s1) // Symbol(s1) console.log(String(s1)) // Symbol(s1) console.log(s1.toString()) // Symbol(s1) console.log(Boolean(s1)) // true 9.2 Symbol作为属性名Symbol作为属性名时，不能用.运算符，只能用[]变量传值。 let s1 = Symbol() a[s1] = 123 var a = {} a = { [s1]: 123 } Object.defineProperty(a, s1, {value: 123}) 9.3 对象Symbol属性的遍历Symbol作为属性名时，不会被for...in、for...of循环遍历到，也不会被Object.keys()、Object.getOwnPropertyNames()返回。可以通过Object.getOwnPropertySymbols()通过数组返回。因此，可以为对象定义一些非私有，但只希望用于内部的方法。 9.4 Symbol.for()和Symbol.keyFor()当需要使用同一个Symbol值时，除了通过变量传参以外，还可以通过Symbol.for()获取。Symbol.for()的机制是检索全局中是否有注册该描述的Symbol值，若有，则返回该值；若没有，则注册后返回该值。Symbol.keyFor()则是通过Symbol值，获取注册描述。Symbol()创建的Symbol值不会进行注册。 Symbol.for(&apos;desc&apos;) === Symbol.for(&apos;desc&apos;) // true Symbol(&apos;desc&apos;) === Symbol.for(&apos;desc&apos;) // false let s1 = Symbol.for(&apos;desc&apos;) let s2 = Symbol(&apos;desc&apos;) Symbol.keyFor(s1) === &apos;desc&apos; // true Symbol.keyFor(s2) // undefined es6内置的Symbol值此处不讲，有需求可以查询相应资料。 TO BE CONTINUED!","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"ES6小记(1)","date":"2017-10-01T00:55:55.000Z","path":"2017/10/01/ES6小结/","text":"ES6小计(1)1. let与constes6中通过let与const声明的变量有了块级作用域的变化，let与const无变量提升，必须先声明再使用，且不能重复声明。先使用再声明会报变量未声明错误。const声明的变量需要立即赋值，声明后不能再次赋值。 2. 解构赋值解构赋值用处主要在于变量的声明。当多变量声明的时候，比较方便快捷。 2.1 数组的解构赋值let [a, b, c] = [1, 2, 3] // a = 1; b = 2; b = 3; let [a, ...b] = [1, 2, 3] // a = 1; b = [2, 3]; let [x = 1] = [undefined] // x = 1 let [x = 1] = [null] // x = null 解构为从左到右依次声明解构对象。若解构不成功，对应的变量为undefined。设定默认值时，当解构失败或者解构对应成员严格等于undefined的时候，解构才会使用默认值。 2.2 对象的解构赋值let {foo, bar} = {foo: &apos;aaa&apos;, bar: &apos;bbb&apos;} // foo = &apos;aaa&apos;; bar = &apos;bbb&apos; let {foo: f} = {foo: &apos;aaa&apos;, bar: &apos;bbb&apos;} // f = &apos;aaa&apos; let {x, y = 5} = {x: 1} // x = 1; y = 5 对象的解构赋值其实就是同名属性名的定义与赋值，因为es6中，对象的属性名与变量名相同时，可以简写。当然，数组解构与对象解构可以嵌套。对象解构的默认值与数组解构一致，对象的属性严格等于undefined或者解构失败时才会生效。 var x; {x} = {x: 1} 上述写法会报错，js解析时，会将 {x} 看成一个代码块，’=’ 赋值没有变量，报错。注意不要将大括号写在首行！ 2.3 字符串的解构赋值let [a, b, c, d, length] = &apos;1234&apos; // a = &apos;1&apos;; b = &apos;2&apos;; c = &apos;3&apos;; d = &apos;4&apos;; length = 4; 字符串对象转化为类数组对象后进行的解构。 2.4 数值和布尔型对象的解构赋值let {toString: s} = 123; // s === Number.prototype.toString 数值和布尔型会转化为对应的对象后再进行解构。123 =&gt; new Number(123), true =&gt; new Boolean(true)因null和undefined不能进行对象化，故用null与undefined进行解构会报错。 2.5 函数的解构赋值函数的解构赋值使用情况不多，不易阅读，且完全可以在函数内进行，故不做多余说明。 2.6 圆括号的使用解构赋值时，大部分情况不能使用()，可以使用圆括号的情况只有一种：赋值语句的非模式部分可以使用圆括号。故使用时，推荐直接不使用圆括号。 2.7 解构赋值的妙用[x, y] = [y, x] // 交换变量的值 let {a, b, c} = object // 从对象中取出特点属性的值 function test({a = 1, b = 2}) {} // 设定参数的初始化值 3. 字符串扩展字符串扩展使用较少，主要变化为UTF-8存储变为UTF-16，将2个字节存储不下的编码用4个字节去存储，写法用{}扩起来，如\\u{20BB7}。同时扩展了一些对于4个字节存储的字符串的相应的方法。 3.1 扩展方法3.1.1 s.codePointAt()返回字符串位置字符的十进制编码值。3.1.2 s.fromCodePoint()用编码值获取对应的字符。3.1.3 添加了字符串遍历接口for...of。相较于for循环来说，for...of可以识别两个字节存储的字符，长度不会出错。但不能记录循环的索引，需要自己处理。3.1.4 s.at()返回索引位置的字符，可以处理UTF-16，chatAt只能处理UTF-8。3.1.5 s.includes()类似于s.indexOf()，返回布尔值，表示是否找到该字符串。第二个字符串表示检测开始位置。记3.1.6 s.startsWith()返回布尔值，表示参数字符串是否在源字符串头部。第二个字符串表示检测开始位置。记3.1.7 s.endsWith()返回布尔值，表示参数字符串是否在源字符串结尾。第二个字符串表示检测开始位置。记3.1.8 s.repeat()返回新字符串，将源字符串重复n次。记3.1.9 s.padStart()返回新字符串，字符串头补全。x.padStart(4, &#39;ab&#39;) // abax3.1.10 s.padEnd()返回新字符串，字符串尾补全。3.1.11 反引号模板。${}用于变量传参。${}内的表达式会执行eval操作。 4. 正则扩展正则表达式在ES6内，构造函数RegExp从值接受字符串作为参数，变为可接受正则表达式作为参数。match、replace、search、split方法添加到RegExp实例上。添加u修饰符，用于对UTF-16编码的识别。添加y修饰符，类似于g修饰符，不过y修饰符每次匹配都是从上次匹配的头开始匹配，自带^匹配。正则对象添加sticky属性，用于记录正则对象是否设置了y修饰符。正则对象添加flags属性，返回正则对象的修饰符。正则对象中有source属性，用于返回正常表达式的正文。 5. 数值扩展二进制0b，八进制0o，十六进制0x。Number.isFinite()返回数值是否非无穷。除非无穷数值外，其余均返回false。Number.isNaN()返回数值是否是NaN。Number.parseInt()同parseInt()。Number.parseFloat()同parseFloat()Number.isInteger()判断数值是否是整数。添加Number.EPSILON常量，表示很小的可接受的误差范围。Number.isSafeInteger()判断是否是安全整数，-2^53-2^53之间。Math.trunc()返回一个数的整数部分。Math.sign()判断一个数是整数、负数、还是0。Math.sign(1) == 1; Math.sign(-1) == -1; Math.sign(0) == 0; Math.sign(-0) == 0; Math.sign(&#39;x&#39;) == NaN。Math对象上还新增了一些其他方法，如三角函数、立方等。新增**指数运算符，2 ** 3 // 8。 6. 数组扩展6.1 Array.from()，真数组变化Array.from()将类数组对象与可遍历对象转化为真数组。要求类数组对象要有length属性。该方法还可以接受第二个参数，类似于map方法，用于对每个元素进行处理，将处理后的值放入返回数组。 let arrayLike = { &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3 } let newSet = new Set([&apos;a&apos;, &apos;b&apos;, &apos;a&apos;]) var arr1 = [].slice.call(arrayLike) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] var arr2 = Array.from(arrayLike) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] var arr3 = Array.from(newSet) // [&apos;a&apos;, &apos;b&apos;] var arr4 = Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] Array.from([1, 2, 3], (x) =&gt; x * x) // [1, 4, 9] function countSymbols(str) { // 避免js将UTF-16的字符算为2个字符长度 return Array.from(str).length } 6.2 Array.of()将一组数值转化为数组注意同Array()的区别。 Array.of(3, 11, 8) // [3, 11, 8] Array.of(3) // [3] Array(3) // [ , , ,] Array(3, 11, 8) // [3, 11, 8] 6.3 Array.prototype.copyWithin(targetIndex, copyStart, copyEnd)数组内部复制将数组从targetIndex位置，用copyStart(默认为0)位置到copyEnd(默认为数组长度)位置的内容进行覆盖。 [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] 6.4 数组实例的find()与findIndex()方法find()用于找出第一个符合条件的数组成员，并返回该成员，不存在则返回undefined；findIndex()用于找出第一个符合条件的数组成员的索引，不存在则返回-1。 let arr = [1, 4, -5, 10] console.log(arr.find((value, index, arr) =&gt; value &lt; 0)) // -5 console.log(arr.findIndex((value, index, arr) =&gt; value &lt; 0)) // 2 6.5 数组实例的fill()方法fill(schar, startIndex, endIndex)将数组从设定位置startIndex开始(默认为0)，到endIndex之前为止(默认为数组长度)，用特定字符填充，会覆盖设定位置的数组值，会修改原数组。 [1, 2, 3].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 6.6 数组实例的entries()、keys()和values()entries()、keys()和values()用于遍历数组，返回一个遍历器对象(以0,1,2,3…为键名的对象，可用for...of遍历)。keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历。感觉意义不大。 for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) { console.log(index) } for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) { console.log(elem) } for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) { console.log(index, elem) } // 解构赋值 6.7 数组实例的includes()Array.prototype.includes()返回一个布尔值，表示该数组是否包含该给定的值。类似于字符串的includes()。includes()可以检测NaN。 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true [1, 2, 3].includes(2, 2) // false，第二个参数为检索起始位置 6.8 数组空位es6后，数组空位会被处理为undefined，如Array.from()方法。 6.9 数组推导利用for...of对现有数组遍历后做简单处理，并返回新数组的效果，类似于map方法。会看即可。 var a1 = [1, 2, 3, 4] var a2 = [for (i of a1) i * 2] // [2, 4, 6, 8]，对于返回的表达式，还可以使用if语句表达式 6.10 数组实例遍历方法回顾every()对数组中每一项进行处理，若函数每一项都返回true，则表达式返回true；filter()对数组中每一项进行处理，函数返回返回值为true的项目的数组；forEach()对数组中每一项进行处理，无返回值，单纯遍历处理；map()对数组中每一项进行处理，函数返回返回值构成的数组；some()对数组中每一项进行处理，若函数任意一项返回true，则表达式返回true 6.11 数组其余常用方法push()往数组后添加数据，返回数组长度；pop()数组末尾出队列，返回出队列项；shift()数组头出队列，返回出队列项；unshift()数组头入队列，返回数组长度；sort()数组排序，返回值大于0，升序；小于0，降序；reverse()数组顺序翻转；concat()数组合并或者添加项到末尾，返回新数组；slice()数组截取，返回指定位置的数组；splice()数组删除或者修改，返回删除掉的片段数组；reduce()数组正向归并，有四个参数，第一个为上一个处理的返回值，第二个为当前值，第三个为当前索引，第四个为数组对象；reduceRight()数组反向归并，有四个参数，第一个为上一个处理的返回值，第二个为当前值，第三个为当前索引，第四个为数组对象；indexOf()查找数组内对象，返回查找到的索引值或-1，不能查找NaN； TO BE CONTINUED!","tags":[{"name":"es6","slug":"es6","permalink":"https://naliomg.github.io/tags/es6/"}]},{"title":"vuex使用小计","date":"2017-08-28T13:12:27.000Z","path":"2017/08/28/vuex使用小计/","text":"vuex使用小计1. 安装vuexnpm install vuex --save 2. 引入vueximport Vuex from &apos;vuex&apos; 3. 文件安装Vue.use(Vuex) 4. 实例化const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment: state =&gt; state.count++ } }) 5. 挂载注入(此处为全局注入)new Vue({ el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: { App } }) 6. 组件使用状态读取:store中的状态应该从组件的计算属性中去读取，因为状态存储是响应式的。对于一个组件需要获取较多的状态的时候，可以在计算属性中引入 mapState 辅助函数去计算，作用不大…也就少写几个字。 computed: { count () { return this.$store.state.count } } 7. getters使用getters相当于计算属性computed，当依赖发生改变时才会刷新对应的缓存值。Getters 接受 state 作为其第一个参数，另一个getter作为第二个参数。也有一个 mapGetters 函数可以简化书写。 const store = new Vuex.Store({ state: { arr: [{ value: &apos;first&apos;, state: true }, { value: &apos;second&apos;, state: false }, { value: &apos;third&apos;, state: true }] }, getters: { trueArr: state =&gt; { return state.arr.filter(item =&gt; item.state) } } }) // 组件中： computed: { arr() { // [{value: &apos;first&apos;, state: true}, {value: &apos;third&apos;, state: true}] return this.$store.getters.trueArr } } 8. Mutations状态改变更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型（事件名） (type) 和 一个 回调函数（处理函数） (handler)。当然，你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）,在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment(state, params) { state.count += params.n } } }) // 组件中触发事件： methods: { addCount() { this.$store.commit(&apos;increment&apos;, { n: 2 }) } } 提交 mutation 的另一种方式是直接使用包含 type 属性的对象,当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变: store.commit({ type: &apos;increment&apos;, n: 2 }) 注意事项 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：state.obj = { …state.obj, newProp: 123 }。 mutation 必须是同步函数。 9. Actions状态改变Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象: const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment: state =&gt; state.count++ }, actions: { increment(context, paramsObj) { setTimeout(function(){ context.commit(&apos;increment&apos;, paramsObj) }, 1000) } } }) // 分发, 载荷部分同mutations methods: { delayCount() { this.$store.dispatch(&apos;increment&apos;, 2) } } 10. ModulesVuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -&gt; moduleA 的状态 store.state.b // -&gt; moduleB 的状态 THE END!","tags":[{"name":"vue","slug":"vue","permalink":"https://naliomg.github.io/tags/vue/"}]},{"title":"soket.io使用","date":"2017-08-08T13:28:26.000Z","path":"2017/08/08/soket-io使用/","text":"soket-io的常用接口webdoket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。 此文介绍一些 soket.io 的基本使用。主页：https://socket.io/ 1. node + express + soket.io系统搭建服务器端：安装：npm install --save socket.io 将soket服务绑到 server 上； // www文件 var io = require(&apos;../routes/websoket.js&apos;); io.attach(server); //独立的websoket文件 var io = require(&apos;socket.io&apos;)(); var request = require(&apos;request&apos;); io.on(&apos;connection&apos;, function(socket) { console.log(&apos;a user connected&apos;); socket.emit(&apos;msg&apos;, { msg: &apos;我是智能闲聊高手，放马过来吧!&apos; }); socket.on(&apos;msg&apos;, function(obj) { // 接入图灵机器人,此处用图灵机器人实现了一个对话功能。 request({ url: &apos;http://www.tuling123.com/openapi/api&apos;, method: &quot;POST&quot;, json: true, form: { &apos;key&apos;: &apos;1a6e7a453c1645ee8739f592ef05465e&apos;, &apos;info&apos;: obj.msg, &apos;userid&apos;: &apos;naliomg&apos; } }, function(err, resp, body) { if (err) { console.log(err); return; } if (body.code == 100000) { socket.emit(&apos;msg&apos;, {msg: body.text}); }else if(body.code == 200000) { socket.emit(&apos;msg&apos;, {msg: body.text+&apos;，&lt;a href=&quot;&apos;+body.url+&apos;&quot;&gt;点这里&lt;/a&gt;&apos;}); } }); }); }); module.exports = io; 客户端：客户端需要引入soket.io的js文件，cdn: https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=1.0&quot; /&gt; &lt;title&gt;websoket&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ margin: 0; padding: 0; } .clearfix{ zoom: 1; } .clearfix:after{ content: &apos;&apos;; display:block; width: 0; height: 0; font-size: 0; visibility: hidden; clear: both; } .pull-l{ float: left; } .pull-r{ float: right; } .container{ padding: 10px; margin: 0 auto; box-sizing: border-box; } .msg-wrap{ width: 300px; height: 400px; margin: 10px auto; border: 3px solid #ddd; overflow: auto; } .controll-btn{ width: 300px } #sendMsg{ width: 220px; height: 40px; color: #aaa; box-sizing: border-box; } #send{ height: 40px; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/utils/jquery/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;msg-wrap container&quot; id=&quot;log&quot;&gt;&lt;/div&gt; &lt;div class=&quot;controll-btn container clearfix&quot;&gt; &lt;input id=&quot;sendMsg&quot; class=&quot;pull-l&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot;&gt;&lt;/input&gt; &lt;input id=&quot;send&quot; class=&quot;pull-r&quot; type=&quot;button&quot; value=&quot;发送&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;script&gt; $(function(){ var socket = io(&apos;http://naliomg.site&apos;); socket.on(&apos;msg&apos;, function(resp){ $(&apos;#log&apos;).append(&apos;&lt;p class=&quot;clearfix&quot;&gt;&lt;span class=&quot;pull-l&quot;&gt;&apos;+resp.msg+&apos;&lt;/span&gt;&lt;/p&gt;&apos;); $(&apos;#log&apos;).scrollTop( $(&apos;#log&apos;)[0].scrollHeight ); }); $(&apos;#send&apos;).on(&apos;click&apos;, function(){ var msg = $(&apos;#sendMsg&apos;).val(); if (msg.trim()==&apos;&apos;) { alert(&apos;消息不能为空~&apos;); return; } socket.emit(&apos;msg&apos;, {msg: msg}); $(&apos;#log&apos;).append(&apos;&lt;p class=&quot;clearfix&quot;&gt;&lt;span class=&quot;pull-r&quot;&gt;&apos;+msg+&apos;&lt;/span&gt;&lt;/p&gt;&apos;); $(&apos;#sendMsg&apos;).val(&apos;&apos;); $(&apos;#log&apos;).scrollTop( $(&apos;#log&apos;)[0].scrollHeight ); }); $(&apos;#otherConnect&apos;).on(&apos;click&apos;, function(){ var nameSoket = io(&apos;/test&apos;); }); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2. 服务器端常用API//监听客户端连接,回调函数会传递本次连接的socket io.on(&apos;connection&apos;,function(socket){ //监听客户端发送的信息 socket.on(&apos;event&apos;,function(data){}); //给该socket的客户端发送消息 socket.emit(&apos;event&apos;, data); //给除了自己以外的客户端广播消息 socket.broadcast.emit(&quot;msg&quot;,{data:&quot;hello,everyone&quot;}); //分组 socket.on(&apos;group1&apos;, function (data) { socket.join(&apos;group1&apos;); }); socket.on(&apos;group2&apos;,function(data){ socket.join(&apos;group2&apos;); }); //一个客户端可以存在多个分组（订阅模式） socket.emit(&apos;group1&apos;); //就可以加入group1分组； socket.emit(&apos;group2&apos;); //就可以加入group2分组； socket.leave(data.room); //退出分组 //对分组中的用户发送信息，不包括自己 socket.broadcast.to(&apos;group1&apos;).emit(&apos;event_name&apos;, data); }); //给所有客户端广播消息 io.sockets.emit(&apos;event&apos;,data); //给指定的客户端发送消息 io.sockets.socket(socketid).emit(&apos;event&apos;, data); //对分组中的用户发送信息，不包括自己 io.sockets.in(&apos;group1&apos;).emit(&apos;event_name&apos;, data); //获取连接的客户端socket io.sockets.clients().forEach(function (socket) { //..... }); //获取分组信息 //获取所有房间（分组）信息 io.sockets.manager.rooms; //来获取此socketid进入的房间信息 io.sockets.manager.roomClients[socket.id]; //获取particular room中的客户端，返回所有在此房间的socket实例 io.sockets.clients(&apos;particular room&apos;); //另一种分组方式 io.of(&apos;/some&apos;).on(&apos;connection&apos;, function (socket) { socket.on(&apos;test&apos;, function (data) { socket.broadcast.emit(&apos;event_name&apos;,{}); }); }); 3. 客户端常用API//建立一个socket连接 var socket = io(&quot;ws://103.31.201.154:5555&quot;); //监听服务消息 socket.on(&apos;msg&apos;,function(data){ socket.emit(&apos;msg&apos;, {rp:&quot;fine,thank you&quot;}); //向服务器发送消息 console.log(data); }); //监听socket断开与重连。 socket.on(&apos;disconnect&apos;, function() { console.log(&quot;与服务其断开&quot;); }); socket.on(&apos;reconnect&apos;, function() { console.log(&quot;重新连接到服务器&quot;); }); 客户端socket.on()监听的事件：connect：连接成功connecting：正在连接disconnect：断开连接connect_failed：连接失败error：错误发生，并且无法被其他事件类型所处理message：同服务器端message事件anything：同服务器端anything事件reconnect_failed：重连失败reconnect：成功重连reconnecting：正在重连 当第一次连接时，事件触发顺序为：connecting-&gt;connect；当失去连接时，事件触发顺序 为：disconnect-&gt;reconnecting（可能进行多 次）-&gt;connecting-&gt;reconnect-&gt;connect。 THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"ngrok搭建外网可以访问的本地服务器","date":"2017-08-01T12:18:15.000Z","path":"2017/08/01/ngrok搭建外网可以访问的本地服务器/","text":"利用ngrok搭建外网可以访问的本地服务器微信公众号开发的时候，由于在自己电脑上开发，而微信接入需要一个外网的域名地址，用ngrok搭建一个反向代理就非常方便了。 使用方法： 注册 -&gt; 开通一个隧道 -&gt; 利用隧道的id -&gt; 启动‘Sunny-Ngrok启动工具.bat’ -&gt; 输入隧道id -&gt; ok; 前提要打开本地服务器； 免费的隧道有时候慢得很…","tags":[{"name":"工具","slug":"工具","permalink":"https://naliomg.github.io/tags/工具/"}]},{"title":"node+ueditor+qn+atjs编辑器搭建","date":"2017-08-01T12:17:53.000Z","path":"2017/08/01/node-ueditor-qn-atjs编辑器搭建/","text":"nodejs + ueditor + qn + at.js 构建富文本编辑器图片文件上传及@功能1. ueditorueditor为百度前端团队开发的一款功能强大的富文本编辑器，使用也比较方便。 其主页为：http://ueditor.baidu.com/website/ 使用时必须引入的文件有：ueditor.cssueditor.config.jsueditor.all.js后端需要使用ueditor.config.json;ueditor.config.js的具体配置请查看官网api；后台为node或者php的话，下载php版本即可 基本使用： // html，可以为script标签，也可以为textarea标签 &lt;script id=&quot;container&quot; name=&quot;content&quot; type=&quot;text/plain&quot;&gt;需要初始化的数据&lt;/script&gt; &lt;!-- &lt;textarea id=&quot;container&quot;&gt;需要初始化的数据&lt;/textarea&gt; --&gt; // js实例化即可，可以传一个json参数作为初始化的使用定制 var ue = UE.getEditor(&apos;container&apos;); 2. 七牛文件上传搭配nodejs使用七牛，此处并没有使用七牛官方提供 js sdk ，而是使用的 node-ueditor 的一款针对ueditor的插件。实现图片文件的上传与管理。 安装: npm install ueditor --save 使用: // 此为没有使用7牛存储，将上传的图片存储到自己服务器的情况 var bodyParser = require(&apos;body-parser&apos;) var ueditor = require(&quot;ueditor&quot;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), function(req, res, next) { // ueditor 客户发起上传图片请求 if(req.query.action === &apos;uploadimage&apos;){ var foo = req.ueditor; var date = new Date(); var imgname = req.ueditor.filename; var img_url = &apos;/images/ueditor/&apos;; res.ue_up(img_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 } // 客户端发起图片列表请求 else if (req.query.action === &apos;listimage&apos;){ var dir_url = &apos;/images/ueditor/&apos;; res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/ueditor/ueditor.config.json&apos;) // ueditor初始化时会向设置的/ueditor/ue路由发起请求，需要返回ueditor.config.json }})); // qn存储 var bodyParser = require(&apos;body-parser&apos;) var ueditor = require(&quot;ueditor&quot;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); // 支持七牛上传，如有需要请配置好qn参数，如果没有qn参数则存储在本地 app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), { qn: { accessKey: &apos;your access key&apos;, // qn accessKey secretKey: &apos;your secret key&apos;, // qn secretKey bucket: &apos;your bucket name&apos;, // qn bucket origin: &apos;http://{bucket}.u.qiniudn.com&apos;, // 这个地址是qn返回的图片地址域，使用融合cdn或者qn提供的测试域 uploadURL: &apos;http://up-z2.qiniu.com&apos; // qn上传接口地址，这个为华南 } }, function(req, res, next) { // ueditor 客户发起上传图片请求，如果没有配置qn参数，则会上传到本地服务器；就会走下面的存储。 var imgDir = &apos;/img/ueditor/&apos; if(req.query.action === &apos;uploadimage&apos;){ var foo = req.ueditor; var imgname = req.ueditor.filename; res.ue_up(imgDir); //你只要输入要保存的地址 。保存操作交给ueditor来做 } // 客户端发起图片列表请求 else if (req.query.action === &apos;listimage&apos;){ res.ue_list(imgDir); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/ueditor/ueditor.config.json&apos;) }})); // 多文件类型存储 var bodyParser = require(&apos;body-parser&apos;) var ueditor = require(&quot;ueditor&quot;) app.use(bodyParser.urlencoded({ extended: true })) app.use(bodyParser.json()); app.use(&quot;/ueditor/ue&quot;, ueditor(path.join(__dirname, &apos;public&apos;), function(req, res, next) { var imgDir = &apos;/img/ueditor/&apos; //默认上传地址为图片 var ActionType = req.query.action; if (ActionType === &apos;uploadimage&apos; || ActionType === &apos;uploadfile&apos; || ActionType === &apos;uploadvideo&apos;) { var file_url = imgDir;//默认上传地址为图片 /*其他上传格式的地址*/ if (ActionType === &apos;uploadfile&apos;) { file_url = &apos;/file/ueditor/&apos;; //附件保存地址 } if (ActionType === &apos;uploadvideo&apos;) { file_url = &apos;/video/ueditor/&apos;; //视频保存地址 } res.ue_up(file_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;); } //客户端发起图片列表请求 else if (ActionType === &apos;listimage&apos;){ res.ue_list(imgDir); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/ueditor/ueditor.config.json&apos;) }})); 其实这个插件已经不止用于搭配ueditor了，所有图片及文件的上传基本都可以使用了，不过对数据的处理比较死，没有更多的对上传文件进行加工。 3. at.js用at.js实现 ‘@’ 书写功能。 github地址：https://github.com/ichord/At.js 必须要引入的文件：jquery.atwho.cssjquery.min.jsjquery.caret.jsjquery.atwho-2.js 一定要注意at的版本，1.0以下好像与ueditor不兼容，@功能会有问题。 使用： &lt;script type=&quot;text/javascript&quot;&gt; var ue = UE.getEditor(&apos;container&apos;); $(function(){ var at_config = { at: &quot;@&quot;, data:[&apos;Peter&apos;, &apos;Tom&apos;, &apos;Anne&apos;, &apos;zhangsan&apos;, &apos;lisi&apos;], limit: 20 } var ue = UE.getEditor(&apos;container&apos;,{ autoClearinitialContent:true, //关闭字数统计 wordCount:false, //关闭elementPath elementPathEnabled:false, }); ue.addListener(&apos;ready&apos;, function(editor){ $(this.document.body).atwho(at_config); }); }); &lt;/script&gt; 以上3个插件就实现了富文本编辑器的常见使用功能，是不是比自己写方便多了呢~ THE END！","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"判断浏览器是否是移动设备","date":"2017-07-14T14:34:53.000Z","path":"2017/07/14/判断浏览器是否是移动设备/","text":"判断浏览器是否是移动设备function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == &quot;ipad&quot;; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == &quot;iphone os&quot;; var bIsMidp = sUserAgent.match(/midp/i) == &quot;midp&quot;; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == &quot;rv:1.2.3.4&quot;; var bIsUc = sUserAgent.match(/ucweb/i) == &quot;ucweb&quot;; var bIsAndroid = sUserAgent.match(/android/i) == &quot;android&quot;; var bIsCE = sUserAgent.match(/windows ce/i) == &quot;windows ce&quot;; var bIsWM = sUserAgent.match(/windows mobile/i) == &quot;windows mobile&quot;; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { return false; //是移动设备 } else { return true; //是pc } } THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"CSS实现侧边栏等高布局","date":"2017-07-04T13:20:59.000Z","path":"2017/07/04/CSS实现侧边栏等高布局/","text":"CSS实现侧边栏等高布局用纯CSS来实现侧边栏等高布局： html: &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;左边，无高度属性，自适应于最高一栏的高度&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边，无高度属性，自适应于最高一栏的高度&lt;/div&gt; &lt;div class=&quot;center&quot;&gt;中间，高度600像素，左右两栏的高度与之自适应&lt;/div&gt; &lt;/div&gt; css: #content{ overflow:hidden; } .left{ width:200px; margin-bottom:-3000px; padding-bottom:3000px; background:#cad5eb; float:left; } .right{ width:400px; margin-bottom:-3000px; padding-bottom:3000px; background:#f0f3f9; float:right; } .center{ margin:0 410px 0 210px; background:#ffe6b8; height:600px; } 最终起作用的就是父元素的 overflow:hidden，子元素的 margin-bottom:-3000px;padding-bottom:3000px ；3000这个数值是根据可能存在的最大高度来算的。 THE END！","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"node将excel转换为json","date":"2017-07-03T13:19:20.000Z","path":"2017/07/03/node将excel转换为json/","text":"nodeJs将excel转化为json1.直接转换var xlsx = require(&quot;node-xlsx&quot;); var fs = require(&apos;fs&apos;); var list = xlsx.parse(&quot;myexcel.xlsx&quot;); //console.log(JSON.stringify(list)); console.log(list); writeFile(&quot;myexcel.json&quot;, JSON.stringify(list)); function writeFile(fileName, data) { fs.writeFile(fileName, data, &apos;utf-8&apos;, complete); function complete(err) { if (!err) { console.log(&quot;文件生成成功&quot;); } } } 这种基础的转换会生成这样一个数组： [ { &quot;name&quot;: &quot;Sheet1&quot;, &quot;data&quot;: [ [&quot;id&quot;, &quot;name&quot;, &quot;sex&quot;, &quot;age&quot;], [1, &quot;nali&quot;, &quot;male&quot;, 25], [2, &quot;naliomg&quot;, &quot;female&quot;, 22] ] }, { &quot;name&quot;: &quot;Sheet2&quot;, &quot;data&quot;: [] }, { &quot;name&quot;: &quot;Sheet3&quot;, &quot;data&quot;: [] } ] 其中，每一个大对象为一个sheet中的内容，name为sheet命名，data为表格里每一行的数据。 2.对数据进行一些对象化处理以上直接转换的方式主要转换成了数组内容，不太方便读取与使用，将excel定义好后做一些基本处理就好用得多。 excel数据为如下： var xlsx = require(&quot;node-xlsx&quot;); var fs = require(&apos;fs&apos;); var list = xlsx.parse(&quot;Camp.xlsx&quot;); praseExcel(list); //解析Excel function praseExcel(list) { // sheet循环 for (var i = 0; i &lt; list.length; i++) { var excleData = list[i].data; // body数据 var sheetArray = []; // sheet存储 var typeArray = excleData[1]; // 数据类型 var keyArray = excleData[2]; // 关键字或者属性名 // 开始循环数据内容 for (var j = 3; j &lt; excleData.length ; j++) { var curData = excleData[j]; if(curData.length == 0) continue; var item = changeObj(curData,typeArray,keyArray); sheetArray.push(item); } if(sheetArray.length &gt;0) writeFile(list[i].name+&quot;.json&quot;,JSON.stringify(sheetArray)); } console.log(&quot;qqq&quot;); } //转换数据类型，用对象保存起来 function changeObj(curData,typeArray,keyArray) { var obj = {}; for (var i = 0; i &lt; curData.length; i++) { //字母 obj[keyArray[i]] = changeValue(curData[i],typeArray[i]); } return obj; } function changeValue(value,type) { if(value == null || value ==&quot;null&quot;) return &quot;&quot;; if(type ==&quot;int&quot;) return Math.floor(value); if(type ==&quot;Number&quot;) return value; if(type ==&quot;String&quot;) return value; } //写文件 function writeFile(fileName,data) { fs.writeFile(fileName,data,&apos;utf-8&apos;,complete); function complete(err) { if(!err) { console.log(&quot;文件生成成功&quot;); } } } 这样就将excel转换为有属性的对象了。 THE END！","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"js获取url地址中参数","date":"2017-07-02T10:09:39.000Z","path":"2017/07/02/js获取url地址中参数/","text":"js获取url中地址参数写页面时，常会有需要获取url中参数的需求，以下为常用的一些方法： 1.正则法function getQueryString(name) { var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;); var r = window.location.search.substr(1).match(reg); if (r != null) { return unescape(r[2]); } return null; } console.log(getQueryString(&apos;paramName&apos;)); // 及时查询 2.split拆分法function GetRequest() { var url = location.search; //获取url中&quot;?&quot;符后的字串 var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) { var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) { theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]); } } return theRequest; } // 返回一个参数对象，包含当前url中所有参数 THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"nodejs文件压缩与解压","date":"2017-07-02T09:48:52.000Z","path":"2017/07/02/nodejs文件压缩与解压/","text":"nodejs文件压缩与解压nodejs现在常用比较靠谱的压缩与解压方式，archiver 与 unzip 结合。archiver：https://github.com/ctalkington/node-archiverunzip：https://github.com/EvanOxfeld/node-unzip 以下为基本使用： 文件压缩：npm install archiver --save var fs = require(&apos;fs&apos;) var archiver = require(&apos;archiver&apos;) // 压缩工具 // 注意fs.createWriteStream()会重写整个文件 // 压缩 // 定义输出文件路径及文件名 var output = fs.createWriteStream(&apos;./example.zip&apos;); var archive = archiver(&apos;zip&apos;, { zlib: { level: 9 } // 设置压缩等级 }); // 压缩完毕的回调 output.on(&apos;close&apos;, function() { console.log(archive.pointer() + &apos; total bytes&apos;); console.log(&apos;压缩完毕&apos;); }); // 监听警告 archive.on(&apos;warning&apos;, function(err) { if (err.code === &apos;ENOENT&apos;) { console.log(&apos;warning&apos;) } else { throw err; } }); // 监听错误 archive.on(&apos;error&apos;, function(err) { throw err; }); // 将解压数据添加到写入的文件 archive.pipe(output); // 向archive添加需要压缩的文件 // 打开一个已有文件，并以特定文件名将打开内容保存到压缩文件 // var file1 = &apos;./zip/test1.txt&apos;; // archive.append(fs.createReadStream(file1), { name: &apos;file1.txt&apos; }); // 将字符串添加到压缩文件 // archive.append(&apos;这是字符串内容&apos;, { name: &apos;file2.txt&apos; }); // 将缓冲区内容添加到压缩文件 // var buffer3 = Buffer.from(&apos;buff it!&apos;); // archive.append(buffer3, { name: &apos;file3.txt&apos; }); // 直接添加一个文件 // archive.file(&apos;./zip/test1.txt&apos;, { name: &apos;file4.txt&apos; }); // 添加一个文件夹下所有内容到新命名的文件夹中压缩,注意不要添加输出文件夹，会有小问题 // archive.directory(&apos;./zip/&apos;, &apos;newdirc&apos;); // 添加一个文件夹下所有内容到压缩文件的根目录 archive.directory(&apos;./zip/&apos;, false); // 添加特定匹配模式的文件 // archive.glob(&apos;./zip/*.txt&apos;); // 压缩完成 archive.finalize(); 文件解压：npm install unzip --save var fs = require(&apos;fs&apos;) var unzip = require(&apos;unzip&apos;) // 解压工具 // 直接解压 fs.createReadStream(&apos;./example.zip&apos;).pipe(unzip.Extract({ path: &apos;./unzip/&apos; })); // 可以自定义提取中的事件处理 // var extract = unzip.Extract({ path: &apos;./unzip/&apos; }); // extract.on(&apos;error&apos;, function(err) { // console.log(&quot;error++++++++++++++++++++++&quot;); // console.log(err); // //解压异常处理 // }); // extract.on(&apos;finish&apos;, function() { // console.log(&quot;解压完成!!&quot;); // //解压完成处理 // }); // fs.createReadStream(&apos;./zip/test.zip&apos;).pipe(extract); // // 对每一个解压文件做处理 // fs.createReadStream(&apos;./zip/test.zip&apos;) // .pipe(unzip.Parse()) // .on(&apos;entry&apos;, function(entry) { // 遍历每一个文件 // var fileName = entry.path // 文件名 // var type = entry.type // &apos;Directory&apos; or &apos;File&apos;，表明解压的项是文件夹还是文件 // var size = entry.size // 文件大小 // if (fileName === &quot;test1.txt&quot;) { // entry.pipe(fs.createWriteStream(&apos;./unzip/dest.txt&apos;)); // 读取test.txt中文件内容并copy到目标文件中 // } else { // entry.autodrain(); // 关闭文件读取缓冲，释放内存。 // } // }); 以上两者可以结合起来用，比较靠谱。美中不足的是unzip解压不能解压压缩文件中某个特定的文件，并且在linux环境下unzip去解压windows环境下的压缩包，会出现中文文件名乱码的情况。解决办法为将unzip的parse.js源码中用utf8对文件名解码转换为gbk文件名解码。 THE END!","tags":[{"name":"node","slug":"node","permalink":"https://naliomg.github.io/tags/node/"}]},{"title":"随笔笔记01","date":"2017-06-08T00:55:55.000Z","path":"2017/06/08/随笔笔记01/","text":"随笔笔记011. npm与bower的区别npm 和bower 的最大区别，就是 npm 支持嵌套的依赖管理，而 bower只能支持扁平的依赖（嵌套的依赖，由程序员自己解决）。现在不建议使用bower了。官方已经停止维护，建议直接使用npm就可以了。 2. gulp有无return的区别依据gulp官方文档，gulp的task方法是按最大并发执行的，也就是说所有的task都会同时执行，而对于依赖于其他任务的异步task来说，就需要一个通知来告知该什么时候执行。故需要一个return。 gulp.task(&apos;js&apos;, [&apos;css&apos;], function() { // 做一些事 }); // js这个异步任务就需要css任务执行完毕后给一个提示，可以为如下3种方式 // 1.返回一个stream，就是直接return的方式 gulp.task(&apos;css&apos;, function() { var stream = gulp.src(&apos;client/**/*.css&apos;) .pipe(gulp.dest(&apos;build&apos;)); return stream; }); // 2. 返回一个promise gulp.task(&apos;css&apos;, function() { var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() { deferred.resolve(); }, 1); return deferred.promise; }); // 3. 执行一个回调 gulp.task(&apos;css&apos;, function(cb) { exec(&apos;jekyll build&apos;, function(err) { if (err) return cb(err); // 返回 error cb(); // 完成 task }); });","tags":[{"name":"笔记","slug":"笔记","permalink":"https://naliomg.github.io/tags/笔记/"}]},{"title":"stiky-footer","date":"2017-06-04T02:27:13.000Z","path":"2017/06/04/stiky-footer/","text":"stiky-footer 的实现方式html: &lt;div class=&quot;detail&quot;&gt; &lt;div class=&quot;detail-wrap&quot;&gt; &lt;div class=&quot;detail-main&quot;&gt; &lt;p&gt;123&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;detail-close&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;X&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; less: .detail { position: fixed; top: 0; left: 0; z-index: 2; width: 100%; height: 100%; overflow: auto; .detail-wrap{ box-sizing: border-box; min-height: 100%; padding-top: 64px; padding-bottom: 64px; } .detail-close{ position: relative; width: 32px; height: 32px; margin: -64px auto 0; font-size: 32px; } } DONE!","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"less基本语法","date":"2017-06-02T01:45:12.000Z","path":"2017/06/02/less/","text":"less基本语法编译自动编译软件有很多，sublime、koala都可以，自选。 定义变量变量使用 @test_num: 30px; .test{ width: @test_num; } // 会被编译为： .test{ width: 30px; } 混合样式中嵌套别的样式名，类似class控制 ul{ height: 30px; .mix; } .mix{ border: 1px solid #ddd; } //会被编译为： ul{ height: 30px; border: 1px solid #ddd; } .mix{ border: 1px solid #ddd; } 带参数的混合混合的参数名是只属于当前的混合函数的，可以设置默认值；没有设置默认值的变量不可以缺省，不然会报错。 ul{ height: 30px; .mix(15px); } .mix(@width: 15px){ border: @width solid #ddd; } //会被编译为： ul{ height: 30px; border: 15px solid #ddd; } 匹配模式类似于switch函数，可以加载传入的参数的某类css样式。若没有匹配到值，则对应语句解析为空,sublime插件会报错。 .test_pipei(red){ color: red; } .test_pipei(green){ color: green; } .test{ .test_pipei(red); } // 以上代码会解析为： .test{ color: red; } // 若 .test{.test_pipei(green)} 则会解析为 .test{color:green} 运算可以对数值及变量进行基础运算，颜色也可以计算不过不常用。 @num: 300px; .test{ width: @num + 20; } // 以上代码会解析为： .test{ width: 320px; } 嵌套规则对相应的html结构进行嵌套的css书写。“&amp;”代表上一层选择器。 // html结构 &lt;ul class=&quot;test&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; // less嵌套语法 .test{ background-color: #eee; li{ background-color: #ddd; a{ display: inline-block; background-color: #ccc; &amp;:hover{ color: red; } } } &amp;nali:{ margin-top: 10px; } } // 以上代码解析为: .test { background-color: #eee } .test li { list-style: none; background-color: #ddd } .test li a { display: inline-block; background-color: #ccc } .test li a:hover { color: red } .testnali { margin-top: 10px } @arguments变量用于全部的参数的直接使用。使用比较少。 .border_arg(@w: 30px, @c: red, @xx: solid){ border: @arguments; } 避免编译有时需要输出不用less编译或者less不认识的语句，就需要less对这些语句不做处理。 // ~&quot;words&quot; 引号内的语句将不会被less解析 .test{ width: ~&quot;calc(30px + 20px)&quot;; } 变量与字符串拼接在less中定义好路径变量对路径迁移是一件非常重要的事情，所以定义路径变量非常有必要，此处就会用到路径变量与字符串之间的拼接问题。 @iconUrl: &quot;/img&quot;; // mixin .c-icon(@bgImg) { background-image: url(@bgImg); } .bg { @someImgUrl: &quot;/icon.png&quot;; // call mixin .c-icon(); .c-icon(&quot;@{iconUrl}@{someImgUrl}&quot;); // or below // .c-icon(&quot;@{iconUrl}/icon.png&quot;); } important在混合的样式后面加入 !important 后，该样式下的全部样式都不被添加上 !important ，用处不大，一般用于调试。 .test{ .test_detail !important; } .test_detail{ width: 120px; height: 50px; } // 以上代码会被编译为 .test { width: 120px!important; height: 50px!important } .test_detail { width: 120px; height: 50px } vue组件中使用less语法，需要安装less依赖以及将 &lt; &lt;style lang=&quot;less&quot;&gt;&lt;/style&gt; 的语言指定为less。THE END!","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"ios下js中newDate的坑","date":"2017-03-06T05:24:11.000Z","path":"2017/03/06/ios下js中newDate的坑/","text":"ios下js中 new Date() 的坑ios中safari竟然不支持yyyy-mm-dd的日期格式，所以当你输入如下语句时，会返回空的时间。 new Date(&apos;2016-05-17&apos;); // Invalid Time Safari支持的格式是yyyy/mm/dd这样的，差别主要在于短横”-“与斜杠”/“，而斜杠这样的格式在其他常见的浏览器中也都是可以正常运行的，所以只需要都换成斜杠就可以了，转换函数如下所示： new Date(&apos;2016-05-17&apos;.replace(/-/g, &quot;/&quot;)); // 坑的ios总算认识了 THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"浏览器sessionid变化情况","date":"2017-02-27T08:39:55.000Z","path":"2017/02/27/浏览器sessionid变化/","text":"浏览器sessionid变化情况浏览器中sessionid一般不会因为浏览器标签页的开关而变化，是存储于浏览器内存中的。不同的域名，浏览器会存储不同的sessionid；但相同的域名不同的端口，浏览器会认为是同一地址，更新sessionid！！！ THE END!","tags":[{"name":"其他","slug":"其他","permalink":"https://naliomg.github.io/tags/其他/"}]},{"title":"网站从输入地址到展示基本简单过程","date":"2017-02-17T09:22:13.000Z","path":"2017/02/17/网站从输入地址到展示基本简单过程/","text":"网站从输入地址到展示基本简单过程 用户操作浏览器访问，浏览器向服务器发出一个 HTTP 请求； 服务器接收到 HTTP 请求，Web Server 进行相应的初步处理，使用服务器脚本生成页面； 服务器脚本（利用Web Framework）调用本地和客户端传来的数据，生成页面； Web Server 将生成的页面作为 HTTP 响应的 body，根据不同的处理结果生成 HTTP header，发回给客户端； 客户端（浏览器）接收到 HTTP 响应，通常第一个请求得到的 HTTP 响应的 body 里是 HTML 代码，于是对 HTML 代码开始解析；解析过程中遇到引用的服务器上的资源（额外的 CSS、JS代码，图片、音视频，附件等），再向 Web Server 发送请求，Web Server 找到对应的文件，发送回来； 浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步渲染，JS 代码也可能会对外观进行一定的处理； 用户与页面交互（点击，悬停等等）时，JS 代码对此作出一定的反应，添加特效与动画； 交互的过程中可能需要向服务器索取或提交额外的数据（局部的刷新，类似微博的新消息通知），一般不是跳转就是通过 JS 代码（响应某个动作或者定时）向 Web Server 发送请求，Web Server 再用服务器脚本进行处理（生成资源or写入数据之类的），把资源返回给客户端，客户端用得到的资源来实现动态效果或其他改变。","tags":[{"name":"网络","slug":"网络","permalink":"https://naliomg.github.io/tags/网络/"}]},{"title":"cache存储常用方法","date":"2017-01-14T13:40:52.000Z","path":"2017/01/14/cache存储常用方法/","text":"cache 存储常用方法/** * [设置cookie] * @param {[string]} key [键] * @param {[string]} value [值] * @param {[number]} t [过期时间(天)] */ function setCookie(key, value, t) { var oDate = new Date(); oDate.setDate(oDate.getDate() + t); document.cookie = key + &quot;=&quot; + value + &quot;;expires=&quot; + oDate.toGMTString(); } /** * [读取cookie] * @param {[string]} key [键] * @return {[type]} [description] */ function getCookie(key) { var arr1 = document.cookie.split(&quot;; &quot;); for (var i = 0; i &lt; arr1.length; i++) { var arr2 = arr1[i].split(&quot;=&quot;); if (arr2[0] == key) { return decodeURI(arr2[1]); } } } /** * [删除cookie] * @param {[string]} key [键] * @return {[type]} [description] */ function removeCookie(key) { myJsPag.setCookie(key, &quot;&quot;, -1); }","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"原生JS封装Ajax方法","date":"2017-01-14T13:27:11.000Z","path":"2017/01/14/原生JS封装Ajax方法/","text":"原生JS封装Ajax方法/** * [ajax description] * @param {[json]} opt [参数设置] * @return {[type]} [description] option设置： { method: &apos;GET&apos;, url: &apos;1.txt&apos;, responseType:&apos;xml/json&apos;, data: { name1:&apos;value1&apos;, name2:&apos;value2&apos; }, success: function (response) { alert(response); } } */ function ajax(opt) { // 参数初始化 opt = opt || {}; opt.method = opt.method.toUpperCase() || &apos;POST&apos;; opt.url = opt.url || &apos;&apos;; opt.async = opt.async || true; opt.responseType = opt.responseType || &apos;&apos;; opt.data = opt.data || null; opt.success = opt.success || function() {}; // 创建httpRequest var xmlHttp = createXHR(); // 向服务器传递的参数存放在params var params = []; for (var key in opt.data) { params.push(key + &apos;=&apos; + opt.data[key]); } var postData = params.join(&apos;&amp;&apos;); // 对请求做相应处理并发送 if (opt.method.toUpperCase() === &apos;POST&apos;) { xmlHttp.open(opt.method, opt.url, opt.async); xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;); xmlHttp.send(postData); } else if (opt.method.toUpperCase() === &apos;GET&apos;) { xmlHttp.open(opt.method, opt.url + &apos;?&apos; + postData + &apos;&amp;&apos; + Math.random(), opt.async); xmlHttp.send(null); } // 监听请求状态 xmlHttp.onreadystatechange = function() { if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) { if (opt.responseType == &apos;json&apos;) { var responseData = JSON.parse(xmlHttp.responseText); } else if (opt.responseType == &apos;xml&apos;) { var responseData = xmlHttp.responseXML; } else { var responseData = xmlHttp.responseText; } opt.success(responseData); } }; // 创建request请求方法 function createXHR() { var xmlHttp; try { xmlHttp = new XMLHttpRequest(); } catch (e) { try { xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e) { try { xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e) { alert(&quot;您的浏览器不支持AJAX！&quot;); return false; } } } return xmlHttp; } }","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"localStorage","date":"2017-01-14T09:57:54.000Z","path":"2017/01/14/localStorage/","text":"localStorage 的使用与说明HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 localStorage和sessionStorage均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。 localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。 sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 localStorage 和 sessionStorage 使用时使用相同的API： localStorage.setItem(&quot;key&quot;,&quot;value&quot;);//以“key”为名称存储一个值“value” localStorage[&quot;key&quot;] = &quot;value&quot;;//以“key”为名称存储一个值“value” localStorage.getItem(&quot;key&quot;);//获取名称为“key”的值 var item = localStorage[&quot;key&quot;];//获取名称为“key”的值 localStorage.removeItem(&quot;key&quot;);//删除名称为“key”的信息。 localStorage.clear();​//清空localStorage中所有信息 将上述的 localStorage 换成 sessionStorage 即为 sessionStorage 的用法。 THE END！","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"国内公共cdn资源库","date":"2017-01-06T04:34:44.000Z","path":"2017/01/06/国内公共资源库/","text":"国内公共cdn资源库 新浪 http://lib.sinaapp.com/ 微软 http://ajax.aspnetcdn.com/ jQuery http://code.jquery.com/ Staticfile https://www.staticfile.org/ (推荐) 百度 http://cdn.code.baidu.com/ 当然，用别人的 CDN 都是不保险的，所以建议在 CDN 读取失败的时候从自己服务器提供： &lt;script src=&quot;//http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; if (!window.jQuery) { var script = document.createElement(&apos;script&apos;); script.src = &quot;/js/jquery.min.js&quot;; document.body.appendChild(script); } &lt;/script&gt;","tags":[{"name":"cdn","slug":"cdn","permalink":"https://naliomg.github.io/tags/cdn/"}]},{"title":"常用正则验证表达式","date":"2017-01-03T15:16:25.000Z","path":"2017/01/03/window.location属性/","text":"window.location属性url: https://www.baidu.com:8080/nali#test?k=123 hash 设置或返回从井号 (#) 开始的 URL（锚）。host 设置或返回主机名和当前 URL 的端口号。hostname 设置或返回当前 URL 的主机名。href 设置或返回完整的 URL。pathname 设置或返回当前 URL 的路径部分。port 设置或返回当前 URL 的端口号。protocol 设置或返回当前 URL 的协议。search 设置或返回从问号 (?) 开始的 URL（查询部分）。 assign() 加载新的文档。reload() 重新加载当前文档。replace() 用新的文档替换当前文档。 Location 对象描述Location 对象存储在 Window 对象的 Location 属性中，表示那个窗口中当前显示的文档的 Web 地址。它的 href 属性存放的是文档的完整 URL，其他属性则分别描述了 URL 的各个部分。这些属性与 Anchor 对象（或 Area 对象）的 URL 属性非常相似。当一个 Location 对象被转换成字符串，href 属性的值被返回。这意味着你可以使用表达式 location 来替代 location.href。不过 Anchor 对象表示的是文档中的超链接，Location 对象表示的却是浏览器当前显示的文档的 URL（或位置）。但是 Location 对象所能做的远远不止这些，它还能控制浏览器显示的文档的位置。如果把一个含有 URL 的字符串赋予 Location 对象或它的 href 属性，浏览器就会把新的 URL 所指的文档装载进来，并显示出来。除了设置 location 或 location.href 用完整的 URL 替换当前的 URL 之外，还可以修改部分 URL，只需要给 Location 对象的其他属性赋值即可。这样做就会创建新的 URL，其中的一部分与原来的 URL 不同，浏览器会将它装载并显示出来。例如，假设设置了Location对象的 hash 属性，那么浏览器就会转移到当前文档中的一个指定的位置。同样，如果设置了 search 属性，那么浏览器就会重新装载附加了新的查询字符串的 URL。除了 URL 属性外，Location 对象的 reload() 方法可以重新装载当前文档，replace() 可以装载一个新文档而无须为它创建一个新的历史记录，也就是说，在浏览器的历史列表中，新文档将替换当前文档。","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"字符关系操作","date":"2017-01-02T15:33:46.000Z","path":"2017/01/02/字符关系操作/","text":"字符关系操作//操作符字符串的隐性转换 test//乘法 console.dir(&quot;-------以下乘法---------&quot;); console.dir(5*&quot;5&quot;); console.dir(5*&quot;a&quot;); console.dir(5*NaN); console.dir(5*null); console.dir(5*undefined); console.dir(5*5); console.dir(&quot;-------以上乘法---------&quot;); //除法 console.dir(&quot;-------以下除法---------&quot;); console.dir(5/&quot;5&quot;); console.dir(5/&quot;a&quot;); console.dir(5/NaN); console.dir(5/null); console.dir(null/5); console.dir(5/undefined); console.dir(5/5); console.dir(5/0); console.dir(0/5); console.dir(0/0); console.dir(&quot;-------以上除法---------&quot;); //取余、求模 console.dir(&quot;-------以下取余、求模--------&quot;); console.dir(16%&quot;5&quot;); console.dir(5%&quot;a&quot;); console.dir(5%NaN); console.dir(5%null); console.dir(null%5); console.dir(5%undefined); console.dir(5%5); console.dir(5%0); console.dir(0%5); console.dir(0%0); console.dir(&quot;-------以上取余、求模---------&quot;); //加法 console.dir(&quot;-------以下加法--------&quot;); console.dir(16+&quot;5&quot;); console.dir(5+&quot;a&quot;); console.dir(5+NaN); console.dir(5+null); console.dir(5+undefined); console.dir(5+5); console.dir(&quot;两个数的和是&quot;+5+5); console.dir(&quot;两个数的和是&quot;+(5+5)); console.dir(&quot;-------以上加法--------&quot;); //减法 console.dir(&quot;-------以下减法--------&quot;); console.dir(16-&quot;5&quot;); console.dir(5-&quot;a&quot;); console.dir(5-NaN); console.dir(5-null); console.dir(5-undefined); console.dir(5-5); console.dir(5-true); console.dir(5-&quot;true&quot;); console.dir(5-&quot;&quot;); console.dir(&quot;两个数的差是&quot;+5-5); console.dir(&quot;两个数的差是&quot;+(5-5)); console.dir(&quot;-------以上减法--------&quot;); //关系操作符 console.dir(&quot;-------以下关系操作符--------&quot;); console.dir(16&gt;&quot;5&quot;); console.dir(&quot;16&quot;&gt;&quot;5&quot;); console.dir(5&lt;&quot;a&quot;); console.dir(5&gt;=NaN); console.dir(5&lt;NaN); console.dir(NaN&gt;=NaN); console.dir(5&gt;=null); console.dir(5&gt;=undefined); console.dir(5&gt;=5); console.dir(5&gt;=true); console.dir(5&gt;=&quot;true&quot;); console.dir(5&gt;=&quot;&quot;); console.dir(&quot;Brick&quot;&gt;&quot;alphabet&quot;); console.dir(&quot;brick&quot;&gt;&quot;alphabet&quot;); console.dir(&quot;-------以上关系操作符--------&quot;); answers//乘法 console.dir(5*&quot;5&quot;); //25 console.dir(5*&quot;a&quot;);//NaN console.dir(5*NaN);//NaN console.dir(5*null);0 console.dir(5*undefined);//NaN console.dir(5*5);//25 //除法 console.dir(5/&quot;5&quot;);//1 将字符转化为数字进行相除 console.dir(5/&quot;a&quot;);//NaN 将“a”用Number()函数进行转化，出来的值是NaN，结果就是NaN console.dir(5/NaN);//NaN console.dir(5/null);//Infinity null用Number()函数进行转化，结果是0，那么5/0是正无穷 console.dir(null/5);//0 同上0/5是0 console.dir(5/undefined);//NaN undefined 用Number()进行转化，结果是NaN console.dir(5/5);//1 console.dir(5/0);//Infinity console.dir(0/5);//0 console.dir(0/0);//NaN //0除以0结果是NaN //取模 console.dir(16%&quot;5&quot;); //1 将字符串5通过Number()转化为5然后进行求余 console.dir(5%&quot;a&quot;);//NaN console.dir(5%NaN);//NaN console.dir(5%null);//NaN 将null 通过Number()转化，结果是0，然后计算5%0 ，结果是NaN console.dir(null%5);//0 同上0%5 取余，结果是0 console.dir(5%undefined);//NaN console.dir(5%5);//0 console.dir(5%0);//NaN console.dir(0%5);//0 console.dir(0%0);//NaN console.dir(Infinity%Infinity);//NaN console.dir(5%Infinity);//5 console.dir(Infinity%5); //NaN //减法 console.dir(16-&quot;5&quot;);//11 console.dir(5-&quot;a&quot;);//NaN console.dir(5-NaN);//NaN console.dir(5-null);//5 console.dir(5-undefined);//NaN console.dir(5-5);//0 console.dir(5-true);//4 console.dir(5-&quot;true&quot;);//NaN console.dir(5-&quot;&quot;);//5 console.dir(5-Infinity);//-Infinity console.dir(Infinity-Infinity);//NaN console.dir(&quot;两个数的差是&quot;+5-5);//NaN console.dir(&quot;两个数的差是&quot;+(5-5));//两个数的差是0 //关系操作符 console.dir(16&gt;&quot;5&quot;); //true console.dir(&quot;16&quot;&gt;&quot;5&quot;);//false console.dir(5&lt;&quot;a&quot;);//false console.dir(5&gt;=NaN);//false console.dir(5&lt;NaN);//false console.dir(NaN&gt;=NaN);//false console.dir(5&gt;=null);//true console.dir(5&gt;=undefined);//false console.dir(5&gt;=5);//true console.dir(5&gt;=true);//true console.dir(5&gt;=&quot;true&quot;);//false console.dir(5&gt;=&quot;&quot;);//true console.dir(&quot;Brick&quot;&gt;&quot;alphabet&quot;);//false B的字符串编码值是66 ，而a的字符串编码是97.因此false console.dir(&quot;brick&quot;&gt;&quot;alphabet&quot;);//true 小写字母b比a大，所以是true //加法 console.dir(16+&quot;5&quot;); //156 console.dir(5+&quot;a&quot;);//5a console.dir(5+NaN);//NaN console.dir(5+null);//5 console.dir(&apos;5&apos;+null);//5null console.dir(5+undefined);//NaN console.dir(null+undefined);//NaN console.dir(5+5);//10 console.dir(&quot;两个数的和是&quot;+5+5);//两个数的和是55 console.dir(&quot;两个数的和是&quot;+(5+5));//两个数的和是10","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"关于显示内容高度与宽度问题","date":"2017-01-02T15:27:01.000Z","path":"2017/01/02/关于显示内容高度与宽度问题/","text":"关于显示内容高度与宽度问题网页可见区域宽： document .body.clientWidth;网页可见区域高： document .body.clientHeight;网页可见区域宽： document .body.offsetWidth (包括边线的宽);网页可见区域高： document .body.offsetHeight (包括边线的宽);网页正文全文宽： document .body.scrollWidth;网页正文全文高： document .body.scrollHeight;网页被卷去的高： document .body.scrollTop;网页被卷去的左： document .body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度：window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth; scrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX: 相对文档的水平座标event.clientY: 相对文档的垂直座标 event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标document.documentElement.scrollTop 垂直方向滚动的值event.clientX+document.documentElement.scrollTop相对文档的水平座标+垂直方向滚动的量 要获取当前页面的滚动条纵坐标位置，用：document .documentElement.scrollTop;而不是：document .body.scrollTop;documentElement 对应的是 html 标签，而 body 对应的是 body 标签。 在标准w3c下，document .body.scrollTop恒为0，需要用document .documentElement.scrollTop来代替;如果你想定位鼠标相对于页面的绝对位置时，你会发现google里面1000篇文章里面有999.99篇会让你使用event.clientX+document.body.scrollLeft，event.clientY+document .body.scrollTop，如果你发现你的鼠标定位偏离了你的想象，请不要奇怪，这是再正常不过的事情。ie5.5之后已经不支持document .body.scrollX对象了。所以在编程的时候，请加上这样的判断 if (document .body &amp;&amp; document .body.scrollTop &amp;&amp; document .body.scrollLeft) { top=document .body.scrollTop; left=document .body.scrollleft; } if (document .documentElement &amp;&amp; document .documentElement.scrollTop &amp;&amp; document .documentElement.scrollLeft) { top=document .documentElement.scrollTop; left=document .documentElement.scrollLeft; }","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"常用正则验证表达式","date":"2017-01-02T15:16:25.000Z","path":"2017/01/02/常用正则验证表达式/","text":"常用正则验证表达式匹配中文字符的正则表达式：[u4e00-u9fa5] 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 匹配双字节字符(包括汉字在内)：[^x00-xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：ns*r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^s*|s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 评注：表单验证时很实用 匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配国内电话号码：d{3}-d{8}|d{4}-d{7} 评注：匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,} 评注：腾讯QQ号从10000开始 匹配中国邮政编码：[1-9]d{5}(?!d) 评注：中国邮政编码为6位数字 匹配身份证：d{15}|d{18} 评注：中国的身份证为15位或18位 匹配ip地址：d+.d+.d+.d+ 评注：提取ip地址时有用 匹配特定数字：^[1-9]d*$ //匹配正整数 ^-[1-9]d*$ //匹配负整数 ^-?[1-9]d*$ //匹配整数 ^[1-9]d*|0$ //匹配非负整数（正整数 + 0） ^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） ^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 ^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） 评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串：^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 ^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 ^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 输入验证：只能输入数字：“^[0-9]*$” 只能输入n位的数字：“^d{n}$” 只能输入至少n位数字：“^d{n,}$” 只能输入m-n位的数字：“^d{m,n}$” 只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” 只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” 只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” 只能输入非零的正整数：“^+?[1-9][0-9]*$” 只能输入非零的负整数：“^-[1-9][0-9]*$” 只能输入长度为3的字符：“^.{3}$” 只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” 只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” 只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” 只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” 只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” 其他验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， 只能包含字符、数字和下划线。 验证是否含有^%&amp;&apos;&apos;,;=?$&quot;等字符：“[^%&amp;&apos;&apos;,;=?$x22]+” 只能输入汉字：“^[u4e00-u9fa5],{0,}$” 验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” 验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” 验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” 正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， “XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 验证身份证号（15位或18位数字）：“^d{15}|d{}18$” 验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” 验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” 正确格式为：“01”“09”和“1”“31”。 匹配中文字符的正则表达式： [u4e00-u9fa5] 匹配双字节字符(包括汉字在内)：[^x00-xff] 匹配空行的正则表达式：n[s| ]*r 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*|&lt;(.*) /&gt;/ 匹配首尾空格的正则表达式：(^s*)|(s*$) 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?*/","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"伪类与伪元素区别","date":"2017-01-01T03:45:31.000Z","path":"2017/01/01/伪类与伪元素区别/","text":"伪类与伪元素的区别伪类：用于向某些选择器添加特殊的效果。伪元素：用于向某些选择器内部的内容添加特殊效果。 伪类种类:active //将样式添加到被激活的元素 :focus //将样式添加到获得焦点的元素 :hover //当鼠标悬浮在元素上方时，向元素添加样式 :link //将样式添加到未被访问的链接 :visited //将样式添加到被访问过的链接 :first-child //将样式添加到元素的第一个子元素，记住，这个为伪类！！！ :lang //允许创作者来定义指定的元素中使用的语言 伪元素种类::first-letter //将样式添加到元素的文本首字母，只对块级元素有用 ::first-line //将样式添加到元素的文本首行，只对块级元素有用 ::before //在元素之前插入某些内容 ::after //在元素之后插入某些内容 区别这里用伪类:first-child和伪元素::first-letter来进行比较。 p&gt;i:first-child {color: red} &lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt; &lt;/p&gt; first单词会变为红色。 p:first-letter {color: red} &lt;p&gt;I am stephen lee.&lt;/p&gt; 字母 I 会变为红色。 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。 伪元素和伪类之所以这么容易混淆，是因为他们的效果类似而且写法相仿，但实际上 css3 为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 但因为兼容性的问题（IE从9开始才支持双冒号伪元素写法），所以现在大部分还是统一的单冒号，但是抛开兼容性的问题，我们在书写时应该尽可能养成好习惯，区分两者。 THE END. 本文摘自：https://segmentfault.com/a/1190000000484493","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"清除浮动的几种方法","date":"2017-01-01T02:12:53.000Z","path":"2017/01/01/清除浮动的几种方法/","text":"清除浮动的几种常见方法1.clear方法.child{clear：both;} 适用于浮动元素后面容器之内有个非浮动元素，或是额外添加一个新的空元素。设置了clear 属性的元素，其上边框位置会紧贴浮动元素的 margin-bottom 边界位置渲染，使包含浮动元素的容器高度正常。 2.伪类添加新元素.parent::after{content:&quot;&quot;; display:block; clear:both;} 只适用于父容器最后一级子元素是浮动的，即浮动元素后面没有非浮动元素把它和父容器隔开。IE6/7不支持:after 伪元素。原理同上。 3.overflow:hidden/auto方法.parent{overflow:hidden;} .parent{overflow:auto;} 创建了overflow 样式值为非visilbe的元素，实际上是创建了 CSS 2.1 规范定义的 Block Formatting Contexts，会重新计算其内部元素位置，从而获得确切高度。这样父容器也就包含了浮动元素高度。这个名词过于晦涩，在 CSS 3 草案中被变更为名词 Root Flow，顾名思义，是创建了一个新的根布局流，这个布局流是独立的，不影响其外部元素的。测试时当子元素同时混有浮动元素和非浮动元素时效果并不好。IE6/7 中并不被支持。 4.display:table/table-cell方法.parent{display:table;} .parent{display:table-cell;} 当元素 display 值被设定为 table 或 table-cell 时，同样也创建了 CSS 2.1 规范定义的 Block Formatting Contexts。这样父容器也就包含了浮动元素高度。IE6/7 中并不被支持。 5.使用表格类元素作为浮动元素容器把浮动元素匡在td里就木有浮动问题，而且木有兼容问题。当使用 TABLE TD TH 等 TABLE 系列标签时， 元素的 display 值实际上说是 display: table 系列，这同样也创建了 CSS 2.1 规范定义的 Block Formatting Contexts。这样父容器也就包含了浮动元素高度。同时在 IE 6/7 中，TABLE TD TH 等 TABLE 系列标签天然拥有 haslayout 特性。 6.浮动父元素虽然这种方式并没有兼容问题，但实际使用中并不推荐。因为很容易推断出，页面中只要有一个浮动元素，使用该方法清理浮动将不可避免的使页面所有元素都浮动才可以达到预期效果。 7.触发 hasLayout‘Layout’ 是 IE 的专有概念，它决定了元素如何对其内容进行定位和尺寸计算，与其他元素的关系和相互作用，以及对应用还有使用者的影响。‘Layout’ 可以被某些 CSS property（特性）不可逆的触发，而某些 HTML 元素本身就具有 layout 。‘Layout’ 在 IE 中可以通过 hasLayout 属性来判断一个元素是否拥有 layout ，如 object.currentStyle.hasLayout。‘Layout’ 是 IE 浏览器渲染引擎的一个内部组成部分。在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容。为了协调这两种方式的矛盾，渲染引擎采用了 ‘hasLayout’ 属性，属性值可以为 true 或 false。 当一个元素的 ‘hasLayout’ 属性值为 true 时，我们说这个元素有一个布局（layout），或拥有布局。 //常见触发 hasLayout 的 CSS： .haslayout-clear-float:{width:1px} .haslayout-clear-float:{height:1px} .haslayout-clear-float:{zoom:1} //默认拥有布局的元素： &lt;html&gt;, &lt;body&gt; &lt;table&gt;, &lt;tr&gt;, &lt;th&gt;, &lt;td&gt; &lt;img&gt; &lt;hr&gt; &lt;input&gt;, &lt;button&gt;, &lt;select&gt;, &lt;textarea&gt;, &lt;fieldset&gt;, &lt;legend&gt; &lt;iframe&gt;, &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt; &lt;marquee&gt; IE7 还有一些额外的属性(不完全列表)可以触发 hasLayout ： min-height: (任意值) min-width: (任意值) max-height: (除 none 外任意值) max-width: (除 none 外任意值) overflow: (除 visible 外任意值，仅用于块级元素) overflow-x: (除 visible 外任意值，仅用于块级元素) overflow-y: (除 visible 外任意值，仅用于块级元素) position: fixed IE6 以前的版本（也包括 IE6 及以后所有版本的混杂模式，其实这种混杂模式在渲染方面就相当于 IE 5.5）， 通过设置任何元素的 ‘width’ 或 ‘height’（非auto）都可以触发 hasLayout ； 但在 IE6 和 IE7 的标准模式中的行内元素上却不行，设置 ‘display:inline-block’ 才可以。 注意兼容问题：haslayout 特性仅 IE 支持，其他浏览器并无此特性。可以依靠计算布局清理浮动的 haslayout 特性仅在 IE 6/7 中存在，IE8 之后将使用 CSS 2.1 的 Block Formatting Contexts 定义来达到同样效果。 使用推荐：.clearfix{zoom:1;} .clearfix::before,.clearfix::after{content:&quot;&quot;;display:block;clear:both;} THE END.","tags":[{"name":"css","slug":"css","permalink":"https://naliomg.github.io/tags/css/"}]},{"title":"js遍历二叉树","date":"2016-12-31T13:16:50.000Z","path":"2016/12/31/js遍历树/","text":"javascript遍历二叉树本文记录JavaScript对二叉树的一些常见遍历算法。以下为一个二叉树的模拟结构： var tree = { value: 1, left: { value: 2, left: { value: 4 } }, right: { value: 3, left: { value: 5, left: { value: 7 }, right: { value: 8 } }, right: { value: 6 } } }; 对一个树的遍历分为先序遍历、中序遍历和后序遍历。若以以下表示顺序法： D：访问根结点，L：遍历根结点的左子树，R：遍历根结点的右子树表示遍历顺序的话，先序遍历：以从上到下，从左到右的顺序遍历；(DLR)中序遍历：以从下到上，从左到右的顺序遍历；(LDR)后序遍历：以从左到右，从下到上的顺序遍历；(LRD)以上遍历均为 深度优先遍历 ，还有一种为 广度优先遍历。 广度优先遍历：是以树的层级为遍历的原则的，首选从上到下遍历层，遍历层时以从左到右的原则将个整层遍历完后才会遍历下一个层级。 以下为代码实现： 广度优先遍历：首先将根节点归入队列。当队列不为空的时候，执行循环：取出队列的一个节点，如果该结点的左子树为非空，则将该结点的左子树入队列；如果该结点的右子树为非空，则将该结点的右子树入队列。其实就是把节点以队列的形式存放，抛出先存放的节点，获取其子节点存入队列，这样便实现了以层的形式去遍历。若不是二叉树而是树，则需要遍历该节点下的亲子节点存入队列，就可以实现对树的遍历 var levelOrderTraversal = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var que = []; que.push(node); while(que.length !== 0) { node = que.shift(); console.log(node.value); if(node.left) que.push(node.left); if(node.right) que.push(node.right); } } 递归深度优先遍历根据遍历时，所执行的输出顺序不同实现。 先序递归遍历：var preOrder = function (node) { if (node) { console.log(node.value); preOrder(node.left); preOrder(node.right); } } 中序递归遍历var inOrder = function (node) { if (node) { inOrder(node.left); console.log(node.value); inOrder(node.right); } } 后序递归遍历var postOrder = function (node) { if (node) { postOrder(node.left); postOrder(node.right); console.log(node.value); } } 非递归深度优先遍历非递归先序遍历：这种方法与广度优先遍历很相似，只是将 队列 的方式改为了 栈 的形式，一个是先入先出，一个是后入先出原则。 var preOrderUnRecur = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var stack = []; stack.push(node); while(stack.length !== 0) { node = stack.pop(); console.log(node.value); if(node.right) stack.push(node.right); if(node.left) stack.push(node.left); } } 非递归中序遍历：var inOrderUnRecur = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var stack = []; while(stack.length !== 0 || node) { if(node) { stack.push(node); node = node.left; } else { node = stack.pop(); console.log(node.value); node = node.right; } } } 非递归后序遍历：var posOrderUnRecur = function(node) { if(!node) { throw new Error(&apos;Empty Tree&apos;); } var stack = []; stack.push(node); var tmp = null; while(stack.length !== 0) { tmp = stack[stack.length - 1]; if(tmp.left &amp;&amp; node !== tmp.left &amp;&amp; node !== tmp.right) { stack.push(tmp.left); } else if(tmp.right &amp;&amp; node !== tmp.right) { stack.push(tmp.right); } else { console.log(stack.pop().value); node = tmp; } } } 另外一种方法: var posOrderUnRecur = function(node) { if(node) { var s1 = []; var s2 = []; s1.push(node); while(s1.length !== 0) { node = s1.pop(); s2.push(node); if(node.left) { s1.push(node.left); } if(node.right) { s1.push(node.right); } } while(s2.length !== 0) { console.log(s2.pop().value); } } } Morris遍历这个方法即不用递归也不用栈实现三种深度遍历，空间复杂度为O(1)。 Morris先序:var morrisPre = function(head) { if(!head) { return; } var cur1 = head; var cur2 = null; while(cur1) { cur2 = cur1.left; if(cur2) { while(cur2.right &amp;&amp; cur2.right != cur1) { cur2 = cur2.right; } if(!cur2.right) { cur2.right = cur1; console.log(cur1.value); cur1 = cur1.left; continue; } else { cur2.right = null; } } else { console.log(cur1.value); } cur1 = cur1.right; } } Morris中序:var morrisIn = function(head) { if(!head) { return; } var cur1 = head; var cur2 = null; while(cur1) { cur2 = cur1.left; if(cur2) { while(cur2.right &amp;&amp; cur2.right !== cur1) { cur2 = cur2.right; } if(!cur2.right) { cur2.right = cur1; cur1 = cur1.left; continue; } else { cur2.right = null; } } console.log(cur1.value); cur1 = cur1.right; } } Morris后序:var morrisPost = function(head) { if(!head) { return; } var cur1 = head; var cur2 = null; while(cur1) { cur2 = cur1.left; if(cur2) { while(cur2.right &amp;&amp; cur2.right !== cur1) { cur2 = cur2.right; } if(!cur2.right) { cur2.right = cur1; cur1 = cur1.left; continue; } else { cur2.right = null; printEdge(cur1.left); } } cur1 = cur1.right; } printEdge(head); } var printEdge = function(head) { var tail = reverseEdge(head); var cur = tail; while(cur) { console.log(cur.value); cur = cur.right; } reverseEdge(tail); } var reverseEdge = function(head) { var pre = null; var next = null; while(head) { next = head.right; head.right = pre; pre = head; head = next; } return pre; } 本文摘自：https://segmentfault.com/a/1190000004620352","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"gulp简介及基本用法","date":"2016-12-30T13:40:36.000Z","path":"2016/12/30/gulp简介及基本用法/","text":"gulp简介及基本用法基本操作 全局安装：npm install --global gulp 作为项目的开发依赖（devDependencies）安装：npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 1234var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp：gulp,只书写gulp的话只会执行default的任务，要执行其他任务，可以输入gulp &lt;task&gt; &lt;othertask&gt; 官方文档http://www.gulpjs.com.cn/docs/api/ API简单介绍gulp的方法只有5个：gulp.src() // 设置处理文件的路径gulp.dest() // 设置处理后的文件存放路径gulp.task() // 任务定义gulp.pipe() // 处理管道运行gulp.watch() // 文件监听 1. gulp.src(globs[,options])输出符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。目前常用为直接写文件路径。 gulp.task(&apos;image&apos;, function() { gulp.src(&apos;src/img/**/*.*&apos;) // src/img目录下的所有文件 .pipe(gulp.dest(&apos;dist/img&apos;)); // 存放到dist/img目录下 }); 2. gulp.dest(path[, options])将src匹配并处理后pipe过来的文件写到指定文件，也可以将它 pipe 到多个文件夹。如果某文件夹不存在，将会自动创建它。path为文件存放路径。也可以传入一个函数，在函数中返回相应路径。 gulp.task(&apos;image&apos;, function() { gulp.src(&apos;src/img/**/*.*&apos;) // src/img目录下的所有文件 .pipe(gulp.dest(&apos;dist/img&apos;)) // 存放到dist/img目录下 .pipe(gulp.dest(&apos;test/&apos;)); // 再存放一份到test/目录 }); 3. gulp.task(name[, deps], fn)gulp.task(&apos;somename&apos;, function() { // 做一些事 }); 定义一个执行任务。name:任务的名字，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。deps:类型:Array,非必须，一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。依赖的异步任务必须要有异步执行方式：使用一个 callback，或者返回一个 promise 或 stream来通知主任务，前面的依赖任务已完成gulp的task任务是按最大并发执行的，也就是全部同时执行。 gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() { // 做一些事 }); // 常见的异步方式为返回一个stream，如下return gulp.task(&apos;array&apos;, function() { return gulp.src(&apos;*.*&apos;) .pipe(gulp.dest(&apos;test/&apos;)); }) fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。 4. gulp.src().pipe()任务的数据传递方法，将上一个插件处理后的文件数据传往下一个处理插件。 5. gulp.watch(glob[, opts], tasks)监视文件，并且可以在文件发生改动时候做一些事情。glob:一个 glob 字符串，或者一个包含多个 glob 字符串的数组，用来指定具体监控哪些文件的变动,常使用文件路径。opts：传给 gaze 的参数。不常用。tasks：类型：Array，需要在文件变动后执行的一个或者多个通过 gulp.task() 创建的 task 的名字。 gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); // 当指定文件变动时，就会执行uglify和reload任务 也可以 gulp.watch(glob[, opts], fn); fn为文件改变后执行的自定义回调。 6. gulp有无return的区别依据gulp官方文档，gulp的task方法是按最大并发执行的，也就是说所有的task都会同时执行，而对于依赖于其他任务的异步task来说，就需要一个通知来告知该什么时候执行。故需要一个return。 gulp.task(&apos;js&apos;, [&apos;css&apos;], function() { // 做一些事 }); // js这个异步任务就需要css任务执行完毕后给一个提示，可以为如下3种方式 // 1.返回一个stream，就是直接return的方式 gulp.task(&apos;css&apos;, function() { var stream = gulp.src(&apos;client/**/*.css&apos;) .pipe(gulp.dest(&apos;build&apos;)); return stream; }); // 2. 返回一个promise gulp.task(&apos;css&apos;, function() { var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() { deferred.resolve(); }, 1); return deferred.promise; }); // 3. 执行一个回调 gulp.task(&apos;css&apos;, function(cb) { exec(&apos;jekyll build&apos;, function(err) { if (err) return cb(err); // 返回 error cb(); // 完成 task }); }); 基本的gulpfile.js示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//引入gulp及其插件模块var gulp = require(&apos;gulp&apos;); //gulp基本包var autoprefixer = require(&apos;gulp-autoprefixer&apos;); //css前缀处理var cssnano = require(&apos;gulp-cssnano&apos;); //css压缩var uglify = require(&apos;gulp-uglify&apos;); //压缩 JavaScriptvar htmlmin = require(&apos;gulp-htmlmin&apos;); //html压缩var imagemin = require(&apos;gulp-imagemin&apos;); //图片压缩//注册样式编译任务gulp.task(&apos;style&apos;, function() &#123; return gulp.src(&apos;src/css/*.css&apos;) .pipe(autoprefixer(&#123;browsers: [ &quot;ie &gt;= 8&quot;, &quot;ie_mob &gt;= 10&quot;, &quot;ff &gt;= 26&quot;, &quot;chrome &gt;= 30&quot;, &quot;safari &gt;= 6&quot;, &quot;opera &gt;= 23&quot;, &quot;ios &gt;= 5&quot;, &quot;android &gt;= 2.3&quot;, &quot;bb &gt;= 10&quot; ]&#125;)) .pipe(cssnano()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;);gulp.task(&apos;image&apos;, function() &#123; return gulp.src(&apos;src/img/**/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/img&apos;));&#125;);gulp.task(&apos;script&apos;, function() &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;);gulp.task(&apos;html&apos;, function() &#123; return gulp.src(&apos;src/*.html&apos;) .pipe(htmlmin(&#123; collapseWhitespace: true, collapseBooleanAttributes: true, removeAttributeQuotes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, &#125;)) .pipe(gulp.dest(&apos;dist&apos;));&#125;);//监听文档gulp.task(&apos;serve&apos;, [&apos;style&apos;, &apos;image&apos;, &apos;script&apos;, &apos;html&apos;], function() &#123; gulp.watch(&apos;src/styles/*.css&apos;, [&apos;style&apos;]); gulp.watch(&apos;src/images/*.*&apos;, [&apos;image&apos;]); gulp.watch(&apos;src/scripts/*.js&apos;, [&apos;script&apos;]); gulp.watch(&apos;src/*.html&apos;, [&apos;html&apos;]);&#125;); gulp@4版本npm install --global gulp-cli npm install --save-dev gulp // 创建gulpfile.js gulp任务：不再支持同步，任务是一个异步函数，可以返回stream、promise、event emitter、child process 或 observable。任务新增public和private类型。 组合任务：以前版本是通过第二个传参为任务名数组将任务进行组合，新版本使用series()和parallel()进行组合，series()用于顺序执行，parallel()用于并发执行。以上两个函数都返回一个新的任务，也就是可以随意嵌套。 任务返回值：stream、promise、event emitter、child process 或 observable。如果任务（task）不返回任何内容，则必须使用 callback 来指示任务已完成。function callbackTask(cb){cb()}。 src()创建一个流，用于从文件系统读取 Vinyl 对象。src(globs, [options])。 const { src, dest } = require(&apos;gulp&apos;); function copy() { return src(&apos;input/*.js&apos;) .pipe(dest(&apos;output/&apos;)); } dest()创建一个用于将 Vinyl 对象写入到文件系统的流。dest(directory, [options])。 series()将任务函数和/或组合操作组合成更大的操作，这些操作将按顺序依次执行。 parallel()将任务功能和/或组合操作组合成同时执行的较大操作。 task()已不在推荐使用，用函数名/series/parallel即可实现任务，gulp默认会执行exports.default的任务函数。 watch()监听 globs 并在发生更改时运行任务。任务与任务系统的其余部分被统一处理。watch(globs, [options], [task])。 const { watch } = require(&apos;gulp&apos;); watch([&apos;input/*.js&apos;, &apos;!input/something.js&apos;], function(cb) { // body omitted cb(); }); lastRun()检索在当前运行进程中成功完成任务的最后一次时间。lastRun(task, [precision])。返回一个时间戳（以毫秒为单位），表示任务的最后完成时间。如果任务尚未运行或已经失败，则返回 undefined。 将上诉改写为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//引入gulp及其插件模块var &#123;src, dest, watch, series, parallel&#125; = require(&apos;gulp&apos;); //gulp基本包var autoprefixer = require(&apos;gulp-autoprefixer&apos;); //css前缀处理var cssnano = require(&apos;gulp-cssnano&apos;); //css压缩var uglify = require(&apos;gulp-uglify&apos;); //压缩 JavaScriptvar htmlmin = require(&apos;gulp-htmlmin&apos;); //html压缩var imagemin = require(&apos;gulp-imagemin&apos;); //图片压缩function style() &#123; return gulp.src(&apos;src/css/*.css&apos;) .pipe(autoprefixer(&#123;browsers: [ &quot;ie &gt;= 8&quot;, &quot;ie_mob &gt;= 10&quot;, &quot;ff &gt;= 26&quot;, &quot;chrome &gt;= 30&quot;, &quot;safari &gt;= 6&quot;, &quot;opera &gt;= 23&quot;, &quot;ios &gt;= 5&quot;, &quot;android &gt;= 2.3&quot;, &quot;bb &gt;= 10&quot; ]&#125;)) .pipe(cssnano()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;function image() &#123; return gulp.src(&apos;src/img/**/*.*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/img&apos;));&#125;function script() &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;));&#125;function html() &#123; return gulp.src(&apos;src/*.html&apos;) .pipe(htmlmin(&#123; collapseWhitespace: true, collapseBooleanAttributes: true, removeAttributeQuotes: true, removeComments: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, &#125;)) .pipe(gulp.dest(&apos;dist&apos;));&#125;function serve() &#123; watch(&apos;src/styles/*.css&apos;, style) watch(&apos;src/images/*.*&apos;, image) watch(&apos;src/scripts/*.js&apos;, script) watch(&apos;src/*.html&apos;, html)&#125;exports.default = series(style, image, script, html, serve) gulp插件编写gulp插件，对stream流操作的一个中间函数，并返回一个数据流。 123456789101112131415161718192021222324252627var gutil = require(&apos;gulp-util&apos;) // gulp工具类var through = require(&apos;through2&apos;) // stream处理var pp = require(&apos;preprocess&apos;) // 文件流转换var PLUGIN_NAME = &apos;PUBSRC&apos; // 插件名称module.exports = function(pubsrc) &#123; pubsrc = pubsrc || &apos;&apos; return through.obj(function(file, enc, cb) &#123; if (file.isNull()) &#123; // 空内容，直接跳过 this.push(file) return cb() &#125; if (file.isStream()) &#123; this.emit(&apos;error&apos;, new gutil.PluginError(PLUGIN_NAME, &apos;Streaming not supported&apos;)) return cb() &#125; var content = pp.preprocess(file.contents.toString(), &#123;&#125;) content = content.replace(/PUBSRC/ig, pubsrc) file.contents = new Buffer(content) // 文件流替换赋值 this.push(file) // 文件流返回 cb() &#125;)&#125; THE END!","tags":[{"name":"js","slug":"js","permalink":"https://naliomg.github.io/tags/js/"}]},{"title":"常用工具网站","date":"2016-12-30T09:43:28.000Z","path":"2016/12/30/常用工具网站/","text":"常用工具网站汇总 png/jpg在线压缩http://tinypng.com 浏览器兼容hack书写http://browserhacks.com/ 浏览器特性支持检测http://caniuse.com/ 字体下载http://www.youziku.com/图标下载http://www.iconfont.cn/字体图标http://fontawesome.dashgame.com/https://icomoon.ioSVG图标下载http://www.iconsvg.com/ npm官网https://www.npmjs.comgulp官网http://gulpjs.com 编程社区，练习https://www.codewars.com 二维码生成http://cli.im/ 贝瑟尔曲线计算函数http://cubic-bezier.com/ 雪碧图制作网站http://spritepad.wearekiss.com/","tags":[{"name":"工具","slug":"工具","permalink":"https://naliomg.github.io/tags/工具/"}]},{"title":"hexo常用指令","date":"2016-12-30T02:02:16.000Z","path":"2016/12/30/hexo常用指令/","text":"hexo常用指令hexonpm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold） hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作 hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git解决方法: npm install hexo-deployer-git --save 2.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 Deployment Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 3.xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt 4.RSS不显示安装RSS插件 npm install hexo-generator-feed --save 5.开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 6.开启评论1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的复制到 themes\\landscape\\layout_partial\\article.ejs把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 改为 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt; 文章摘自：https://segmentfault.com/a/1190000002632530 本主题文档：http://forsigner.com/2016/03/10/fexo-doc-zh-cn/","tags":[{"name":"hexo","slug":"hexo","permalink":"https://naliomg.github.io/tags/hexo/"}]},{"title":"MD基础语法记录","date":"2016-12-29T14:42:45.000Z","path":"2016/12/29/MD基础语法记录/","text":"Markdown 语法的简要规则1. 标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 2. 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 * 无序列表1 * 无序列表2 1. 有序列表1 2. 有序列表2 3. 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可。 例如这样书写 4. 图片与链接插入链接与插入图片的语法很像，区别在一个 ! 号： 图片为：![](){ImgCap}{/ImgCap}链接为：[]() 插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。 5. 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 6. 表格表格是我觉得 Markdown 比较累人的地方，例子如下： | Tables | Are | Cool | \\\\表头 | ------------- |:-------------:| -----:| \\\\表头与主体的分隔，定义对齐方式 | col 3 is | right-aligned | $1600 | \\\\对齐默认为左对齐 | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 7. 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，若要实现行间代码，只需要用两个 ` 把中间的代码包裹起来；若需要使用代码块，使用 tab 键缩进即可。 var a = 9; \\\\这里就是行间代码 var a = 9; \\\\这里就是代码块 8. 分割线分割线的语法只需要三个 * 号，效果如下： 以上就是 Markdown 的基本使用方法，官方说明可参见：http://www.appinn.com/markdown/","tags":[{"name":"md","slug":"md","permalink":"https://naliomg.github.io/tags/md/"}]}]